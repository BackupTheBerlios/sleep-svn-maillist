From rsmudge at mail.berlios.de  Thu Oct 11 03:32:36 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 11 Oct 2007 03:32:36 +0200
Subject: [Sleep-svn] r299 - in sleep: . src/sleep/bridges
	src/sleep/engine/types src/sleep/runtime tests tests/output
Message-ID: <200710110132.l9B1WaHv026440@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-11 03:32:36 +0200 (Thu, 11 Oct 2007)
New Revision: 299

Added:
   sleep/tests/ohash.sl
   sleep/tests/output/ohash.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/engine/types/HashContainer.java
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/whatsnew.txt
Log:
added &ohash(...)



Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2007-09-23 22:30:57 UTC (rev 298)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2007-10-11 01:32:36 UTC (rev 299)
@@ -64,6 +64,7 @@
 
         temp.put("&array", f_array); 
         temp.put("&hash", f_hash);
+        temp.put("&ohash", f_hash);
         temp.put("&@", f_array);
         temp.put("&%", f_hash);  
 
@@ -525,7 +526,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance si, Stack l)
        {
-          Scalar value = SleepUtils.getHashScalar();
+          Scalar value = n.equals("&ohash") ? SleepUtils.getOrderedHashScalar() : SleepUtils.getHashScalar();
            
           while (!l.isEmpty())
           {

Modified: sleep/src/sleep/engine/types/HashContainer.java
===================================================================
--- sleep/src/sleep/engine/types/HashContainer.java	2007-09-23 22:30:57 UTC (rev 298)
+++ sleep/src/sleep/engine/types/HashContainer.java	2007-10-11 01:32:36 UTC (rev 299)
@@ -4,13 +4,23 @@
 
 import java.util.*;
 
+/* Container for Sleep hashes.  *phEAR* */
 public class HashContainer implements ScalarHash
 {
-   protected HashMap values;
+   protected Map values;
 
+   /* constructs this hash container using the specified Map compatible data structure as the
+      backing.  this data structure will hold sleep.runtime.Scalar objects and should by empty
+      when passed to this constructor */
+   public HashContainer(Map container)
+   {
+      values = container;
+   }
+
+   /* constructs this hash container backed by a HashMap data structure */
    public HashContainer()
    {
-      values = new HashMap();
+      this(new HashMap());
    }
 
    public Scalar getAt(Scalar key)

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2007-09-23 22:30:57 UTC (rev 298)
+++ sleep/src/sleep/runtime/SleepUtils.java	2007-10-11 01:32:36 UTC (rev 299)
@@ -457,6 +457,15 @@
       return temp;
    }
 
+   /** returns an empty ordered hashmap scalar */
+   public static Scalar getOrderedHashScalar()
+   {
+      Scalar temp = new Scalar();
+      temp.setValue(new HashContainer(new LinkedHashMap()));
+
+      return temp;
+   }
+
    /** returns an int scalar with value x */
    public static Scalar getScalar(int x)
    {

Added: sleep/tests/ohash.sl
===================================================================
--- sleep/tests/ohash.sl	2007-09-23 22:30:57 UTC (rev 298)
+++ sleep/tests/ohash.sl	2007-10-11 01:32:36 UTC (rev 299)
@@ -0,0 +1,34 @@
+#
+# test of the pHEARsome ordered hash.
+#
+
+%hash = ohash(a => "apple", c => "cat", d => "dog", p => "pHEAR", aa => 33, b => 56L);
+println(%hash);
+
+foreach $key => $value (%hash)
+{
+   println("$[10]key is $value");
+}
+
+%hash["a"] = $null;
+%hash["a"] = "ordered insert...";  # in this case a will just be updated.
+
+println(%hash);
+
+%hash["a"] = $null; 
+
+println(%hash);
+
+%hash["a"] = "at the end";
+
+println(%hash);
+
+%phear = %hash;
+%phear["zzz"] = "this is at the end of phear";
+println(%phear);
+
+%copy = ohash(begin => "front end");
+putAll(%copy, keys(%phear), values(%phear));
+
+println(%copy);
+println(%phear);

Added: sleep/tests/output/ohash.sl
===================================================================
--- sleep/tests/output/ohash.sl	2007-09-23 22:30:57 UTC (rev 298)
+++ sleep/tests/output/ohash.sl	2007-10-11 01:32:36 UTC (rev 299)
@@ -0,0 +1,13 @@
+%(a => 'apple', c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L)
+a          is apple
+c          is cat
+d          is dog
+p          is pHEAR
+aa         is 33
+b          is 56
+%(a => 'ordered insert...', c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L)
+%(c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L)
+%(c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L, a => 'at the end')
+%(c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L, a => 'at the end', zzz => 'this is at the end of phear')
+%(begin => 'front end', c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L, a => 'at the end', zzz => 'this is at the end of phear')
+%(c => 'cat', d => 'dog', p => 'pHEAR', aa => 33, b => 56L, a => 'at the end', zzz => 'this is at the end of phear')

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-09-23 22:30:57 UTC (rev 298)
+++ sleep/whatsnew.txt	2007-10-11 01:32:36 UTC (rev 299)
@@ -7,6 +7,8 @@
   deserializing Sleep functions.  
 - closure context metadata (regex matcher and iterator for foreach 
   loops) is no longer serialized with the closure...  beware of this.
+- added &ohash(...) to initialize a Sleep hash that keeps track of
+  key insertion order.  requested by Marty.
 
 2.1-beta 18  (5 Jul 07)
 ===========



From rsmudge at mail.berlios.de  Thu Oct 11 04:13:33 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 11 Oct 2007 04:13:33 +0200
Subject: [Sleep-svn] r300 - in sleep: . src/sleep/bridges
	src/sleep/bridges/io
Message-ID: <200710110213.l9B2DXKK028030@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-11 04:13:33 +0200 (Thu, 11 Oct 2007)
New Revision: 300

Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/bridges/io/SocketObject.java
   sleep/whatsnew.txt
Log:
updates to allow additional socket parameters... may add some more yet :)


Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2007-10-11 01:32:36 UTC (rev 299)
+++ sleep/src/sleep/bridges/BasicIO.java	2007-10-11 02:13:33 UTC (rev 300)
@@ -486,17 +486,24 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          SocketHandler handler = new SocketHandler();
+          Map options = BridgeUtilities.extractNamedParameters(l);
+
+          SocketObject.SocketHandler handler = new SocketObject.SocketHandler();
           handler.socket        = new SocketObject();
           handler.script        = i;
 
+          handler.lport    = options.containsKey("lport") ? ((Scalar)options.get("lport")).intValue() : 0; /* 0 means use any free port */
+          handler.laddr    = options.containsKey("laddr") ? ((Scalar)options.get("laddr")).toString() : null;
+          handler.linger   = options.containsKey("linger") ? ((Scalar)options.get("linger")).intValue() : 5; /* 5ms is the default linger */
+          handler.backlog  = options.containsKey("backlog") ? ((Scalar)options.get("backlog")).intValue() : 0; /* backlog of 0 means use default */
+
           if (n.equals("&listen"))
           {
              handler.port     = BridgeUtilities.getInt(l, -1);          // port
              handler.timeout  = BridgeUtilities.getInt(l, 60 * 1000);   // timeout
              handler.callback = BridgeUtilities.getScalar(l);           // scalar to put info in to
 
-             handler.type     = LISTEN_FUNCTION;
+             handler.type     = SocketObject.LISTEN_FUNCTION;
           }
           else
           {
@@ -504,7 +511,7 @@
              handler.port     = BridgeUtilities.getInt(l, 1);
              handler.timeout  = BridgeUtilities.getInt(l, 60 * 1000);   // timeout
 
-             handler.type     = CONNECT_FUNCTION;
+             handler.type     = SocketObject.CONNECT_FUNCTION;
           }
           
           if (!l.isEmpty())
@@ -1433,53 +1440,4 @@
           }
        }
     }
-
-    private static final int LISTEN_FUNCTION  = 1;
-    private static final int CONNECT_FUNCTION = 2;
-
-    private static class SocketHandler implements Runnable
-    {
-       public ScriptInstance script;
-       public SleepClosure   function;
-       public SocketObject   socket;
-
-       public int            port;
-       public int            timeout;
-       public String         host;
-       public Scalar         callback;
-
-       public int            type;
-
-       public void start()
-       {
-          if (function != null)
-          {
-             socket.setThread(new Thread(this));
-             socket.getThread().start();
-          }
-          else
-          {
-             run();
-          }
-       }
-
-       public void run()
-       {
-          if (type == LISTEN_FUNCTION)
-          {
-             socket.listen(port, timeout, callback, script.getScriptEnvironment());
-          }
-          else
-          {
-             socket.open(host, port, timeout, script.getScriptEnvironment());
-          }
-
-          if (function != null)
-          {
-             Stack  args  = new Stack();
-             args.push(SleepUtils.getScalar(socket));
-             function.callClosure("&callback", script, args);
-          }
-       }
-    }
 }

Modified: sleep/src/sleep/bridges/io/SocketObject.java
===================================================================
--- sleep/src/sleep/bridges/io/SocketObject.java	2007-10-11 01:32:36 UTC (rev 299)
+++ sleep/src/sleep/bridges/io/SocketObject.java	2007-10-11 02:13:33 UTC (rev 300)
@@ -3,6 +3,7 @@
 import java.io.*;
 import java.net.*;
 import sleep.runtime.*;
+import sleep.bridges.SleepClosure;
 
 import java.util.*;
 
@@ -16,15 +17,21 @@
       return socket;
    }
 
-   public void open(String server, int port, int timeout, ScriptEnvironment env)
+   public void open(SocketHandler params, ScriptEnvironment env)
    {
       try
       {
          socket = new Socket();
+         
+         if (params.laddr != null)
+         {
+            socket.bind(new InetSocketAddress(params.laddr, params.lport));
+         }
 
-         socket.connect(new InetSocketAddress(server, port), timeout);
-         socket.setSoLinger(true, 5);
+         socket.connect(new InetSocketAddress(params.host, params.port), params.timeout);
 
+         socket.setSoLinger(true, params.linger);
+
          openRead(socket.getInputStream());
          openWrite(socket.getOutputStream());
       }
@@ -58,7 +65,7 @@
 
    private static Map servers;
 
-   private static ServerSocket getServerSocket(int port) throws Exception
+   private static ServerSocket getServerSocket(int port, SocketHandler params) throws Exception
    {
       String key = port + "";
 
@@ -75,32 +82,27 @@
       }
       else
       {
-         server = new ServerSocket(port);
+         server = new ServerSocket(port, params.backlog, params.laddr != null ? InetAddress.getByName(params.laddr) : null);
          servers.put(key, server);
       }
 
       return server;
    }
  
-   public void listen(int port, int timeout, Scalar data, ScriptEnvironment env)
+   public void listen(SocketHandler params, ScriptEnvironment env)
    {
       ServerSocket server = null;
 
       try
       {
-//         server = new ServerSocket(port);
-         server = getServerSocket(port);
-         server.setSoTimeout(timeout);
+         server = getServerSocket(params.port, params);
+         server.setSoTimeout(params.timeout);
         
          socket = server.accept();
-         socket.setSoLinger(true, 5);
+         socket.setSoLinger(true, params.linger);
 
-  //       server.close();
- /* releases the bound and listening port, probably not a good idea for a massive server but for a scripting
-                            lang API who cares */
+         params.callback.setValue(SleepUtils.getScalar(socket.getInetAddress().getHostAddress()));
 
-         data.setValue(SleepUtils.getScalar(socket.getInetAddress().getHostAddress()));
-
          openRead(socket.getInputStream());
          openWrite(socket.getOutputStream());
 
@@ -110,12 +112,6 @@
       {
          env.flagError(ex);
       }
-
-      try
-      {
-//         if (server != null) { server.close(); }
-      }
-      catch (Exception ex) { }
    }
 
    public void close()
@@ -128,4 +124,57 @@
 
       super.close();
    }
+
+    public static final int LISTEN_FUNCTION  = 1;
+    public static final int CONNECT_FUNCTION = 2;
+
+    public static class SocketHandler implements Runnable
+    {
+       public ScriptInstance script;
+       public SleepClosure   function;
+       public SocketObject   socket;
+
+       public int            port;
+       public int            timeout;
+       public String         host;
+       public Scalar         callback;
+
+       public int            type;
+       public String         laddr;
+       public int            lport;
+       public int            linger;
+       public int            backlog;
+
+       public void start()
+       {
+          if (function != null)
+          {
+             socket.setThread(new Thread(this));
+             socket.getThread().start();
+          }
+          else
+          {
+             run();
+          }
+       }
+
+       public void run()
+       {
+          if (type == LISTEN_FUNCTION)
+          {
+             socket.listen(this, script.getScriptEnvironment());
+          }
+          else
+          {
+             socket.open(this, script.getScriptEnvironment());
+          }
+
+          if (function != null)
+          {
+             Stack  args  = new Stack();
+             args.push(SleepUtils.getScalar(socket));
+             function.callClosure("&callback", script, args);
+          }
+       }
+    }
 }

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-11 01:32:36 UTC (rev 299)
+++ sleep/whatsnew.txt	2007-10-11 02:13:33 UTC (rev 300)
@@ -9,7 +9,27 @@
   loops) is no longer serialized with the closure...  beware of this.
 - added &ohash(...) to initialize a Sleep hash that keeps track of
   key insertion order.  requested by Marty.
+- updated the sleep listen(...) and connect(...) functions to accept a
+  number of key/value options.  options include:
+     linger  => the value of SO_LINGER (how long (ms) the socket waits 
+               for a TCP reset before actually closing.
+     lport   => the local port to bind to
+     laddr   => the local address to bind to
+     backlog => the number of connections to queue while waiting for
+                a subsequent call of listen(...) to accept a 
+                connection.
 
+   for example, to listen on port 8888 of 192.168.1.1 while allowing
+   only 1 connection:
+ 
+   $handle = listen(8888, laddr => "192.168.1.1", backlog => 1)
+   
+   listen will only honor the extra parameters the first time the 
+   port is intialized.  the extra params will have no effect on 
+   subsequent calls to listen.  to fix this call closef(port) to
+   unbind the specified port.
+
+
 2.1-beta 18  (5 Jul 07)
 ===========
 - added scalar references: \$x is equivalent to $x => $x.  this sugar



From rsmudge at mail.berlios.de  Sun Oct 14 02:15:39 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sun, 14 Oct 2007 02:15:39 +0200
Subject: [Sleep-svn] r301 - in sleep: . src/sleep/bridges src/sleep/engine
	src/sleep/engine/atoms src/sleep/runtime tests tests/output
Message-ID: <200710140015.l9E0FdqJ010608@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-14 02:15:34 +0200 (Sun, 14 Oct 2007)
New Revision: 301

Added:
   sleep/src/sleep/engine/CallRequest.java
   sleep/tests/inline.sl
   sleep/tests/output/inline.sl
Modified:
   sleep/src/sleep/bridges/BridgeUtilities.java
   sleep/src/sleep/bridges/DefaultEnvironment.java
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/engine/atoms/Call.java
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/src/sleep/runtime/ScriptEnvironment.java
   sleep/tests/output/cast.sl
   sleep/tests/output/convertds3.sl
   sleep/tests/output/forker.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
added inline functions (halfway, minus some error checking yet :)) and refactored the function call debug logic flow (little more to do yet)


Modified: sleep/src/sleep/bridges/BridgeUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BridgeUtilities.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/bridges/BridgeUtilities.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -23,8 +23,9 @@
 
 import sleep.runtime.*;
 import java.io.File;
-import sleep.interfaces.Function;
+import sleep.interfaces.*;
 import java.util.*;
+import sleep.engine.types.*;
 
 /**
  * A bridge is a class that bridges your applications API and sleep.  Bridges are created using interfaces from the sleep.interfaces package.  Arguments are passed to bridges generally in a java.util.Stack form.  The Stack of arguments contains sleep Scalar objects.  The BridgeUtilities makes it safer and easier for you to extract Java types from arguments.
@@ -311,6 +312,38 @@
       return toValue;
    }
 
+   /** initializes local scope based on argument stack */
+   public static int initLocalScope(ScriptVariables vars, Variable localLevel, Stack locals)
+   {
+      int name = 1;
+
+      while (!locals.isEmpty())
+      {
+         Scalar lvar = (Scalar)locals.pop();
+
+         if (lvar.getActualValue() != null && lvar.getActualValue().getClass() == ObjectValue.class && lvar.getActualValue().objectValue() != null && lvar.getActualValue().objectValue().getClass() == KeyValuePair.class)
+         {
+            KeyValuePair kvp = (KeyValuePair)lvar.getActualValue().objectValue();
+
+            if (!sleep.parser.Checkers.isVariable(kvp.getKey().toString()))
+            {
+               throw new IllegalArgumentException("unreachable named parameter: " + kvp.getKey());
+            }
+            else
+            {
+               vars.setScalarLevel(kvp.getKey().toString(), kvp.getValue(), localLevel);
+            }
+         }
+         else
+         {
+            vars.setScalarLevel("$"+name, lvar, localLevel);
+            name++;
+         }
+      }
+
+      return name;
+   }
+
    /** normalizes the index value based on the specified length */
    public static final int normalize(int value, int length)
    {

Modified: sleep/src/sleep/bridges/DefaultEnvironment.java
===================================================================
--- sleep/src/sleep/bridges/DefaultEnvironment.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/bridges/DefaultEnvironment.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -92,7 +92,8 @@
         //
         // tell the environment that we want subroutine's to be bound here
         //
-        env.put("sub",   this);
+        env.put("sub",    this);
+        env.put("inline", this);
 
         return true;
     }
@@ -101,20 +102,27 @@
     {
         Hashtable env = si.getScriptEnvironment().getEnvironment(); // assuming the environment is shared. hah right
 
-        Stack unloadStack;
-
-        if (env.get("&"+name) != null && env.get("&"+name) instanceof BasicSubroutine)
+        if (type.equals("sub"))
         {
-            BasicSubroutine temp = (BasicSubroutine)env.get("&"+name);
-            unloadStack = temp.getUnloadStack();
+           Stack unloadStack;
 
-            unloadStack.push(temp); // make this instance of BasicSubroutine available in case the main one gets unloaded
+           if (env.get("&"+name) != null && env.get("&"+name) instanceof BasicSubroutine)
+           {
+               BasicSubroutine temp = (BasicSubroutine)env.get("&"+name);
+               unloadStack = temp.getUnloadStack();
+
+               unloadStack.push(temp); // make this instance of BasicSubroutine available in case the main one gets unloaded
+           }
+           else
+           {
+               unloadStack = new Stack();
+           }
+
+           env.put("&"+name, new BasicSubroutine(si, code, unloadStack));
         }
-        else
+        else if (type.equals("inline"))
         {
-            unloadStack = new Stack();
+           env.put("^&"+name, code); /* add an inline function, very harmless */
         }
-
-        env.put("&"+name, new BasicSubroutine(si, code, unloadStack));
     }
 }

Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/bridges/SleepClosure.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -192,37 +192,11 @@
              vars.pushLocalLevel(localLevel);
           }
 
-          vars.setScalarLevel("$0", SleepUtils.getScalar(message), localLevel);
-
           //
-          // setup the parameters from the stack based since this is
-          // the default function environment.
+          // initialize local variables...
           //
-          int name = 1;
-          while (!locals.isEmpty())
-          {
-             Scalar lvar = (Scalar)locals.pop();
-
-             if (lvar.getActualValue() != null && lvar.getActualValue().getClass() == ObjectValue.class && lvar.getActualValue().objectValue() != null && lvar.getActualValue().objectValue().getClass() == KeyValuePair.class)
-             {
-                KeyValuePair kvp = (KeyValuePair)lvar.getActualValue().objectValue();
-
-                if (!sleep.parser.Checkers.isVariable(kvp.getKey().toString()))
-                {
-                   throw new IllegalArgumentException("unreachable named parameter: " + kvp.getKey());
-                }
-                else
-                {
-                   vars.setScalarLevel(kvp.getKey().toString(), kvp.getValue(), localLevel);
-                }
-             } 
-             else
-             {
-                vars.setScalarLevel("$"+name, lvar, localLevel);
-                name++;
-             }
-          }
-
+          vars.setScalarLevel("$0", SleepUtils.getScalar(message), localLevel);
+          int name = BridgeUtilities.initLocalScope(vars, localLevel, locals);
           vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(name, localLevel)), localLevel);
 
           //

Added: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/engine/CallRequest.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -0,0 +1,122 @@
+package sleep.engine;
+
+import sleep.engine.*;
+import sleep.runtime.*;
+
+/** this class encapsulates a function call request. sleep has so many reasons, places, and ways to call functions.
+    this class helps to avoid duplicate code and manage the complexity of Sleep's myriad of profiling, tracing, and error reporting
+    options. */
+public abstract class CallRequest
+{
+   protected ScriptEnvironment environment;
+   protected int               lineNumber;
+
+   /** initialize a new call request */
+   public CallRequest(ScriptEnvironment e, int lineNo)
+   {
+      environment = e;
+      lineNumber  = lineNo;
+   }
+
+   /** returns the script environment... pHEAR */
+   protected ScriptEnvironment getScriptEnvironment()
+   {
+      return environment;      
+   }
+
+   /** returns the line number this function call is occuring from */
+   public int getLineNumber()
+   {
+      return lineNumber;
+   }
+
+   /** return the name of the function (for use in profiler statistics) */
+   public abstract String getFunctionName();
+
+   /** return the description of this current stack frame in the event of an exception */
+   public abstract String getFrameDescription();
+
+   /** execute the function call contained here */
+   protected abstract Scalar execute();
+
+   /** return a string view of this function call; arguments are captured as comma separated descriptions of all args */
+   protected abstract String formatCall(String args);
+
+   /** return true if debug trace is enabled.  override this to add/change criteria for trace activiation */
+   public boolean isDebug()
+   {
+      return (getScriptEnvironment().getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+   }
+
+   /** actually execute the function call */
+   public void CallFunction()
+   {
+      Scalar temp;
+      ScriptEnvironment e = getScriptEnvironment();
+      int mark = getScriptEnvironment().markFrame();
+
+      if (isDebug())
+      {
+         if (e.getScriptInstance().isProfileOnly())
+         {
+             long stat = System.currentTimeMillis();
+             temp = execute();
+             stat = System.currentTimeMillis() - stat;
+             e.getScriptInstance().collect(getFunctionName(), getLineNumber(), stat);
+         }
+         else
+         {
+             String args = SleepUtils.describe(e.getCurrentFrame());
+
+             try
+             {
+                long stat = System.currentTimeMillis();
+                temp = execute();
+                stat = System.currentTimeMillis() - stat;
+                e.getScriptInstance().collect(getFunctionName(), getLineNumber(), stat);
+
+                if (e.isThrownValue())
+                {
+                   e.getScriptInstance().fireWarning(formatCall(args) + " - FAILED!", getLineNumber(), true);
+                }
+                else if (SleepUtils.isEmptyScalar(temp))
+                {
+                   e.getScriptInstance().fireWarning(formatCall(args), getLineNumber(), true);
+                }
+                else
+                {
+                   e.getScriptInstance().fireWarning(formatCall(args) + " = " + SleepUtils.describe(temp), getLineNumber(), true);
+                }
+             }
+             catch (RuntimeException rex)
+             {
+                e.cleanFrame(mark);
+                e.KillFrame();
+                e.getScriptInstance().fireWarning(formatCall(args) + " - FAILED!", getLineNumber(), true);
+                throw(rex);
+             }
+         }
+      }
+      else
+      {
+         try
+         {
+             temp = execute();
+         }
+         catch (RuntimeException rex)
+         {
+             e.cleanFrame(mark);
+             e.KillFrame();
+             throw(rex);
+         }
+      }
+
+      if (e.isThrownValue())
+      {
+         e.getScriptInstance().recordStackFrame(getFrameDescription(), getLineNumber());
+      }
+
+      e.cleanFrame(mark);
+      e.FrameResult(temp);
+   }
+}

Modified: sleep/src/sleep/engine/atoms/Call.java
===================================================================
--- sleep/src/sleep/engine/atoms/Call.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/engine/atoms/Call.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -41,97 +41,114 @@
    {
       return prefix + "[Function Call]: "+function+"\n";
    }
-  
+
+   private static class FunctionCallRequest extends CallRequest
+   {
+      protected String function;
+      protected Function callme;
+
+      public FunctionCallRequest(ScriptEnvironment e, int lineNo, String functionName, Function f)
+      {
+         super(e, lineNo);
+         function = functionName;
+         callme   = f;
+      }
+
+      public String getFunctionName()
+      {
+         return function;
+      }
+
+      public String getFrameDescription()    
+      {
+         return function + "()";
+      }
+
+      public String formatCall(String args) 
+      {
+         return function + "(" + args + ")";
+      }
+
+      public boolean isDebug()
+      {
+         return super.isDebug() && !function.equals("&@") && !function.equals("&%");
+      }
+
+      protected Scalar execute()
+      {
+         Scalar temp = callme.evaluate(function, getScriptEnvironment().getScriptInstance(), getScriptEnvironment().getCurrentFrame());
+         getScriptEnvironment().clearReturn();
+         return temp;
+      }
+   }
+
+   private static class InlineCallRequest extends CallRequest
+   {
+      protected String function;
+      protected Block  inline;
+
+      public InlineCallRequest(ScriptEnvironment e, int lineNo, String functionName, Block i)
+      {
+         super(e, lineNo);
+         function = functionName;
+         inline   = i;
+      }
+
+      public String getFunctionName()
+      {
+         return "<inline> " + function;
+      }
+
+      public String getFrameDescription()    
+      {
+         return "<inline> " + function + "()";
+      }
+
+      protected String formatCall(String args) 
+      {
+         return "<inline> " + function + "(" + args + ")";
+      }
+
+      protected Scalar execute()
+      {
+         ScriptVariables vars = getScriptEnvironment().getScriptVariables();
+         synchronized (vars)
+         {
+            Variable localLevel = vars.getLocalVariables();
+            sleep.bridges.BridgeUtilities.initLocalScope(vars, localLevel, getScriptEnvironment().getCurrentFrame());
+            return inline.evaluate(getScriptEnvironment());
+         }
+      }
+   }
+
+	  
    // Pre Condition:
    //  arguments on the current stack (to allow stack to be passed0
    //
    // Post Condition:
    //  current frame will be dissolved and return value will be placed on parent frame
 
-
    public Scalar evaluate(ScriptEnvironment e)
    {
-      Scalar temp = null;
       Function callme = e.getFunction(function);
+      Block    inline = null;
 
-      int mark = e.markFrame();
-
       if (callme != null)
       {
-         if ((e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS && !function.equals("&@") && !function.equals("&%"))
-         {
-             if (e.getScriptInstance().isProfileOnly())
-             {
-                long stat = System.currentTimeMillis();
-                temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
-                e.clearReturn();
-                stat = System.currentTimeMillis() - stat;
-                e.getScriptInstance().collect(function, getLineNumber(), stat); 
-             }
-             else
-             {
-                String args = SleepUtils.describe(e.getCurrentFrame());
-
-                String message = function + "(" + args + ")";
-                try
-                {
-                   long stat = System.currentTimeMillis();
-                   temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
-                   e.clearReturn();
-                   stat = System.currentTimeMillis() - stat;
-                   e.getScriptInstance().collect(function, getLineNumber(), stat); /* add to the profiler, plz */
-                
-                   if (e.isThrownValue())
-                   {
-                      e.getScriptInstance().fireWarning(message + " - FAILED!", getLineNumber(), true);
-                   }
-                   else if (SleepUtils.isEmptyScalar(temp))
-                   {
-                      e.getScriptInstance().fireWarning(message, getLineNumber(), true);
-                   }
-                   else
-                   {
-                      e.getScriptInstance().fireWarning(message + " = " + SleepUtils.describe(temp), getLineNumber(), true);
-                   }
-                }
-                catch (RuntimeException rex)
-                {
-                   e.cleanFrame(mark);
-                   e.KillFrame();
-                   e.getScriptInstance().fireWarning(message + " - FAILED!", getLineNumber(), true);
-                   throw(rex);
-                }
-             }
-         }
-         else
-         {
-             try
-             {
-                temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
-                e.clearReturn();
-             }
-             catch (RuntimeException rex)
-             {
-                e.cleanFrame(mark);
-                e.KillFrame();
-                throw(rex);
-             }
-         }
-
-         if (e.isThrownValue())
-         {
-             e.getScriptInstance().recordStackFrame(function + "()", getLineNumber());
-         }
+         FunctionCallRequest request = new FunctionCallRequest(e, getLineNumber(), function, callme);         
+         request.CallFunction();
       }
+      else if ((inline = e.getBlock(function)) != null)
+      {
+         InlineCallRequest request = new InlineCallRequest(e, getLineNumber(), function, inline);
+         request.CallFunction();
+      }
       else
       {
          e.getScriptInstance().fireWarning("Attempted to call non-existent function " + function, getLineNumber());
-         temp = SleepUtils.getEmptyScalar();
+         e.FrameResult(SleepUtils.getEmptyScalar());
       }
 
-      e.cleanFrame(mark);
-      e.FrameResult(temp);
-
       return null;
    }
 }

Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -46,6 +46,58 @@
       return "[Object Access]: "+classRef+"#"+name+"\n";
    }
 
+   private static class ClosureCallRequest extends CallRequest
+   {
+      protected String name;
+      protected Scalar scalar;
+
+      public ClosureCallRequest(ScriptEnvironment e, int lineNo, Scalar _scalar, String _name)
+      {
+         super(e, lineNo);
+         scalar = _scalar;
+         name   = _name;
+      }
+
+      public String getFunctionName()
+      {
+         return ((SleepClosure)scalar.objectValue()).toStringGeneric();
+      }
+
+      public String getFrameDescription()
+      {
+         return scalar.toString();   
+      }
+
+      public String formatCall(String args)
+      {
+         StringBuffer buffer = new StringBuffer("[" + SleepUtils.describe(scalar));
+         
+         if (name != null && name.length() > 0)
+         {
+            buffer.append(" " + name);
+         }
+
+         if (args.length() > 0)
+         {
+            buffer.append(": " + args);
+         }
+
+         buffer.append("]");
+
+         return buffer.toString();
+      }
+
+      protected Scalar execute()
+      {
+         Function func = SleepUtils.getFunctionFromScalar(scalar, getScriptEnvironment().getScriptInstance());
+
+         Scalar result;
+         result = func.evaluate(name, getScriptEnvironment().getScriptInstance(), getScriptEnvironment().getCurrentFrame());
+         getScriptEnvironment().clearReturn();
+         return result;
+      }
+   }
+
    //
    // Pre Condition:
    //   object we're accessing is top item on current frame
@@ -57,8 +109,7 @@
 
    public Scalar evaluate(ScriptEnvironment e)
    {
-      boolean isTrace   = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
-
+      int mark = e.markFrame();
       Scalar result = SleepUtils.getEmptyScalar();
 
       Object accessMe = null;
@@ -66,8 +117,6 @@
 
       Scalar scalar   = null;
 
-      int mark = e.markFrame();
-
       if (classRef == null)
       {
          scalar    = (Scalar)e.getCurrentFrame().pop();
@@ -94,94 +143,18 @@
       //
       // check if this is a closure, if it is, try to invoke stuff on it instead
       //
+
       if (scalar != null && SleepUtils.isFunctionScalar(scalar))
       {
-         Function func = SleepUtils.getFunctionFromScalar(scalar, e.getScriptInstance());
-
-         if (isTrace)
-         {
-            if (e.getScriptInstance().isProfileOnly())
-            {
-               long stat = System.currentTimeMillis();
-               result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
-               e.clearReturn();
-               stat = System.currentTimeMillis() - stat;
-               e.getScriptInstance().collect(((SleepClosure)scalar.objectValue()).toStringGeneric(), getLineNumber(), stat);
-            }
-            else
-            {
-               String args = SleepUtils.describe(e.getCurrentFrame());
-
-               /* construct the actual trace message */
-   
-               StringBuffer trace = new StringBuffer("[" + SleepUtils.describe(scalar));
-            
-               if (name != null && name.length() > 0)
-               {
-                  trace.append(" " + name);
-               }
-
-               if (args.length() > 0)
-               {
-                  trace.append(": " + args + "]");
-               }
-               else
-               {
-                  trace.append("]");
-               }
-
-               try
-               {
-                  long stat = System.currentTimeMillis();
-
-                  result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
-                  e.clearReturn();
-
-                  stat = System.currentTimeMillis() - stat;
-                  e.getScriptInstance().collect(((SleepClosure)scalar.objectValue()).toStringGeneric(), getLineNumber(), stat);
-
-                  if (!SleepUtils.isEmptyScalar(result))
-                  {
-                     trace.append(" = " + SleepUtils.describe(result));
-                  }
-
-                  e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
-               }
-               catch (RuntimeException rex)
-               {
-                  e.cleanFrame(mark);
-                  e.KillFrame();
-                  trace.append(" - FAILED!");
-                  e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
-                  throw(rex);
-               }
-            }
-         }
-         else
-         {
-            try
-            {
-               result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
-               e.clearReturn();
-            }
-            catch (RuntimeException rex)
-            {
-               e.cleanFrame(mark);
-               e.KillFrame();
-               throw(rex);
-            }
-         }         
-
-         if (e.isThrownValue())
-         {
-            e.getScriptInstance().recordStackFrame(scalar.toString(), getLineNumber());
-         }
-         
-         e.cleanFrame(mark);
-         e.FrameResult(result);
+         ClosureCallRequest request = new ClosureCallRequest(e, getLineNumber(), scalar, name);
+         request.CallFunction();
          return null;
       }
 
+      //
+      // now we know we're not dealing with a closure; so before we go on the name field has to be non-null.
+      //
+
       if (name == null)
       {
          e.getScriptInstance().fireWarning("Attempted to query an object with no method/field", getLineNumber());
@@ -192,9 +165,12 @@
          return null;
       }
 
+      boolean isTrace   = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+
       //
       // try to invoke stuff on the object...
       //
+
       Method theMethod    = null;
       Object[] parameters = null;
 

Modified: sleep/src/sleep/runtime/ScriptEnvironment.java
===================================================================
--- sleep/src/sleep/runtime/ScriptEnvironment.java	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/src/sleep/runtime/ScriptEnvironment.java	2007-10-14 00:15:34 UTC (rev 301)
@@ -147,6 +147,11 @@
     {
        getScriptVariables().putScalar(key, value);
     }
+
+    public Block getBlock(String name)
+    {
+       return (Block)(getEnvironment().get("^" + name));
+    }   
  
     public Function getFunction(String func)
     {

Added: sleep/tests/inline.sl
===================================================================
--- sleep/tests/inline.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/inline.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -0,0 +1,120 @@
+#
+# test out inline functions... pHEAR continuation like behavior.
+#
+
+# simplest test
+
+inline foo
+{
+   println("foo");
+   return "foo rules!";
+}
+
+sub bar
+{
+   println("bar");
+   foo();
+   return "bar rules";
+}
+
+println(bar());
+
+# coroutines test
+
+inline blah
+{
+   println("blah 1");
+   yield "pHEAR";
+   println("blah 3");
+}
+
+sub bleh
+{
+   println("bleh 0");
+   blah();
+   println("bleh 2");
+}
+
+while $value (bleh())
+{
+   println("Returned $value");
+}
+
+# inline locals access and arguments test.
+
+inline ltest
+{
+   println("@_ = " . @_);
+   println("Arg: $1");
+   println("\$foo: $foo");
+   println("\$this: $this");
+   println("\$key: $key");
+   $foo = "pHEAR";
+}
+
+sub lfunc
+{
+   local('$foo');
+   $foo = 'uNF';
+   ltest("aa", "bbb", $key => "some value", "cccc");
+   println($foo);
+}
+
+lfunc();
+
+#
+# traces..
+#
+
+debug(debug() | 15);
+bar();
+debug(debug() & not(15));
+
+#
+# exceptions..
+#
+
+inline except
+{
+   throw 33;
+}
+
+sub extest
+{
+   local('$ex');
+
+   try
+   {
+      except();
+   }
+   catch $ex
+   {
+      println($ex);
+      printAll(getStackTrace());
+   }
+}
+
+extest();
+
+#
+# test out serialization of a coroutine using inline function calls
+#
+
+sub testit
+{
+   local('$object $buffer');
+
+   $buffer = allocate();
+   $object = lambda(&bleh);
+   println("Result: " . [$object]);   
+
+   writeObject($buffer, $object);
+   closef($buffer); # close write-mode, enable read-mode
+
+   $object = readObject($buffer);
+   println("Result: " . [$object]);
+
+   closef($buffer); # close buffer for all time
+}
+
+testit();

Modified: sleep/tests/output/cast.sl
===================================================================
--- sleep/tests/output/cast.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/output/cast.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -1,2 +1,2 @@
-[Ljava.lang.CharSequence;@697b67 class [Ljava.lang.CharSequence;
-[Ljava.util.List;@d439fe class [Ljava.util.List;
+[Ljava.lang.CharSequence;@6b496d class [Ljava.lang.CharSequence;
+[Ljava.util.List;@648016 class [Ljava.util.List;

Modified: sleep/tests/output/convertds3.sl
===================================================================
--- sleep/tests/output/convertds3.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/output/convertds3.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -32,9 +32,9 @@
 int[] a
 Collection a
 Collection a
-Warning: there is no method that matches mar([Z at 1a1399) in sleep.ArrayTest1 at convertds3.sl:36
-Warning: there is no method that matches mar([F at fcc0a2) in sleep.ArrayTest1 at convertds3.sl:37
-Warning: there is no method that matches mar([Ljava.lang.Object;@caf6c1) in sleep.ArrayTest1 at convertds3.sl:38
+Warning: there is no method that matches mar([Z at 19762f) in sleep.ArrayTest1 at convertds3.sl:36
+Warning: there is no method that matches mar([F at 9e215b) in sleep.ArrayTest1 at convertds3.sl:37
+Warning: there is no method that matches mar([Ljava.lang.Object;@9ff0a8) in sleep.ArrayTest1 at convertds3.sl:38
 int[] a
 Collection a
 Collection a

Modified: sleep/tests/output/forker.sl
===================================================================
--- sleep/tests/output/forker.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/output/forker.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -1,4 +1,4 @@
 Trace: &check('within fork') at forker.sl:9
-Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at d381d2 at forker.sl:8
+Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at 9c2715 at forker.sl:8
 Trace: &sleep(1000) at forker.sl:12
 Trace: &check('outside of fork') at forker.sl:14

Added: sleep/tests/output/inline.sl
===================================================================
--- sleep/tests/output/inline.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/output/inline.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -0,0 +1,31 @@
+bar
+foo
+foo rules!
+bleh 0
+blah 1
+Returned pHEAR
+blah 3
+bleh 2
+ at _ = @()
+Arg: aa
+$foo: uNF
+$this: &closure[inline.sl:57-60]#3
+$key: some value
+pHEAR
+bar
+Trace: &println('bar') at inline.sl:15
+foo
+Trace: &println('foo') at inline.sl:9
+Trace: <inline> &foo() = 'foo rules!' at inline.sl:16
+Trace: &bar() = 'foo rules!' at inline.sl:70
+Trace: &not(15) = -16 at inline.sl:71
+Trace: &debug() = 15 at inline.sl:71
+33
+   inline.sl:88 <inline> &except()
+   inline.sl:79 <origin of exception>
+bleh 0
+blah 1
+Result: pHEAR
+blah 3
+bleh 2
+Result: 

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/output/trace.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at b301f2 println: 'this is a test'] at trace.sl:6
+Trace: [java.io.PrintStream at a83a13 println: 'this is a test'] at trace.sl:6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at trace.sl:7
 81.0
-Trace: [java.io.PrintStream at b301f2 println: 81.0] at trace.sl:7
+Trace: [java.io.PrintStream at a83a13 println: 81.0] at trace.sl:7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at trace.sl:8
 243.0
 Trace: &println(243.0) at trace.sl:8
 testing again...
-Trace: [java.io.PrintStream at b301f2 println: 'testing again...'] at trace.sl:10
+Trace: [java.io.PrintStream at a83a13 println: 'testing again...'] at trace.sl:10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at trace.sl:12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at trace.sl:12
 Warning: variable '$list' not declared at trace.sl:12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/tests/output/wrong.sl	2007-10-14 00:15:34 UTC (rev 301)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at wrong.sl:6
 81.0
-Trace: [java.io.PrintStream at 855562 println: 81.0] at wrong.sl:6
+Trace: [java.io.PrintStream at 7eb6e2 println: 81.0] at wrong.sl:6
 Trace: &casti(1, 'z') = true at wrong.sl:9
 true
-Trace: [java.io.PrintStream at 855562 println: true] at wrong.sl:9
+Trace: [java.io.PrintStream at 7eb6e2 println: true] at wrong.sl:9
 Trace: &casti(0, 'z') = false at wrong.sl:10
 false
-Trace: [java.io.PrintStream at 855562 println: false] at wrong.sl:10
+Trace: [java.io.PrintStream at 7eb6e2 println: false] at wrong.sl:10
 Trace: &casti(1, 'd') = 1.0 at wrong.sl:13
 1.0
-Trace: [java.io.PrintStream at 855562 println: 1.0] at wrong.sl:13
+Trace: [java.io.PrintStream at 7eb6e2 println: 1.0] at wrong.sl:13
 Trace: &casti(1, 'b') = 1 at wrong.sl:16
 1
-Trace: [java.io.PrintStream at 855562 println: 1] at wrong.sl:16
+Trace: [java.io.PrintStream at 7eb6e2 println: 1] at wrong.sl:16
 Trace: &casti(100, 'f') = 100.0 at wrong.sl:19
 100.0
-Trace: [java.io.PrintStream at 855562 println: 100.0] at wrong.sl:19
+Trace: [java.io.PrintStream at 7eb6e2 println: 100.0] at wrong.sl:19
 Trace: &casti('b', 'c') = b at wrong.sl:22
 b
-Trace: [java.io.PrintStream at 855562 println: b] at wrong.sl:22
+Trace: [java.io.PrintStream at 7eb6e2 println: b] at wrong.sl:22
 Trace: &casti(63, 'i') = 63 at wrong.sl:25
 63
-Trace: [java.io.PrintStream at 855562 println: 63] at wrong.sl:25
+Trace: [java.io.PrintStream at 7eb6e2 println: 63] at wrong.sl:25
 this is a string y0
-Trace: [java.io.PrintStream at 855562 println: 'this is a string y0'] at wrong.sl:28
+Trace: [java.io.PrintStream at 7eb6e2 println: 'this is a string y0'] at wrong.sl:28
 Trace: [new java.lang.StringBuilder: 'test'] = test at wrong.sl:31
 test
-Trace: [java.io.PrintStream at 855562 println: test] at wrong.sl:31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 3caa4b at wrong.sl:34
+Trace: [java.io.PrintStream at 7eb6e2 println: test] at wrong.sl:31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at bf053f at wrong.sl:34
 abcd
-Trace: [java.io.PrintStream at 855562 println: [C at 3caa4b] at wrong.sl:34
+Trace: [java.io.PrintStream at 7eb6e2 println: [C at bf053f] at wrong.sl:34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-11 02:13:33 UTC (rev 300)
+++ sleep/whatsnew.txt	2007-10-14 00:15:34 UTC (rev 301)
@@ -28,8 +28,16 @@
    port is intialized.  the extra params will have no effect on 
    subsequent calls to listen.  to fix this call closef(port) to
    unbind the specified port.
+- added inline functions.  these are more like poor macros than anything
+  else.  an inline function is executed inline with the current function,
+  it shares all scope information and any attempt to return/yield values
+  will affect the parent directly. 
 
+  inline return12 { return 12; }
 
+- refactored Sleep's logic flow for managing function calls, debug 
+  options, etc.. to one file.  
+
 2.1-beta 18  (5 Jul 07)
 ===========
 - added scalar references: \$x is equivalent to $x => $x.  this sugar



From rsmudge at mail.berlios.de  Mon Oct 15 04:02:54 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 15 Oct 2007 04:02:54 +0200
Subject: [Sleep-svn] r302 - in sleep: . src/sleep/engine
	src/sleep/engine/atoms tests/output
Message-ID: <200710150202.l9F22seM030019@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-15 04:02:53 +0200 (Mon, 15 Oct 2007)
New Revision: 302

Modified:
   sleep/src/sleep/engine/CallRequest.java
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/tests/output/cast.sl
   sleep/tests/output/convertds3.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
refactored HOES calls into the new CallRequest methodology... ah code cleanup.



Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/src/sleep/engine/CallRequest.java	2007-10-15 02:02:53 UTC (rev 302)
@@ -51,7 +51,7 @@
    /** actually execute the function call */
    public void CallFunction()
    {
-      Scalar temp;
+      Scalar temp = null;
       ScriptEnvironment e = getScriptEnvironment();
       int mark = getScriptEnvironment().markFrame();
 
@@ -90,10 +90,16 @@
              }
              catch (RuntimeException rex)
              {
-                e.cleanFrame(mark);
-                e.KillFrame();
                 e.getScriptInstance().fireWarning(formatCall(args) + " - FAILED!", getLineNumber(), true);
-                throw(rex);
+
+                if (rex.getCause() == null || ! (  (java.lang.reflect.InvocationTargetException.class).isInstance(rex.getCause())  ))
+                {
+                   /* swallow invocation target exceptions please */
+
+                   e.cleanFrame(mark);
+                   e.KillFrame();
+                   throw(rex);
+                }
              }
          }
       }
@@ -105,9 +111,14 @@
          }
          catch (RuntimeException rex)
          {
-             e.cleanFrame(mark);
-             e.KillFrame();
-             throw(rex);
+             if (rex.getCause() == null || ! (  (java.lang.reflect.InvocationTargetException.class).isInstance(rex.getCause())  ))
+             {
+                 /* swallow invocation target exceptions please */
+
+                e.cleanFrame(mark);
+                e.KillFrame();
+                throw(rex);
+             }
          }
       }
 
@@ -116,6 +127,9 @@
          e.getScriptInstance().recordStackFrame(getFrameDescription(), getLineNumber());
       }
 
+      if (temp == null)
+        temp = SleepUtils.getEmptyScalar();
+
       e.cleanFrame(mark);
       e.FrameResult(temp);
    }

Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2007-10-15 02:02:53 UTC (rev 302)
@@ -46,6 +46,83 @@
       return "[Object Access]: "+classRef+"#"+name+"\n";
    }
 
+   private static class MethodCallRequest extends CallRequest
+   {
+      protected Method theMethod;
+      protected Scalar scalar;
+      protected String name;
+      protected Class  theClass;
+
+      public MethodCallRequest(ScriptEnvironment e, int lineNo, Method method, Scalar _scalar, String _name, Class _class)
+      {
+         super(e, lineNo);
+         theMethod = method;
+         scalar    = _scalar;
+         name      = _name;
+         theClass  = _class;
+      }
+
+      public String getFunctionName()
+      {
+         return theMethod.toString();
+      }
+
+      public String getFrameDescription()
+      {
+         return theMethod.toString();   
+      }
+
+      public String formatCall(String args)
+      {
+         StringBuffer trace = new StringBuffer("[");
+
+         if (args != null && args.length() > 0) { args = ": " + args; }
+
+         if (scalar == null)
+         {
+            trace.append(theClass.getName() + " " + name + args + "]");
+         }
+         else if (Proxy.isProxyClass(theClass))
+         {
+            trace.append(theClass.getName() + " " + name + args + "]");
+         }
+         else
+         {
+            trace.append(SleepUtils.describe(scalar) + " " + name + args + "]");
+         }
+
+         return trace.toString();
+      }
+
+      protected Scalar execute()
+      {
+         Object[] parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), getScriptEnvironment().getCurrentFrame(), getScriptEnvironment().getScriptInstance());
+
+         try
+         {
+            return ObjectUtilities.BuildScalar(true, theMethod.invoke(scalar != null ? scalar.objectValue() : null, parameters));
+         }
+         catch (InvocationTargetException ite)
+         {
+            if (ite.getCause() != null)
+               getScriptEnvironment().flagError(ite.getCause());
+
+            throw new RuntimeException(ite);
+         }
+         catch (IllegalArgumentException aex)
+         {
+            aex.printStackTrace();
+            getScriptEnvironment().getScriptInstance().fireWarning(ObjectUtilities.buildArgumentErrorMessage(theClass, name, theMethod.getParameterTypes(), parameters), getLineNumber());
+         }
+         catch (IllegalAccessException iax)
+         {
+            getScriptEnvironment().getScriptInstance().fireWarning("cannot access " + name + " in " + theClass + ": " + iax.getMessage(), getLineNumber());
+         }
+
+         return SleepUtils.getEmptyScalar();
+      }
+   }
+ 
    private static class ClosureCallRequest extends CallRequest
    {
       protected String name;
@@ -171,93 +248,27 @@
       // try to invoke stuff on the object...
       //
 
-      Method theMethod    = null;
-      Object[] parameters = null;
+      Method theMethod = ObjectUtilities.findMethod(theClass, name, e.getCurrentFrame());
 
-      try
-      {
-         theMethod  = ObjectUtilities.findMethod(theClass, name, e.getCurrentFrame());
-
-         if (theMethod != null && (classRef == null || (theMethod.getModifiers() & Modifier.STATIC) == Modifier.STATIC))
-         {  
-            try
-            {
-               theMethod.setAccessible(true);
-            }
-            catch (Exception ex) { }
-
-            if (isTrace)
-            {
-               if (e.getScriptInstance().isProfileOnly())
-               {
-                  long stat = System.currentTimeMillis();
-
-                  parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-                  result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
-
-                  stat = System.currentTimeMillis() - stat;
-                  e.getScriptInstance().collect(theMethod.toString(), getLineNumber(), stat);
-               }
-               else
-               {
-                  String args = SleepUtils.describe(e.getCurrentFrame());
-
-                  if (args.length() > 0) { args = ": " + args; }
-
-                  parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-
-                  /* construct the actual trace message */
-
-                  StringBuffer trace = new StringBuffer("[");
-
-                  if (scalar == null)
-                  {
-                     trace.append(theClass.getName() + " " + name + args + "]");
-                  }
-                  else if (Proxy.isProxyClass(theClass))
-                  {
-                     trace.append(theClass.getName() + " " + name + args + "]");
-                  }
-                  else
-                  {
-                     trace.append(SleepUtils.describe(scalar) + " " + name + args + "]");
-                  }
-
-                  try
-                  {
-                     long stat = System.currentTimeMillis();
-                     result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
-                     stat = System.currentTimeMillis() - stat;
-                     e.getScriptInstance().collect(theMethod.toString(), getLineNumber(), stat);
-
-                     if (!SleepUtils.isEmptyScalar(result))
-                     {
-                        trace.append(" = " + SleepUtils.describe(result));
-                     }
-
-                     e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
-                  }
-                  catch (InvocationTargetException ite)
-                  {
-                     ObjectUtilities.handleExceptionFromJava(ite.getCause(), e, theMethod + "", getLineNumber());
-                     trace.append(" - FAILED!");
-                     e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
-                  }
-                  catch (RuntimeException rex)
-                  {
-                     trace.append(" - FAILED!");
-                     e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
-                     throw(rex);
-                  }
-               }
-            }
-            else
-            {
-               parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-               result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
-            }
+      if (theMethod != null && (classRef == null || (theMethod.getModifiers() & Modifier.STATIC) == Modifier.STATIC))
+      {  
+         try
+         {
+            theMethod.setAccessible(true);
          }
-         else
+         catch (Exception ex) { }
+
+         MethodCallRequest request = new MethodCallRequest(e, getLineNumber(), theMethod, scalar, name, theClass);
+         request.CallFunction();
+         return null;
+      }
+      else if (theMethod == null && !e.getCurrentFrame().isEmpty())
+      {
+         e.getScriptInstance().fireWarning("there is no method that matches " + name + "("+SleepUtils.describe(e.getCurrentFrame()) + ") in " + theClass.getName(), getLineNumber());
+      }
+      else
+      {
+         try
          {
             Field aField = theClass.getField(name);
 
@@ -276,33 +287,15 @@
                result = SleepUtils.getEmptyScalar();
             }
          }
-      }
-      catch (InvocationTargetException ite)
-      {
-         ObjectUtilities.handleExceptionFromJava(ite.getCause(), e, theMethod + "", getLineNumber());
-      }
-      catch (IllegalArgumentException aex)
-      {
-         aex.printStackTrace();
-
-         e.getScriptInstance().fireWarning(ObjectUtilities.buildArgumentErrorMessage(theClass, name, theMethod.getParameterTypes(), 
-                                     parameters), getLineNumber());
-      }
-      catch (NoSuchFieldException fex)
-      {
-         if (!e.getCurrentFrame().isEmpty())
+         catch (NoSuchFieldException fex)
          {
-            e.getScriptInstance().fireWarning("there is no method that matches " + name + "("+SleepUtils.describe(e.getCurrentFrame()) + ") in " + theClass.getName(), getLineNumber());
+            e.getScriptInstance().fireWarning("no field/method named " + name + " in " + theClass, getLineNumber());
          }
-         else
+         catch (IllegalAccessException iax)
          {
-            e.getScriptInstance().fireWarning("no field/method named " + name + " in " + theClass, getLineNumber());
+            e.getScriptInstance().fireWarning("cannot access " + name + " in " + theClass + ": " + iax.getMessage(), getLineNumber());
          }
       }
-      catch (IllegalAccessException iax)
-      {
-         e.getScriptInstance().fireWarning("cannot access " + name + " in " + theClass + ": " + iax.getMessage(), getLineNumber());
-      }
 
       e.cleanFrame(mark);
       e.FrameResult(result);

Modified: sleep/tests/output/cast.sl
===================================================================
--- sleep/tests/output/cast.sl	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/tests/output/cast.sl	2007-10-15 02:02:53 UTC (rev 302)
@@ -1,2 +1,2 @@
-[Ljava.lang.CharSequence;@6b496d class [Ljava.lang.CharSequence;
-[Ljava.util.List;@648016 class [Ljava.util.List;
+[Ljava.lang.CharSequence;@aae86e class [Ljava.lang.CharSequence;
+[Ljava.util.List;@bf053f class [Ljava.util.List;

Modified: sleep/tests/output/convertds3.sl
===================================================================
--- sleep/tests/output/convertds3.sl	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/tests/output/convertds3.sl	2007-10-15 02:02:53 UTC (rev 302)
@@ -32,9 +32,9 @@
 int[] a
 Collection a
 Collection a
-Warning: there is no method that matches mar([Z at 19762f) in sleep.ArrayTest1 at convertds3.sl:36
-Warning: there is no method that matches mar([F at 9e215b) in sleep.ArrayTest1 at convertds3.sl:37
-Warning: there is no method that matches mar([Ljava.lang.Object;@9ff0a8) in sleep.ArrayTest1 at convertds3.sl:38
+Warning: there is no method that matches mar([Z at 502819) in sleep.ArrayTest1 at convertds3.sl:36
+Warning: there is no method that matches mar([F at 78aa80) in sleep.ArrayTest1 at convertds3.sl:37
+Warning: there is no method that matches mar([Ljava.lang.Object;@1d98a) in sleep.ArrayTest1 at convertds3.sl:38
 int[] a
 Collection a
 Collection a

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/tests/output/trace.sl	2007-10-15 02:02:53 UTC (rev 302)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at a83a13 println: 'this is a test'] at trace.sl:6
+Trace: [java.io.PrintStream at aae86e println: 'this is a test'] at trace.sl:6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at trace.sl:7
 81.0
-Trace: [java.io.PrintStream at a83a13 println: 81.0] at trace.sl:7
+Trace: [java.io.PrintStream at aae86e println: 81.0] at trace.sl:7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at trace.sl:8
 243.0
 Trace: &println(243.0) at trace.sl:8
 testing again...
-Trace: [java.io.PrintStream at a83a13 println: 'testing again...'] at trace.sl:10
+Trace: [java.io.PrintStream at aae86e println: 'testing again...'] at trace.sl:10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at trace.sl:12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at trace.sl:12
 Warning: variable '$list' not declared at trace.sl:12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/tests/output/wrong.sl	2007-10-15 02:02:53 UTC (rev 302)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at wrong.sl:6
 81.0
-Trace: [java.io.PrintStream at 7eb6e2 println: 81.0] at wrong.sl:6
+Trace: [java.io.PrintStream at 6ed322 println: 81.0] at wrong.sl:6
 Trace: &casti(1, 'z') = true at wrong.sl:9
 true
-Trace: [java.io.PrintStream at 7eb6e2 println: true] at wrong.sl:9
+Trace: [java.io.PrintStream at 6ed322 println: true] at wrong.sl:9
 Trace: &casti(0, 'z') = false at wrong.sl:10
 false
-Trace: [java.io.PrintStream at 7eb6e2 println: false] at wrong.sl:10
+Trace: [java.io.PrintStream at 6ed322 println: false] at wrong.sl:10
 Trace: &casti(1, 'd') = 1.0 at wrong.sl:13
 1.0
-Trace: [java.io.PrintStream at 7eb6e2 println: 1.0] at wrong.sl:13
+Trace: [java.io.PrintStream at 6ed322 println: 1.0] at wrong.sl:13
 Trace: &casti(1, 'b') = 1 at wrong.sl:16
 1
-Trace: [java.io.PrintStream at 7eb6e2 println: 1] at wrong.sl:16
+Trace: [java.io.PrintStream at 6ed322 println: 1] at wrong.sl:16
 Trace: &casti(100, 'f') = 100.0 at wrong.sl:19
 100.0
-Trace: [java.io.PrintStream at 7eb6e2 println: 100.0] at wrong.sl:19
+Trace: [java.io.PrintStream at 6ed322 println: 100.0] at wrong.sl:19
 Trace: &casti('b', 'c') = b at wrong.sl:22
 b
-Trace: [java.io.PrintStream at 7eb6e2 println: b] at wrong.sl:22
+Trace: [java.io.PrintStream at 6ed322 println: b] at wrong.sl:22
 Trace: &casti(63, 'i') = 63 at wrong.sl:25
 63
-Trace: [java.io.PrintStream at 7eb6e2 println: 63] at wrong.sl:25
+Trace: [java.io.PrintStream at 6ed322 println: 63] at wrong.sl:25
 this is a string y0
-Trace: [java.io.PrintStream at 7eb6e2 println: 'this is a string y0'] at wrong.sl:28
+Trace: [java.io.PrintStream at 6ed322 println: 'this is a string y0'] at wrong.sl:28
 Trace: [new java.lang.StringBuilder: 'test'] = test at wrong.sl:31
 test
-Trace: [java.io.PrintStream at 7eb6e2 println: test] at wrong.sl:31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at bf053f at wrong.sl:34
+Trace: [java.io.PrintStream at 6ed322 println: test] at wrong.sl:31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 884a40 at wrong.sl:34
 abcd
-Trace: [java.io.PrintStream at 7eb6e2 println: [C at bf053f] at wrong.sl:34
+Trace: [java.io.PrintStream at 6ed322 println: [C at 884a40] at wrong.sl:34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-14 00:15:34 UTC (rev 301)
+++ sleep/whatsnew.txt	2007-10-15 02:02:53 UTC (rev 302)
@@ -35,8 +35,8 @@
 
   inline return12 { return 12; }
 
-- refactored Sleep's logic flow for managing function calls, debug 
-  options, etc.. to one file.  
+- major refactor of Sleep's logic flow for managing function calls, debug 
+  options, etc.. to one file.  please report any bugs 
 
 2.1-beta 18  (5 Jul 07)
 ===========



From rsmudge at mail.berlios.de  Thu Oct 18 07:10:01 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 18 Oct 2007 07:10:01 +0200
Subject: [Sleep-svn] r304 - in sleep: . src/sleep/engine/atoms tests/output
Message-ID: <200710180510.l9I5A1wX010876@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-18 07:10:00 +0200 (Thu, 18 Oct 2007)
New Revision: 304

Modified:
   sleep/src/sleep/engine/atoms/ObjectNew.java
   sleep/tests/output/cast.sl
   sleep/tests/output/convertds3.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
refactored ObjectNew to use the CallRequest framework stuphz



Modified: sleep/src/sleep/engine/atoms/ObjectNew.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectNew.java	2007-10-18 04:17:34 UTC (rev 303)
+++ sleep/src/sleep/engine/atoms/ObjectNew.java	2007-10-18 05:10:00 UTC (rev 304)
@@ -43,123 +43,100 @@
       return "[Object New]: "+name+"\n";
    }
 
-   //
-   // Pre Condition:
-   //   arguments are on the current frame
-   //
-   // Post Condition:
-   //   current frame dissolved
-   //   new object is placed on parent frame
-
-   public Scalar evaluate(ScriptEnvironment e)
+   private static class ConstructorCallRequest extends CallRequest
    {
-      boolean isTrace = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+      protected Constructor theConstructor;
+      protected Class  name;
 
-      Scalar result = SleepUtils.getEmptyScalar();
+      public ConstructorCallRequest(ScriptEnvironment e, int lineNo, Constructor cont, Class _name)
+      {
+         super(e, lineNo);
+         theConstructor = cont;
+         name      = _name;
+      }
 
-      Object[]    parameters     = null;
-      Constructor theConstructor = null;
+      public String getFunctionName()
+      {
+         return name.toString();
+      }
 
-      int mark = e.markFrame();
+      public String getFrameDescription()
+      {
+         return name.toString();
+      }
 
-      try
+      public String formatCall(String args)
       {
-         theConstructor  = ObjectUtilities.findConstructor(name, e.getCurrentFrame());
+         if (args != null && args.length() > 0) { args = ": " + args; }
+         StringBuffer trace = new StringBuffer("[new " + name.getName() + args + "]");
 
-         if (theConstructor != null)
-         {  
-            try
-            {
-               theConstructor.setAccessible(true);
-            }
-            catch (Exception ex) { }
+         return trace.toString();
+      }
 
-            if (isTrace)
-            {
-               if (e.getScriptInstance().isProfileOnly())
-               {
-                  long stat = System.currentTimeMillis();
+      protected Scalar execute()
+      {
+         Object[] parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), getScriptEnvironment().getCurrentFrame(), getScriptEnvironment().getScriptInstance());
 
-                  parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-                  result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+         try
+         {
+            return ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+         }
+         catch (InvocationTargetException ite)
+         {
+            if (ite.getCause() != null)
+               getScriptEnvironment().flagError(ite.getCause());
 
-                  stat = System.currentTimeMillis() - stat;
-                  e.getScriptInstance().collect(theConstructor.toString(), getLineNumber(), stat);
-               }
-               else
-               {
-                  String args = SleepUtils.describe(e.getCurrentFrame());
-                  parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
- 
-                  StringBuffer trace = new StringBuffer("[new " + name.getName());
+            throw new RuntimeException(ite);
+         }
+         catch (IllegalArgumentException aex)
+         {
+            aex.printStackTrace();
+            getScriptEnvironment().getScriptInstance().fireWarning(ObjectUtilities.buildArgumentErrorMessage(name, name.getName(), theConstructor.getParameterTypes(), parameters), getLineNumber());
+         }
+         catch (InstantiationException iex)
+         {
+            getScriptEnvironment().getScriptInstance().fireWarning("unable to instantiate abstract class " + name.getName(), getLineNumber());
+         }
+         catch (IllegalAccessException iax)
+         {
+            getScriptEnvironment().getScriptInstance().fireWarning("cannot access constructor in " + name.getName() + ": " + iax.getMessage(), getLineNumber());
+         }
 
-                  if (args.length() > 0)
-                  {
-                     trace.append(": " + args);
-                  }
+         return SleepUtils.getEmptyScalar();
+      }
+   }   
 
-                  trace.append("]");
+   //
+   // Pre Condition:
+   //   arguments are on the current frame
+   //
+   // Post Condition:
+   //   current frame dissolved
+   //   new object is placed on parent frame
 
-                  try
-                  {
-                     long stat = System.currentTimeMillis();
-                     result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+   public Scalar evaluate(ScriptEnvironment e)
+   {
+      Scalar      result;
+      Constructor theConstructor  = ObjectUtilities.findConstructor(name, e.getCurrentFrame());
 
-                     stat = System.currentTimeMillis() - stat;
-                     e.getScriptInstance().collect(theConstructor.toString(), getLineNumber(), stat);
-
-                     if (!SleepUtils.isEmptyScalar(result))
-                     {
-                        trace.append(" = " + SleepUtils.describe(result));
-                     }
-
-                     e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
-                  }
-                  catch (InvocationTargetException ite)
-                  {
-                     ObjectUtilities.handleExceptionFromJava(ite.getCause(), e, theConstructor + "", getLineNumber());
-                     trace.append(" - FAILED!");
-                     e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
-                  }
-                  catch (RuntimeException rex)
-                  {
-                     trace.append(" - FAILED!");
-                     e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
-                     throw(rex);
-                  }
-               }
-            }
-            else
-            { 
-               parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-               result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
-            }
-         }
-         else
+      if (theConstructor != null)
+      {  
+         try
          {
-            e.getScriptInstance().fireWarning("no constructor matching "+name.getName()+"(" + SleepUtils.describe(e.getCurrentFrame()) + ")", getLineNumber());
+            theConstructor.setAccessible(true);
          }
+         catch (Exception ex) { }
+         ConstructorCallRequest request = new ConstructorCallRequest(e, getLineNumber(), theConstructor, name); 
+         request.CallFunction();
+         return null;
       }
-      catch (InvocationTargetException ite)
+      else
       {
-         ObjectUtilities.handleExceptionFromJava(ite.getCause(), e, theConstructor + "", getLineNumber());
+         e.getScriptInstance().fireWarning("no constructor matching " + name.getName() + "("+SleepUtils.describe(e.getCurrentFrame()) + ")", getLineNumber());
+         result = SleepUtils.getEmptyScalar();
+         e.FrameResult(result);
       }
-      catch (IllegalArgumentException aex)
-      {
-         e.getScriptInstance().fireWarning(ObjectUtilities.buildArgumentErrorMessage(name, name.getName(), theConstructor.getParameterTypes(),
-                                     parameters), getLineNumber());
-      }
-      catch (InstantiationException iex)
-      {
-         e.getScriptInstance().fireWarning("unable to instantiate abstract class " + name.getName(), getLineNumber());
-      }
-      catch (Exception iax)
-      {
-         e.getScriptInstance().fireWarning(iax.toString(), getLineNumber());
-      }
 
-      e.cleanFrame(mark);
-      e.FrameResult(result);
       return null;
    }
 }

Modified: sleep/tests/output/cast.sl
===================================================================
--- sleep/tests/output/cast.sl	2007-10-18 04:17:34 UTC (rev 303)
+++ sleep/tests/output/cast.sl	2007-10-18 05:10:00 UTC (rev 304)
@@ -1,2 +1,2 @@
-[Ljava.lang.CharSequence;@aae86e class [Ljava.lang.CharSequence;
-[Ljava.util.List;@bf053f class [Ljava.util.List;
+[Ljava.lang.CharSequence;@1f23e5 class [Ljava.lang.CharSequence;
+[Ljava.util.List;@884a40 class [Ljava.util.List;

Modified: sleep/tests/output/convertds3.sl
===================================================================
--- sleep/tests/output/convertds3.sl	2007-10-18 04:17:34 UTC (rev 303)
+++ sleep/tests/output/convertds3.sl	2007-10-18 05:10:00 UTC (rev 304)
@@ -32,9 +32,9 @@
 int[] a
 Collection a
 Collection a
-Warning: there is no method that matches mar([Z at 502819) in sleep.ArrayTest1 at convertds3.sl:36
-Warning: there is no method that matches mar([F at 78aa80) in sleep.ArrayTest1 at convertds3.sl:37
-Warning: there is no method that matches mar([Ljava.lang.Object;@1d98a) in sleep.ArrayTest1 at convertds3.sl:38
+Warning: there is no method that matches mar([Z at a0864f) in sleep.ArrayTest1 at convertds3.sl:36
+Warning: there is no method that matches mar([F at d1e233) in sleep.ArrayTest1 at convertds3.sl:37
+Warning: there is no method that matches mar([Ljava.lang.Object;@5983b7) in sleep.ArrayTest1 at convertds3.sl:38
 int[] a
 Collection a
 Collection a

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2007-10-18 04:17:34 UTC (rev 303)
+++ sleep/tests/output/trace.sl	2007-10-18 05:10:00 UTC (rev 304)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at aae86e println: 'this is a test'] at trace.sl:6
+Trace: [java.io.PrintStream at 1f23e5 println: 'this is a test'] at trace.sl:6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at trace.sl:7
 81.0
-Trace: [java.io.PrintStream at aae86e println: 81.0] at trace.sl:7
+Trace: [java.io.PrintStream at 1f23e5 println: 81.0] at trace.sl:7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at trace.sl:8
 243.0
 Trace: &println(243.0) at trace.sl:8
 testing again...
-Trace: [java.io.PrintStream at aae86e println: 'testing again...'] at trace.sl:10
+Trace: [java.io.PrintStream at 1f23e5 println: 'testing again...'] at trace.sl:10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at trace.sl:12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at trace.sl:12
 Warning: variable '$list' not declared at trace.sl:12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2007-10-18 04:17:34 UTC (rev 303)
+++ sleep/tests/output/wrong.sl	2007-10-18 05:10:00 UTC (rev 304)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at wrong.sl:6
 81.0
-Trace: [java.io.PrintStream at 6ed322 println: 81.0] at wrong.sl:6
+Trace: [java.io.PrintStream at c391c3 println: 81.0] at wrong.sl:6
 Trace: &casti(1, 'z') = true at wrong.sl:9
 true
-Trace: [java.io.PrintStream at 6ed322 println: true] at wrong.sl:9
+Trace: [java.io.PrintStream at c391c3 println: true] at wrong.sl:9
 Trace: &casti(0, 'z') = false at wrong.sl:10
 false
-Trace: [java.io.PrintStream at 6ed322 println: false] at wrong.sl:10
+Trace: [java.io.PrintStream at c391c3 println: false] at wrong.sl:10
 Trace: &casti(1, 'd') = 1.0 at wrong.sl:13
 1.0
-Trace: [java.io.PrintStream at 6ed322 println: 1.0] at wrong.sl:13
+Trace: [java.io.PrintStream at c391c3 println: 1.0] at wrong.sl:13
 Trace: &casti(1, 'b') = 1 at wrong.sl:16
 1
-Trace: [java.io.PrintStream at 6ed322 println: 1] at wrong.sl:16
+Trace: [java.io.PrintStream at c391c3 println: 1] at wrong.sl:16
 Trace: &casti(100, 'f') = 100.0 at wrong.sl:19
 100.0
-Trace: [java.io.PrintStream at 6ed322 println: 100.0] at wrong.sl:19
+Trace: [java.io.PrintStream at c391c3 println: 100.0] at wrong.sl:19
 Trace: &casti('b', 'c') = b at wrong.sl:22
 b
-Trace: [java.io.PrintStream at 6ed322 println: b] at wrong.sl:22
+Trace: [java.io.PrintStream at c391c3 println: b] at wrong.sl:22
 Trace: &casti(63, 'i') = 63 at wrong.sl:25
 63
-Trace: [java.io.PrintStream at 6ed322 println: 63] at wrong.sl:25
+Trace: [java.io.PrintStream at c391c3 println: 63] at wrong.sl:25
 this is a string y0
-Trace: [java.io.PrintStream at 6ed322 println: 'this is a string y0'] at wrong.sl:28
+Trace: [java.io.PrintStream at c391c3 println: 'this is a string y0'] at wrong.sl:28
 Trace: [new java.lang.StringBuilder: 'test'] = test at wrong.sl:31
 test
-Trace: [java.io.PrintStream at 6ed322 println: test] at wrong.sl:31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 884a40 at wrong.sl:34
+Trace: [java.io.PrintStream at c391c3 println: test] at wrong.sl:31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 9ba640 at wrong.sl:34
 abcd
-Trace: [java.io.PrintStream at 6ed322 println: [C at 884a40] at wrong.sl:34
+Trace: [java.io.PrintStream at c391c3 println: [C at 9ba640] at wrong.sl:34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-18 04:17:34 UTC (rev 303)
+++ sleep/whatsnew.txt	2007-10-18 05:10:00 UTC (rev 304)
@@ -19,15 +19,15 @@
                 a subsequent call of listen(...) to accept a 
                 connection.
 
-   for example, to listen on port 8888 of 192.168.1.1 while allowing
-   only 1 connection:
+    for example, to listen on port 8888 of 192.168.1.1 while allowing
+    only 1 connection:
  
-   $handle = listen(8888, laddr => "192.168.1.1", backlog => 1)
+    $handle = listen(8888, laddr => "192.168.1.1", backlog => 1)
    
-   listen will only honor the extra parameters the first time the 
-   port is intialized.  the extra params will have no effect on 
-   subsequent calls to listen.  to fix this call closef(port) to
-   unbind the specified port.
+    listen will only honor the extra parameters the first time the 
+    port is intialized.  the extra params will have no effect on 
+    subsequent calls to listen.  to fix this call closef(port) to
+    unbind the specified port.
 - added inline functions.  these are more like poor macros than anything
   else.  an inline function is executed inline with the current function,
   it shares all scope information and any attempt to return/yield values
@@ -41,6 +41,7 @@
   with yield) and then it calls the specified function with the packaged
   current function as an argument.  combine this with the new inline 
   functions feature and there is all kinds of fun to be had.
+- HOES now complains if a specified constructor could not be found.
 
 2.1-beta 18  (5 Jul 07)
 ===========



From rsmudge at mail.berlios.de  Sat Oct 20 17:51:22 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 20 Oct 2007 17:51:22 +0200
Subject: [Sleep-svn] r305 - in sleep: . src/sleep/engine/atoms
Message-ID: <200710201551.l9KFpMCG006029@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-20 17:51:21 +0200 (Sat, 20 Oct 2007)
New Revision: 305

Modified:
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/whatsnew.txt
Log:
..


Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2007-10-18 05:10:00 UTC (rev 304)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2007-10-20 15:51:21 UTC (rev 305)
@@ -134,12 +134,8 @@
 
    public Scalar evaluate(ScriptEnvironment e)
    {
-      int mark = e.markFrame();
-      Scalar result = SleepUtils.getEmptyScalar();
-
       Object accessMe = null;
       Class  theClass = null;
-
       Scalar scalar   = null;
 
       if (classRef == null)
@@ -150,9 +146,7 @@
          if (accessMe == null)
          {
             e.getScriptInstance().fireWarning("Attempted to call a non-static method on a null reference", getLineNumber());
-            e.cleanFrame(mark);
             e.KillFrame();
-
             e.getCurrentFrame().push(SleepUtils.getEmptyScalar());
 
             return null;
@@ -183,14 +177,13 @@
       if (name == null)
       {
          e.getScriptInstance().fireWarning("Attempted to query an object with no method/field", getLineNumber());
-         e.cleanFrame(mark);
          e.KillFrame();
-         e.getCurrentFrame().push(result);
+         e.getCurrentFrame().push(SleepUtils.getEmptyScalar());
 
          return null;
       }
 
-      boolean isTrace   = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+      Scalar result = SleepUtils.getEmptyScalar();
 
       //
       // try to invoke stuff on the object...
@@ -245,7 +238,6 @@
          }
       }
 
-      e.cleanFrame(mark);
       e.FrameResult(result);
       return null;
    }

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-18 05:10:00 UTC (rev 304)
+++ sleep/whatsnew.txt	2007-10-20 15:51:21 UTC (rev 305)
@@ -41,7 +41,6 @@
   with yield) and then it calls the specified function with the packaged
   current function as an argument.  combine this with the new inline 
   functions feature and there is all kinds of fun to be had.
-- HOES now complains if a specified constructor could not be found.
 
 2.1-beta 18  (5 Jul 07)
 ===========



From rsmudge at mail.berlios.de  Sat Oct 20 18:53:17 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 20 Oct 2007 18:53:17 +0200
Subject: [Sleep-svn] r306 - in sleep: . tests tests/output
Message-ID: <200710201653.l9KGrH6q017065@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-20 18:53:16 +0200 (Sat, 20 Oct 2007)
New Revision: 306

Added:
   sleep/tests/callccbg.sl
   sleep/tests/output/callccbg.sl
Modified:
   sleep/whatsnew.txt
Log:
test case..


Added: sleep/tests/callccbg.sl
===================================================================
--- sleep/tests/callccbg.sl	2007-10-20 15:51:21 UTC (rev 305)
+++ sleep/tests/callccbg.sl	2007-10-20 16:53:16 UTC (rev 306)
@@ -0,0 +1,26 @@
+#
+# potential callcc bug...
+#
+
+sub bar
+{
+   println("Hello from bar!");
+}
+
+sub foo
+{
+   local('$x');
+   $x = 100;
+   if ($x == 100)
+   {
+      if ($x != 10)
+      {
+         callcc &bar;
+         println("Post cc same block");
+      }
+   }
+
+   println("Ho! post continuation!");
+}
+
+foo();

Added: sleep/tests/output/callccbg.sl
===================================================================
--- sleep/tests/output/callccbg.sl	2007-10-20 15:51:21 UTC (rev 305)
+++ sleep/tests/output/callccbg.sl	2007-10-20 16:53:16 UTC (rev 306)
@@ -0,0 +1 @@
+Hello from bar!

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-20 15:51:21 UTC (rev 305)
+++ sleep/whatsnew.txt	2007-10-20 16:53:16 UTC (rev 306)
@@ -35,6 +35,10 @@
 
   inline return12 { return 12; }
 
+  inline functions themselves always give back $null in an expression. 
+  using an inline function within an expression is not recommended.
+
+  callcc/yield behavior within an expression will break things.
 - major refactor of Sleep's logic flow for managing function calls, debug 
   options, etc.. to one file.  please report any bugs 
 - added callcc to Sleep.  callcc packages up the current function (as 



From rsmudge at mail.berlios.de  Sat Oct 20 19:20:42 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 20 Oct 2007 19:20:42 +0200
Subject: [Sleep-svn] r307 - in sleep: src/sleep/engine tests tests/output
Message-ID: <200710201720.l9KHKg3g027252@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-20 19:20:42 +0200 (Sat, 20 Oct 2007)
New Revision: 307

Added:
   sleep/tests/inlineb.sl
   sleep/tests/output/inlineb.sl
Modified:
   sleep/src/sleep/engine/Block.java
Log:
..


Modified: sleep/src/sleep/engine/Block.java
===================================================================
--- sleep/src/sleep/engine/Block.java	2007-10-20 16:53:16 UTC (rev 306)
+++ sleep/src/sleep/engine/Block.java	2007-10-20 17:20:42 UTC (rev 307)
@@ -248,12 +248,20 @@
               }
               else if (ex instanceof RuntimeException)
               {
-                 environment.getScriptInstance().fireWarning(ex.getMessage(), temp.getLineNumber());
+                 if (ex.getMessage() == null)
+                 {
+                    environment.getScriptInstance().fireWarning("internal error - " + ex.getClass(), temp.getLineNumber());
+//                    ex.printStackTrace(System.err);
+                 }
+                 else
+                 {
+                    environment.getScriptInstance().fireWarning(ex.getMessage(), temp.getLineNumber());
+                 }
               }
               else
               {
                  environment.getScriptInstance().fireWarning(ex.toString(), temp.getLineNumber());
-                 ex.printStackTrace(System.out);
+//                 ex.printStackTrace(System.err);
               }
 
               cleanupEnvironment(environment);

Added: sleep/tests/inlineb.sl
===================================================================
--- sleep/tests/inlineb.sl	2007-10-20 16:53:16 UTC (rev 306)
+++ sleep/tests/inlineb.sl	2007-10-20 17:20:42 UTC (rev 307)
@@ -0,0 +1,21 @@
+#
+# test a broken inline call.
+#
+
+inline foo
+{
+   $x += 3;
+   yield $x;
+}
+
+sub bar
+{
+   local('$x');
+   $x = 2;
+   $z = 10 * foo();
+   println($z);
+   return 10;
+}
+
+println(bar());
+println(bar());

Added: sleep/tests/output/inlineb.sl
===================================================================
--- sleep/tests/output/inlineb.sl	2007-10-20 16:53:16 UTC (rev 306)
+++ sleep/tests/output/inlineb.sl	2007-10-20 17:20:42 UTC (rev 307)
@@ -0,0 +1,3 @@
+5
+Warning: internal error - class java.util.EmptyStackException at inlineb.sl:15
+



From rsmudge at mail.berlios.de  Sun Oct 21 07:11:32 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sun, 21 Oct 2007 07:11:32 +0200
Subject: [Sleep-svn] r308 - in sleep: . docs
Message-ID: <200710210511.l9L5BWup005322@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-21 07:11:31 +0200 (Sun, 21 Oct 2007)
New Revision: 308

Modified:
   sleep/docs/sleeplang.html
   sleep/readme.txt
   sleep/whatsnew.txt
Log:
..


Modified: sleep/docs/sleeplang.html
===================================================================
--- sleep/docs/sleeplang.html	2007-10-20 17:20:42 UTC (rev 307)
+++ sleep/docs/sleeplang.html	2007-10-21 05:11:31 UTC (rev 308)
@@ -785,6 +785,33 @@
    return $1 * fact($1 - 1)
 }</pre>
 
+<h3>Inline Subroutines</h3>
+
+<p>An inline subroutine is Sleep's solution to the macro.  An inline subroutine executes within the current function context as if it manually
+existed there.  Local and closure variable scopes are shared with the current function.  Any attempt to yield, return, or callcc a value from an 
+inline function will directly affect the parent.</p>
+
+<p>Parameters passed to inline subroutines are numbered from <var>$1</var> ... <var>$n</var>.  <var>$this</var> and friends refer to the current
+function and not the inline function.</p>
+
+<p>Inline functions have utility for abstracting complex callcc, yield, or return behavior.  They are declared with the inline keyword.</p>
+
+<pre>inline printx
+{
+   println("\$x is $x");
+}
+
+sub foo
+{
+   local('$x');
+   $x = 0x31337;
+   printx();
+}</pre>
+
+<p>Inline subroutines do not return values themselves.  Any attempt to use an inline function call in
+an expression will result in <var>$null</var>.  Any attempt to use an inline function call that saves function state (yield, callcc) will result
+in an unusable continuation.</p>
+
 <h3>Nesting Subroutines</h3>
 
 <p>Everything in sleep is evaluated in a (semi) straight forward manner.  When sleep executes a statement that consists of the 
@@ -1968,6 +1995,34 @@
 evaluate an expression each iteration of a loop where as foreach is iterating over a closure reference.  The difference is
 pretty much in the implementation, the end result is the same.</p>
 
+<h4>The Callcc Command</h4>
+
+<p>Similar to coroutines are continuations.  A paused function object can be thought of as the future stuff to execute (or the
+continuation) of the function.  The callcc command syntactically resembles yield and return except a function parameter is required.</p>
+
+<p>callcc will save the current function state into a object.  The specified function will the be called with the current function continuation
+as a parameter.  Control flow will be moved to the specified function.  callcc can be thought of as a functional-level goto.</p>
+
+<pre>$buffer  = $null;
+
+sub produce {
+   for ($x = 0; $x < 3; $x++) {
+      println("Produce: $x * 3");
+      $buffer = $x * 3;
+      callcc &consume;
+   }
+}
+
+sub consume {
+   println("Consume: $buffer");
+   callcc &produce;
+}
+
+produce();</pre>
+
+<p>Callcc and yield use the same internal mechanisms.  The practical difference between callcc and yield is that callcc expects a function parameter and this
+function parameter is immediately invoked with the saved state of the calling function.</p>
+
 <h2><a name="11">Function Library</a></h2>
 
 <p>This appendix is a list of the application neutral built-in functions for sleep.  I expect this list to grow as time goes on.  
@@ -2328,6 +2383,11 @@
  </tr>
  <tr>
   <td>%</td>
+  <td>ohash(blah => "value", ...)</td>
+  <td>instantiates an ordered hash with the specified values.  ordered hashes mantain key insertion order.  keys can be updated without changing order.</td>
+ </tr>
+ <tr>
+  <td>%</td>
   <td>putAll(%hash, @|&amp;, [@|&amp;])</td>
   <td>populates the hash with the specified iterators.  If only one iterator is specified then the second argument
   is assumed to be the same as the first.  The first iterator is iterated over to obtain the keys for the hash
@@ -2404,9 +2464,11 @@
  </tr>
  <tr>
   <td>$</td>
-  <td>connect("host", port, [timeout], [&amp;closure])</td>
+  <td>connect("host", port, [timeout], [&amp;closure], ...)</td>
   <td>connects to the specified host:port and returns a $handle.  Check for issues connecting to a host with checkError().  If 
-     &amp;closure is specified, this call will not block.  &amp;closure will be called when a connection is established.</td>
+     &amp;closure is specified, this call will not block.  &amp;closure will be called when a connection is established.  multiple key value pairs
+can be specified to set parameters of the connection: linger => (the value of SO_LINGER (how long (ms) the socket waits for a TCP reset before
+actually closing.); lport => (the local port number to bind to); laddr => (the local address to bind to)</td>
  </tr>
  <tr>
   <td>$</td>
@@ -2439,10 +2501,13 @@
  </tr>
  <tr>
   <td>$</td>
-  <td>listen(port, [timeout], [$host], [&amp;closure])</td>
+  <td>listen(port, [timeout], [$host], [&amp;closure], ...)</td>
   <td>listens for a connection on the specified port.  Check for listening issues with the checkError() function.  If 
       &amp;closure is specified, this call will not block.  &amp;closure will be called when a connection is established.  
-      The specified scalar $host will be set to the name of the host that connects (if successful).</td>
+      The specified scalar $host will be set to the name of the host that connects (if successful).  multiple key value pairs can be specified to
+set parameters of the connection: linger => (the value of SO_LINGER (how long (ms) the socket waits for a TCP reset before actually closing.);
+lport => (the local port number to bind to); laddr => (the local address to bind to); and backlog => (the number of connections to queue while
+waiting for a subsequent call of listen(...) to accept a connection.)</td>
  </tr>
  <tr>
   <td></td>

Modified: sleep/readme.txt
===================================================================
--- sleep/readme.txt	2007-10-20 17:20:42 UTC (rev 307)
+++ sleep/readme.txt	2007-10-21 05:11:31 UTC (rev 308)
@@ -1,5 +1,5 @@
  ------- -------------------- ---------   ---------------  ------- ---------
-Sleep - 2.1 beta 18 - README   
+Sleep - 2.1 beta 19 - README   
 -  ------------- -------- -   ---------------- --       -    -     -     - - -
 
 "You got the language, all you need now is the O'Reilly book".  That is
@@ -21,6 +21,7 @@
 and stabilized.  
 
 Sleep Project Homepage: http://sleep.hick.org/
+              (Mirror): http://sleep.berlios.de/
 
  ------- -------------------- ---------   ---------------  ------- ---------
 Documentation
@@ -156,9 +157,9 @@
 Legal Garbage
 -  ------------- -------- -   ---------------- --       -    -     -     - - -
 
-Sleep is (c) 2002, 2003, 2004, 2005, 2006 Raphael Mudge (raffi at hick.org).  All 
-of the source and somehow the documentation are released under the GNU Lesser
-Public License.  
+Sleep is (c) 2002, 2003, 2004, 2005, 2006, 2007 Raphael Mudge (raffi at hick.org).  
+All of the source and somehow the documentation are released under the GNU 
+Lesser Public License.  
 
 The scripts and library files supplied as input to or produced as output 
 from the Sleep library do not automatically fall under the copyright of the

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-20 17:20:42 UTC (rev 307)
+++ sleep/whatsnew.txt	2007-10-21 05:11:31 UTC (rev 308)
@@ -1,4 +1,4 @@
-2.1-beta 19 
+2.1-beta 19  (23 Oct 07)
 ===========
 - sleep interpreter now performs better stack hygeine to prevent 
   exceptions and errors from corrupting the stack inadvertently.
@@ -28,10 +28,10 @@
     port is intialized.  the extra params will have no effect on 
     subsequent calls to listen.  to fix this call closef(port) to
     unbind the specified port.
-- added inline functions.  these are more like poor macros than anything
-  else.  an inline function is executed inline with the current function,
-  it shares all scope information and any attempt to return/yield values
-  will affect the parent directly. 
+- added inline functions.  these are more like poor mans macros than 
+  anything else.  an inline function is executed inline with the 
+  current function, it shares all scope information and any attempt 
+  to return/yield/callcc values will affect the parent directly. 
 
   inline return12 { return 12; }
 



From rsmudge at mail.berlios.de  Thu Oct 25 02:25:35 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 25 Oct 2007 02:25:35 +0200
Subject: [Sleep-svn] r309 - in sleep: . docs src/sleep/bridges
	src/sleep/runtime tests/output
Message-ID: <200710250025.l9P0PZMx021458@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-25 02:25:33 +0200 (Thu, 25 Oct 2007)
New Revision: 309

Modified:
   sleep/build.xml
   sleep/docs/sleeplang.html
   sleep/src/sleep/bridges/BridgeUtilities.java
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/tests/output/inline.sl
Log:
..


Modified: sleep/build.xml
===================================================================
--- sleep/build.xml	2007-10-21 05:11:31 UTC (rev 308)
+++ sleep/build.xml	2007-10-25 00:25:33 UTC (rev 309)
@@ -16,7 +16,7 @@
            destdir="${project.build}"
            nowarn="yes"
            depend="yes"
-           debug="true"
+           debug="false"
            source="1.4"
            target="1.4"
            optimize="yes"

Modified: sleep/docs/sleeplang.html
===================================================================
--- sleep/docs/sleeplang.html	2007-10-21 05:11:31 UTC (rev 308)
+++ sleep/docs/sleeplang.html	2007-10-25 00:25:33 UTC (rev 309)
@@ -2003,6 +2003,15 @@
 <p>callcc will save the current function state into a object.  The specified function will the be called with the current function continuation
 as a parameter.  Control flow will be moved to the specified function.  callcc can be thought of as a functional-level goto.</p>
 
+<p>The syntax for callcc is:</p>
+
+<p><code>callcc <b>closure</b></code>;</p>
+
+<p>The return value of the specified closure will be the return value of the current function.  The specified closure receives the continuation of 
+the current function as the <var>$1</var> parameter.</p>
+
+<p>The following is a simple example of callcc demonstrating the producer/consumer problem:</p>
+
 <pre>$buffer  = $null;
 
 sub produce {
@@ -2015,7 +2024,7 @@
 
 sub consume {
    println("Consume: $buffer");
-   callcc &produce;
+   callcc $1; # resume the calling function
 }
 
 produce();</pre>

Modified: sleep/src/sleep/bridges/BridgeUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BridgeUtilities.java	2007-10-21 05:11:31 UTC (rev 308)
+++ sleep/src/sleep/bridges/BridgeUtilities.java	2007-10-25 00:25:33 UTC (rev 309)
@@ -313,7 +313,7 @@
    }
 
    /** initializes local scope based on argument stack */
-   public static int initLocalScope(ScriptVariables vars, Variable localLevel, Stack locals)
+   public static void initLocalScope(ScriptVariables vars, Variable localLevel, Stack locals)
    {
       int name = 1;
 
@@ -341,7 +341,7 @@
          }
       }
 
-      return name;
+      vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(name, localLevel)), localLevel);
    }
 
    /** normalizes the index value based on the specified length */

Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2007-10-21 05:11:31 UTC (rev 308)
+++ sleep/src/sleep/bridges/SleepClosure.java	2007-10-25 00:25:33 UTC (rev 309)
@@ -211,8 +211,7 @@
           // initialize local variables...
           //
           vars.setScalarLevel("$0", SleepUtils.getScalar(message), localLevel);
-          int name = BridgeUtilities.initLocalScope(vars, localLevel, locals);
-          vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(name, localLevel)), localLevel);
+          BridgeUtilities.initLocalScope(vars, localLevel, locals);
 
           //
           // call the function, save the scalar that was returned. 

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2007-10-21 05:11:31 UTC (rev 308)
+++ sleep/src/sleep/runtime/SleepUtils.java	2007-10-25 00:25:33 UTC (rev 309)
@@ -26,7 +26,7 @@
 public class SleepUtils
 {
    /** A date stamp of this Sleep release in YYYYMMDD format */
-   public static final int    SLEEP_RELEASE = 20070705;
+   public static final int    SLEEP_RELEASE = 20071024;
 
    /** A string description of this Sleep release */
    public static final String SLEEP_VERSION = "Sleep 2.1";

Modified: sleep/tests/output/inline.sl
===================================================================
--- sleep/tests/output/inline.sl	2007-10-21 05:11:31 UTC (rev 308)
+++ sleep/tests/output/inline.sl	2007-10-25 00:25:33 UTC (rev 309)
@@ -6,7 +6,7 @@
 Returned pHEAR
 blah 3
 bleh 2
- at _ = @()
+ at _ = @('aa', 'bbb', 'cccc')
 Arg: aa
 $foo: uNF
 $this: &closure[inline.sl:57-60]#3



From rsmudge at mail.berlios.de  Thu Oct 25 02:26:04 2007
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 25 Oct 2007 02:26:04 +0200
Subject: [Sleep-svn] r310 - sleep
Message-ID: <200710250026.l9P0Q4q2021551@sheep.berlios.de>

Author: rsmudge
Date: 2007-10-25 02:26:03 +0200 (Thu, 25 Oct 2007)
New Revision: 310

Modified:
   sleep/whatsnew.txt
Log:
..


Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2007-10-25 00:25:33 UTC (rev 309)
+++ sleep/whatsnew.txt	2007-10-25 00:26:03 UTC (rev 310)
@@ -1,4 +1,4 @@
-2.1-beta 19  (23 Oct 07)
+2.1-beta 19  (24 Oct 07)
 ===========
 - sleep interpreter now performs better stack hygeine to prevent 
   exceptions and errors from corrupting the stack inadvertently.



