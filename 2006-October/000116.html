<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Sleep-svn] r134 - sleep/docs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/sleep-svn/2006-October/index.html" >
   <LINK REL="made" HREF="mailto:sleep-svn%40lists.berlios.de?Subject=Re%3A%20%5BSleep-svn%5D%20r134%20-%20sleep/docs&In-Reply-To=%3C200610091113.k99BDfwo022919%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000115.html">
   <LINK REL="Next"  HREF="000117.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Sleep-svn] r134 - sleep/docs</H1>
    <B>crazycoder at BerliOS</B> 
    <A HREF="mailto:sleep-svn%40lists.berlios.de?Subject=Re%3A%20%5BSleep-svn%5D%20r134%20-%20sleep/docs&In-Reply-To=%3C200610091113.k99BDfwo022919%40sheep.berlios.de%3E"
       TITLE="[Sleep-svn] r134 - sleep/docs">crazycoder at mail.berlios.de
       </A><BR>
    <I>Mon Oct  9 13:13:41 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000115.html">[Sleep-svn] r133 - sleep/docs
</A></li>
        <LI>Next message: <A HREF="000117.html">[Sleep-svn] r135 - in sleep: . src/sleep/engine/atoms
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#116">[ date ]</a>
              <a href="thread.html#116">[ thread ]</a>
              <a href="subject.html#116">[ subject ]</a>
              <a href="author.html#116">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: crazycoder
Date: 2006-10-09 13:13:41 +0200 (Mon, 09 Oct 2006)
New Revision: 134

Modified:
   sleep/docs/sleeplang.html
Log:
You owe me beer for fixing your HTML errors =)

Modified: sleep/docs/sleeplang.html
===================================================================
--- sleep/docs/sleeplang.html	2006-10-02 02:13:03 UTC (rev 133)
+++ sleep/docs/sleeplang.html	2006-10-09 11:13:41 UTC (rev 134)
@@ -39,7 +39,7 @@
 &lt;li&gt;&lt;a href=&quot;#17&quot;&gt;F - Transliteration Syntax&lt;/a&gt;&lt;/li&gt;
 &lt;/ol&gt;
 
-&lt;a name=&quot;1&quot;&gt;&lt;h2&gt;Scalar Variables&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;1&quot;&gt;Scalar Variables&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Variables in sleep are temporary locations in memory to store a value.  Variables in sleep are called scalars.  Scalars can be 
 strings, numbers, or even a reference to an object.&lt;/p&gt;
@@ -83,7 +83,7 @@
 
 &lt;p&gt;Sleep also includes a set of logical operators.  These include &lt;var&gt;&lt;&lt;&lt;/var&gt;, &lt;var&gt;&gt;&gt;&lt;/var&gt;, &lt;var&gt;^&lt;/var&gt;, 
 &lt;var&gt;|&lt;/var&gt;, &lt;var&gt;&amp;&lt;/var&gt;, and a 
-function &lt;var&gt;&amp;not()&lt;/var&gt;.  
+function &lt;var&gt;&amp;not()&lt;/var&gt;.&lt;/p&gt;
 
 &lt;h3&gt;Expressions&lt;/h3&gt;
 
@@ -226,12 +226,12 @@
 &lt;var&gt;$decision&lt;/var&gt; was then assigned the value &quot;not guilty&quot;.  When the subroutine verdict finished executing the local variable
 &lt;var&gt;$decision&lt;/var&gt; went away.  The global variable &lt;var&gt;$decision&lt;/var&gt; was not touched.&lt;/p&gt;
 
-&lt;a name=&quot;2&quot;&gt;&lt;h2&gt;If-Else Statements&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;2&quot;&gt;If-Else Statements&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;If-Else statements let you compare different values and execute a certain part of the script based on the result of the 
 comparison.&lt;/p&gt;
 
-&lt;p&gt;The basic format of an if-else statement is:
+&lt;p&gt;The basic format of an if-else statement is:&lt;/p&gt;
 
 &lt;pre&gt;if (&lt;b&gt;v1 operator v2&lt;/b&gt;) { &lt;b&gt;commands&lt;/b&gt; }
 else if (&lt;b&gt;v3 operator v4&lt;/b&gt;) { &lt;b&gt;commands&lt;/b&gt; }
@@ -240,7 +240,7 @@
 &lt;p&gt;The ( ) parentheses enclose the comparisons while the { } brackets enclose the commands to execute.  If the comparison within 
 the ( ) parentheses is true then the following commands are executed.  If the initial comparison is false then the else statement 
 is executed.  Else statements can be followed by either a block of statements enclosed in { } brackets or by another if 
-statement.&lt;/P&gt;
+statement.&lt;/p&gt;
 
 &lt;h3&gt;The Operators&lt;/h3&gt;
 
@@ -432,7 +432,7 @@
 &lt;var&gt;$value&lt;/var&gt; would be &quot;Calculation took 1 second&quot;.  The iff example above checks if &lt;var&gt;$x&lt;/var&gt; is greater than 1.  If it 
 is then &quot;s&quot; is returned.  Otherwise &quot;&quot; is returned.&lt;/p&gt;
 
-&lt;a name=&quot;3&quot;&gt;&lt;h2&gt;Loops&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;3&quot;&gt;Loops&lt;/a&gt;&lt;/h2&gt;
 
 &lt;h3&gt;While Loops&lt;/h3&gt;
 
@@ -520,7 +520,7 @@
 just jumps to the beginning of the loop again ignoring the current item.  Within a for loop the incremeter ($x++
 in this example) is always executed even if continue is used.&lt;/p&gt;
 
-&lt;a name=&quot;4&quot;&gt;&lt;h2&gt;Number Crunching&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;4&quot;&gt;Number Crunching&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;The Scalars -&gt; Expressions section introduced sleep's family of numerical scalars.&lt;/p&gt;
 
@@ -568,7 +568,7 @@
    
 &lt;p&gt;&lt;code&gt;$x--&lt;/code&gt; is equivalent to &lt;code&gt;$x = $x - 1&lt;/code&gt;;&lt;/p&gt;
 
-&lt;a name=&quot;5&quot;&gt;&lt;h2&gt;Subroutines&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;5&quot;&gt;Subroutines&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Subroutines in sleep are basically mini programs.  You can pass arguments to them and they can return values.&lt;/p&gt;
 
@@ -665,7 +665,7 @@
 returns &quot;my favorite color is red&quot;.   Otherwise the subroutine favoriteColor will be declared as a subroutine that returns &quot;I 
 don't know what my favorite color is&quot;.&lt;/p&gt;
 
-&lt;a name=&quot;6&quot;&gt;&lt;h2&gt;Arrays&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;6&quot;&gt;Arrays&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;An array is a variable that holds a bunch of variables.  Arrays reference variables in numerical order.  So each variable in 
 the array has an index (or position).  Arrays in sleep always begin with the @ at symbol.   This goes for referencing array 
@@ -848,7 +848,7 @@
 
 &lt;p&gt;There is no limit to how many levels deep your arrays/data structures can go.  Levels do not need to be the same size.&lt;/p&gt;
 
-&lt;a name=&quot;7&quot;&gt;&lt;h2&gt;Hashes&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;7&quot;&gt;Hashes&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Hashes are a special scalar type that can hold a bunch of variables as well.  Unlike arrays hashes reference variables with a 
 key.   Each variable in the hash has a unique key associated with it.  Hashes in sleep always begin with the % at symbol.   This 
@@ -920,7 +920,7 @@
 
 &lt;pre&gt;$temp = split(' ', &quot;A B C&quot;)[1]; # $temp is now &quot;B&quot;&lt;/pre&gt;
 
-&lt;a name=&quot;8&quot;&gt;&lt;h2&gt;String manipulation&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;8&quot;&gt;String manipulation&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Sleep strings come in two varieties.  Literals and parsed literals.  A literal string is a string where what you type is 
 exactly what you get.&lt;/p&gt;
@@ -1052,7 +1052,7 @@
 
 &lt;pre&gt;$value = join(&quot;replacement value&quot;, split(&lt;b&gt;'pattern'&lt;/b&gt;, &quot;the entire string&quot;));&lt;/pre&gt;
 
-&lt;a name=&quot;9&quot;&gt;&lt;h2&gt;Input/Output Capabilities&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;9&quot;&gt;Input/Output Capabilities&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;The sleep IO capabilities allow you to read and write data from/to files, tcp sockets, and other processes.&lt;/p&gt;
 
@@ -1191,7 +1191,7 @@
 &lt;p&gt;When the above script executes the subroutines &lt;code&gt;&amp;my_taskA&lt;/code&gt; and &lt;code&gt;&amp;my_taskB&lt;/code&gt; will both execute 
 at the same time.  The output will be a seemingly random mix of Task A counting to 100 and Task B counting to 100.  This is 
 because Java lets &lt;code&gt;&amp;my_taskA&lt;/code&gt; run for a little while and then it lets &lt;code&gt;&amp;my_taskB&lt;/code&gt; run for a 
-little while.&lt;p&gt;
+little while.&lt;/p&gt;
 
 &lt;p&gt;When a Sleep script forks, a completely new script environment is created.  This new script environment is mostly isolated
 (see &lt;i&gt;*&lt;/i&gt;) from its parent script environment.  No variables that were visible or available in the parent environment are
@@ -1278,7 +1278,7 @@
 message is cleared.   A scalar passed to checkError() as  an argument will have the value of the 'current' error message placed 
 into it.  In the above example checkError sets the value of $error to be a message stating why the file could not be opened.&lt;/P&gt;
 
-&lt;a name=&quot;10&quot;&gt;&lt;h2&gt;Working with Objects&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;10&quot;&gt;Working with Objects&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;A new feature in Sleep is the haphazard object extensions for Sleep (HOES).  HOES adds some new syntax for creating, 
 accessing, and working with Java objects.  This interface is brand new and is geared towards experienced programmers.  If you 
@@ -1324,7 +1324,7 @@
 
 &lt;p&gt;You can not use a period '.' to access a message/field in an object i.e.:&lt;/p&gt;
 
-&lt;pre&gt;&lt;s&gt;&lt;font color=&quot;red&quot;&gt;[System.out println: &quot;test&quot; ];&lt;/s&gt; # wrong!&lt;/font&gt;&lt;/pre&gt;
+&lt;pre&gt;&lt;font color=&quot;red&quot;&gt;&lt;s&gt;[System.out println: &quot;test&quot; ];&lt;/s&gt; # wrong!&lt;/font&gt;&lt;/pre&gt;
 
 &lt;p&gt;To correctly access a message/field that is multiple levels deep:&lt;/p&gt;
 
@@ -1457,7 +1457,7 @@
 
 &lt;p&gt;Often times Java API's acessed via HOES can throw an &quot;exception&quot;.  Exceptions are a mechanism used to notify programs that some type of error has occured.  You can check for an exception using the &lt;code&gt;checkError($scalar)&lt;/code&gt; function.&lt;/p&gt;
 
-&lt;a name=&quot;10a&quot;&gt;&lt;h2&gt;Sleep Closures&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;10a&quot;&gt;Sleep Closures&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Closely coupled with HOES is the concept of Sleep closures.  A closure in sleep is a block of code that contains its own 
 lexical scope.  i.e. there are variables specific to each closure instance.&lt;/P&gt;
@@ -1501,7 +1501,7 @@
 
 &lt;p&gt;The above creates a new closure assigned to $myfunc.  The initial value of $name inside of the closure scope is &quot;Raffi&quot;.&lt;/p&gt;
 
-&lt;p&gt;To explicitly declare a value or set of values to be within a closure scope use the function &lt;code&gt;this()&lt;/code&gt;&gt;. i.e.&lt;/P.
+&lt;p&gt;To explicitly declare a value or set of values to be within a closure scope use the function &lt;code&gt;this()&lt;/code&gt;&gt;. i.e.&lt;/p&gt;
 
 &lt;pre&gt;$myfunc = {
    this('$a $b $c @array %hash');
@@ -1628,7 +1628,7 @@
 evaluate an expression each iteration of a loop where as foreach is iterating over a closure reference.  The difference is
 pretty much in the implementation, the end result is the same.&lt;/p&gt;
 
-&lt;a name=&quot;11&quot;&gt;&lt;h2&gt;Function Library&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;11&quot;&gt;Function Library&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;This appendix is a list of the application neutral built-in functions for sleep.  I expect this list to grow as time goes on.  
 Much of the functionality for sleep should in theory come from the bridges provided by the application author.&lt;/p&gt;
@@ -2104,7 +2104,7 @@
   &lt;td&gt;read([$handle], &amp;closure, [n])&lt;/td&gt;
   &lt;td&gt;each time text is read from $handle, &amp;closure will be called with the $1 = to the handle and $2 = to the text.  
 specifying a n value will cause $2 to be a string of n bytes.  if n is specified sleep will try to read n bytes before 
-calling the closure.  the closure will be called for the last read even if &lt; n bytes are in the buffer.&lt;/td&gt;
+calling the closure.  the closure will be called for the last read even if &lt; n bytes are in the buffer.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;@&lt;/td&gt;
@@ -2547,8 +2547,7 @@
  &lt;/tr&gt;
 &lt;/table&gt;
 
-&lt;a name=&quot;AppendixA&quot;&gt;&lt;/a&gt;
-&lt;a name=&quot;12&quot;&gt;&lt;h2&gt;Appendix A - System Properties&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;12&quot;&gt;Appendix A - System Properties&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;This appendix contains a list of system properties available in the hash returned by the systemProperties() function.  This 
 list is not comprehensive:&lt;/p&gt;
@@ -2604,8 +2603,7 @@
  &lt;/tr&gt;
 &lt;/table&gt;
 
-&lt;a name=&quot;AppendixB&quot;&gt;&lt;/a&gt;
-&lt;a name=&quot;13&quot;&gt;&lt;h2&gt;Appendix B - Wildcard Strings&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;13&quot;&gt;Appendix B - Wildcard Strings&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Sleep has the ability to determine if a string matches a specified wildcard string.  This appendix is just a quick 
 refresher.&lt;/p&gt;
@@ -2658,8 +2656,7 @@
 &lt;p&gt;In the greedy example the matcher will find &quot;this&quot; and it will then use * for as much stuff as possible.  Taking it all the 
 way to the end of the string where &quot;test&quot; is.&lt;/p&gt;
 
-&lt;a name=&quot;AppendixC&quot;&gt;&lt;/a&gt;
-&lt;a name=&quot;14&quot;&gt;&lt;h2&gt;Appendix C - Regular Expression Pattern Syntax&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;14&quot;&gt;Appendix C - Regular Expression Pattern Syntax&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Think of a pattern as a description of a string.  A pattern describes what an &quot;acceptable&quot; string looks like.   When a string 
 is applied to a pattern, the regex engine goes through the string character by character advancing it through the pattern.  If 
@@ -2899,7 +2896,7 @@
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Blank}&lt;/tt&gt;&lt;/td&gt;
      &lt;td headers=&quot;matches&quot;&gt;A space or a tab: &lt;tt&gt;[ \t]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Cntrl}&lt;/tt&gt;&lt;/td&gt;
-     &lt;td headers=&quot;matches&quot;&gt;A control character: &lt;tt&gt;[\x00-\x1F\x7F]&lt;/td&gt;&lt;/tr&gt;
+     &lt;td headers=&quot;matches&quot;&gt;A control character: &lt;tt&gt;[\x00-\x1F\x7F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{XDigit}&lt;/tt&gt;&lt;/td&gt;
      &lt;td headers=&quot;matches&quot;&gt;A hexadecimal digit: &lt;tt&gt;[0-9a-fA-F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Space}&lt;/tt&gt;&lt;/td&gt;
@@ -3008,7 +3005,7 @@
  &lt;tr align=&quot;left&quot;&gt;&lt;td colspan=&quot;2&quot; id=&quot;quot&quot;&gt;&lt;b&gt;Quotation&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
 
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;/td&gt;
-     &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes the following character&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
+     &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\Q&lt;/tt&gt;&lt;/td&gt;
      &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes all characters until &lt;tt&gt;\E&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\E&lt;/tt&gt;&lt;/td&gt;
@@ -3049,7 +3046,7 @@
 would have to create a string &lt;tt&gt;'\\\\'&lt;/tt&gt; which is resolved into &lt;tt&gt;\\&lt;/tt&gt; which is used by the regex engine to match a 
 single &lt;tt&gt;\&lt;/tt&gt;.  At least with single quoted strings one has to only worry about &lt;tt&gt;\\&lt;/tt&gt; and &lt;tt&gt;\'&lt;/tt&gt;.&lt;/p&gt;
 
-&lt;a name=&quot;15&quot;&gt;&lt;h2&gt;Appendix D - Date/Time Formats&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;15&quot;&gt;Appendix D - Date/Time Formats&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Note: The following is modified from the documentation provided by Sun for the Java java.util.SimpleDateFormat class.  FYI for 
 Sun, nice job on this API - I like it.&lt;/p&gt;
@@ -3217,7 +3214,7 @@
  &lt;/tr&gt;
 &lt;/table&gt;
 
-&lt;a name=&quot;16&quot;&gt;&lt;h2&gt;Appendix E - Binary Data Format Strings&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;16&quot;&gt;Appendix E - Binary Data Format Strings&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Binary data format strings are used in the &amp;bread, &amp;bwrite, &amp;pack, and &amp;unpack functions.  An array of byte 
 data is stored as a sleep string scalar.  Specifying a data format string with one of the above functions allows you to 
@@ -3300,7 +3297,8 @@
   &lt;td&gt;s&lt;/td&gt;
   &lt;td&gt;2&lt;/td&gt;
   &lt;td&gt;short (converted to/from a sleep int)&lt;/td&gt;
- &lt;tr&gt;
+ &lt;/tr&gt;
+  &lt;tr&gt;
   &lt;td&gt;S&lt;/td&gt;
   &lt;td&gt;2&lt;/td&gt;
   &lt;td&gt;unsigned short (converted to/from a sleep int)&lt;/td&gt;
@@ -3345,13 +3343,13 @@
 
 &lt;pre&gt;$endianess = iff(unpack('i!', pack('i+', 1))[0] == 1, &quot;big endian&quot;, &quot;little endian&quot;);&lt;/pre&gt;
 
-&lt;a name=&quot;snote&quot;&gt;&lt;/a&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;u/U/z/Z Note:&lt;/font&gt; Writes using Z/U will pad until the specified count is reached.  
+&lt;a name=&quot;snote&quot;&gt;&lt;/a&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;u/U/z/Z Note:&lt;/font&gt; Writes using Z/U will pad until the specified count is reached.
 If no count is specified a \0 is guaranteed to be written.  If the string length is the same as the specified count no \0 will 
 be written.  The values z/u will write the entire string with a guaranteed \0 always (two \0's for UTF-16).  The count value 
 has no effect on z/u.  Consequently for reads, Z/U will always consume the number of characters specified in the count.  For 
 reads z/u will keep reading until a \0 is found.  U/u strings always read/write 2-byte characters.&lt;/p&gt;
 
-&lt;a name=&quot;17&quot;&gt;&lt;h2&gt;Appendix F - Transliteration&lt;/h2&gt;&lt;/a&gt;
+&lt;h2&gt;&lt;a name=&quot;17&quot;&gt;Appendix F - Transliteration&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;Sleep provides a character translation utility similar to the UNIX tr command with the &lt;code&gt;&amp;tr&lt;/code&gt; function..
 A transliteration consists of a pattern of characters to match and a pattern, typically of equal length, of characters to 
@@ -3370,7 +3368,7 @@
 println(&quot;Cipher: $cipher   Plain: $plain&quot;);&lt;/pre&gt;
 
 &lt;p&gt;Replacement patterns and Matcher patterns may both contain ranges.  Any range specified in either of these places will be
-expanded to all of the characters.  A range is specified as &lt;code&gt;&lt;i&gt;n&lt;/i&gt;-&lt;/i&gt;m&lt;/i&gt;&lt;/code&gt; where &lt;i&gt;n&lt;/i&gt; is the
+expanded to all of the characters.  A range is specified as &lt;code&gt;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;m&lt;/i&gt;&lt;/code&gt; where &lt;i&gt;n&lt;/i&gt; is the
 starting character (A-Z, a-z, 0-9) and &lt;i&gt;m&lt;/i&gt; is the ending character.  Backwards ranges are allowed as well.&lt;/p&gt;
 
 &lt;p&gt;If an expanded replacement pattern is shorter than the matcher pattern, the last character of the replacement pattern


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000115.html">[Sleep-svn] r133 - sleep/docs
</A></li>
	<LI>Next message: <A HREF="000117.html">[Sleep-svn] r135 - in sleep: . src/sleep/engine/atoms
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#116">[ date ]</a>
              <a href="thread.html#116">[ thread ]</a>
              <a href="subject.html#116">[ subject ]</a>
              <a href="author.html#116">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/sleep-svn">More information about the Sleep-svn
mailing list</a><br>
</body></html>
