From rsmudge at mail.berlios.de  Fri Sep  8 04:05:33 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 8 Sep 2006 04:05:33 +0200
Subject: [Sleep-svn] r107 - in sleep: . src/sleep/bridges src/sleep/console
	src/sleep/engine/atoms src/sleep/error src/sleep/parser
	src/sleep/runtime tests tests/output
Message-ID: <200609080205.k8825XLF011935@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-08 04:05:32 +0200 (Fri, 08 Sep 2006)
New Revision: 107

Added:
   sleep/tests/output/trace.sl
   sleep/tests/trace.sl
Modified:
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/console/ConsoleImplementation.java
   sleep/src/sleep/engine/atoms/Call.java
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/src/sleep/engine/atoms/ObjectNew.java
   sleep/src/sleep/error/ScriptWarning.java
   sleep/src/sleep/parser/CodeGenerator.java
   sleep/src/sleep/runtime/Scalar.java
   sleep/src/sleep/runtime/ScriptInstance.java
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/tests/output/args.sl
   sleep/tests/output/foreach.sl
   sleep/tests/output/native_arrays.sl
   sleep/tests/output/passarrays.sl
   sleep/whatsnew.txt
Log:
lots of useful changes.
- new debug level
- int/long literals generate an object scalar
- scalar/hash string conversion now matches sleep literal form



Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/bridges/SleepClosure.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -80,6 +80,11 @@
     /** the meta data for this closure context */
     HashMap          metadata; 
 
+    public String toString()
+    {
+       return "&closure" + hashCode();
+    }
+
     /** Creates a new Sleep Closure, with a brand new set of internal variables.  Don't be afraid, you can call this constructor from your code. */
     public SleepClosure(ScriptInstance si, Block _code)
     {

Modified: sleep/src/sleep/console/ConsoleImplementation.java
===================================================================
--- sleep/src/sleep/console/ConsoleImplementation.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/console/ConsoleImplementation.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -414,7 +414,14 @@
 
    public void processScriptWarning(ScriptWarning warning)
    {
-      getProxy().consolePrintln("Warning: " + warning.getMessage() + " at line " + warning.getLineNumber());
+      if (warning.isDebugTrace())
+      {
+         getProxy().consolePrintln("Trace: " + warning.getMessage() + " at line " + warning.getLineNumber());
+      }
+      else
+      {
+         getProxy().consolePrintln("Warning: " + warning.getMessage() + " at line " + warning.getLineNumber());
+      }
    }     
 
    public boolean scriptLoaded(ScriptInstance script)

Modified: sleep/src/sleep/engine/atoms/Call.java
===================================================================
--- sleep/src/sleep/engine/atoms/Call.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/engine/atoms/Call.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -25,6 +25,7 @@
 import java.util.*;
 import sleep.interfaces.*;
 import sleep.engine.*;
+import sleep.engine.types.*;
 import sleep.runtime.*;
 
 public class Call extends Step
@@ -55,13 +56,32 @@
 
       if (callme != null)
       {
-          temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
-          e.clearReturn();
+         if ((e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS && !function.equals("&@") && !function.equals("&%"))
+         {
+             String args = SleepUtils.describe(e.getCurrentFrame());
+
+             temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
+             e.clearReturn();
+             
+             if (SleepUtils.isEmptyScalar(temp))
+             {
+                e.getScriptInstance().fireWarning(function + "(" + args + ")", getLineNumber(), true);
+             }
+             else
+             {
+                e.getScriptInstance().fireWarning(function + "(" + args + ") = " + SleepUtils.describe(temp), getLineNumber(), true);
+             }
+         }
+         else
+         {
+             temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
+             e.clearReturn();
+         }
       }
       else
       {
-          e.getScriptInstance().fireWarning("Attempted to call non-existent function " + function, getLineNumber());
-          temp = SleepUtils.getEmptyScalar();
+         e.getScriptInstance().fireWarning("Attempted to call non-existent function " + function, getLineNumber());
+         temp = SleepUtils.getEmptyScalar();
       }
 
       e.FrameResult(temp);

Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -57,6 +57,8 @@
 
    public Scalar evaluate(ScriptEnvironment e)
    {
+      boolean isTrace = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+
       Scalar result = SleepUtils.getEmptyScalar();
 
       Object accessMe = null;
@@ -93,8 +95,42 @@
       {
          Function func = SleepUtils.getFunctionFromScalar(scalar, e.getScriptInstance());
 
-         result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
+         if (isTrace)
+         {
+            String args = SleepUtils.describe(e.getCurrentFrame());
 
+            result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
+
+            /* construct the actual trace message */
+
+            StringBuffer trace = new StringBuffer("[&closure");
+           
+            if (name != null && name.length() > 0)
+            {
+               trace.append(" " + name);
+            }
+
+            if (args.length() > 0)
+            {
+               trace.append(": " + args + "]");
+            }
+            else
+            {
+               trace.append("]");
+            }
+
+            if (!SleepUtils.isEmptyScalar(result))
+            {
+               trace.append(" = " + SleepUtils.describe(result));
+            }
+
+            e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
+         }
+         else
+         {
+            result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
+         }         
+
          e.clearReturn(); // this has to be done or else bad things will happen when the closure returns stuff
          // ^-- evaluate, is this really necessary or are closures smart enough to clear the return themselves? // RSM
 
@@ -129,8 +165,40 @@
             }
             catch (Exception ex) { }
 
-            parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-            result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
+            if (isTrace)
+            {
+               String args = SleepUtils.describe(e.getCurrentFrame());
+
+               if (args.length() > 0) { args = ": " + args; }
+
+               parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
+               result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
+
+               /* construct the actual trace message */
+
+               StringBuffer trace = new StringBuffer("[");
+
+               if (scalar == null)
+               {
+                  trace.append(theClass.getName() + " " + name + args + "]");
+               }
+               else
+               {
+                  trace.append(SleepUtils.describe(scalar) + " " + name + args + "]");
+               }
+
+               if (!SleepUtils.isEmptyScalar(result))
+               {
+                  trace.append(" = " + SleepUtils.describe(result));
+               }
+
+               e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
+            }
+            else
+            {
+               parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
+               result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
+            }
          }
          else
          {

Modified: sleep/src/sleep/engine/atoms/ObjectNew.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectNew.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/engine/atoms/ObjectNew.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -53,6 +53,8 @@
 
    public Scalar evaluate(ScriptEnvironment e)
    {
+      boolean isTrace = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+
       Scalar result = SleepUtils.getEmptyScalar();
 
       Object[]    parameters     = null;
@@ -70,8 +72,34 @@
             }
             catch (Exception ex) { }
 
-            parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-            result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+            if (isTrace)
+            {
+               String args = SleepUtils.describe(e.getCurrentFrame());
+
+               parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
+               result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+
+               StringBuffer trace = new StringBuffer("[new " + name.getName());
+
+               if (args.length() > 0)
+               {
+                  trace.append(": " + args);
+               }
+
+               trace.append("]");
+
+               if (!SleepUtils.isEmptyScalar(result))
+               {
+                  trace.append(" = " + SleepUtils.describe(result));
+               }
+
+               e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
+            }
+            else
+            {
+               parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
+               result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+            }
          }
          else
          {

Modified: sleep/src/sleep/error/ScriptWarning.java
===================================================================
--- sleep/src/sleep/error/ScriptWarning.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/error/ScriptWarning.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -14,14 +14,27 @@
    protected ScriptInstance script;
    protected String         message; 
    protected int            line;
+   protected boolean        trace;
 
    public ScriptWarning(ScriptInstance _script, String _message, int _line)
    {
+      this(_script, _message, _line, false);
+   }
+
+   public ScriptWarning(ScriptInstance _script, String _message, int _line, boolean _trace)
+   {
       script  = _script;
       message = _message;
       line    = _line;
+      trace   = _trace;
    }
 
+   /** is this a trace message for one of the trace debug options */
+   public boolean isDebugTrace()
+   {
+      return trace;
+   }
+
    /** returns the ScriptInstance object that was the source of this runtime error */
    public ScriptInstance getSource()
    {

Modified: sleep/src/sleep/parser/CodeGenerator.java
===================================================================
--- sleep/src/sleep/parser/CodeGenerator.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/parser/CodeGenerator.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -426,11 +426,11 @@
          case IDEA_NUMBER:                         // implemented
            if (strings[0].endsWith("L"))
            {
-              ascalar = SleepUtils.getScalar(Long.decode(strings[0].substring(0, strings[0].length() - 1)));
+              ascalar = SleepUtils.getScalar(Long.decode(strings[0].substring(0, strings[0].length() - 1)).longValue());
            }
            else
            {
-              ascalar = SleepUtils.getScalar(Integer.decode(strings[0]));
+              ascalar = SleepUtils.getScalar(Integer.decode(strings[0]).intValue());
            }
 
            atom    = GeneratedSteps.SValue(ascalar);

Modified: sleep/src/sleep/runtime/Scalar.java
===================================================================
--- sleep/src/sleep/runtime/Scalar.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/runtime/Scalar.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -89,10 +89,10 @@
       /* these are in case the scalar is being misused */
 
       if (array != null)
-         return SleepUtils.getScalar(array.toString()).getValue();
+         return SleepUtils.getScalar(SleepUtils.describe(this)).getValue();
 
       if (hash != null)
-         return SleepUtils.getScalar(hash.toString()).getValue();
+         return SleepUtils.getScalar(SleepUtils.describe(this)).getValue();
 
       return null;
    }

Modified: sleep/src/sleep/runtime/ScriptInstance.java
===================================================================
--- sleep/src/sleep/runtime/ScriptInstance.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/runtime/ScriptInstance.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -83,6 +83,9 @@
     /** fire runtime warning whenever an undeclared variable is fired */
     public static final int DEBUG_REQUIRE_STRICT = 4;
 
+    /** fire a runtime warning describing each function call */
+    public static final int DEBUG_TRACE_CALLS    = 8;
+
     /** track all of the flagged debug options for this script (set to DEBUG_SHOW_ERRORS by default) */
     protected int debug = DEBUG_SHOW_ERRORS;
 
@@ -259,10 +262,16 @@
     /** Fire a runtime script warning */
     public void fireWarning(String message, int line)
     {
+       fireWarning(message, line, false);
+    }
+
+    /** Fire a runtime script warning */
+    public void fireWarning(String message, int line, boolean isTrace)
+    {
        if (debug != DEBUG_NONE)
        {
-          ScriptWarning temp = new ScriptWarning(this, message, line);
- 
+          ScriptWarning temp = new ScriptWarning(this, message, line, isTrace);
+
           Iterator i = watchers.iterator();
           while (i.hasNext())
           {

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/src/sleep/runtime/SleepUtils.java	2006-09-08 02:05:32 UTC (rev 107)
@@ -334,6 +334,102 @@
       return SleepUtils.getScalar(handle);
    }
 
+   /** returns a comma separated list of descriptions of the scalars in the specified argument
+       stack.  This is used by the debugging mechanism to format arguments to strings based on
+       their scalar type. */
+   public static String describe(Stack arguments)
+   {
+      StringBuffer values = new StringBuffer();
+
+      Iterator i = arguments.iterator();
+      while (i.hasNext())
+      {
+         Scalar tempz = (Scalar)i.next();
+
+         values.insert(0, SleepUtils.describe(tempz));
+
+         if (i.hasNext()) { values.insert(0, ", "); }
+      }
+
+      return values.toString();
+   }
+
+   /** returns a string description of the specified scalar. Used by debugging mechanism to
+       format scalars based on their value type, i.e. strings are enclosed in single quotes,
+       objects in brackets, $null is displayed as $null, etc. */
+   public static String describe(Scalar scalar)
+   {
+      if (scalar.getArray() != null)
+      {
+         StringBuffer buffer = new StringBuffer("@(");
+         Iterator i = scalar.getArray().scalarIterator();
+         while (i.hasNext())
+         {
+            Scalar next = (Scalar)i.next();
+            buffer.append(describe(next));
+
+            if (i.hasNext())
+            {
+               buffer.append(", ");
+            }
+         }
+        
+         buffer.append(")");
+         return buffer.toString();
+      }
+      if (scalar.getHash() != null)
+      {
+         StringBuffer buffer = new StringBuffer("%(");
+         Iterator i = scalar.getHash().keys().scalarIterator();
+         while (i.hasNext())
+         {
+            Scalar next = (Scalar)i.next();
+            buffer.append(next.toString());
+
+            buffer.append(" => ");
+
+            Scalar nval = scalar.getHash().getAt(next);
+
+            buffer.append(describe(nval));
+
+            if (i.hasNext())
+            {
+               buffer.append(", ");
+            }
+         }
+        
+         buffer.append(")");
+         return buffer.toString();
+      }
+      else
+      {
+         if (scalar.getValue() instanceof NullValue)
+         {
+            return "$null";
+         }
+         else if (scalar.getValue() instanceof StringValue)
+         {
+            return "'" + scalar.toString() + "'";
+         }
+         else if (isFunctionScalar(scalar))
+         {
+            return scalar.toString();
+         }
+         else if (scalar.getValue() instanceof ObjectValue)
+         {
+            return "[" + scalar.toString() + "]";
+         }
+         else if (scalar.getValue() instanceof LongValue)
+         {
+            return scalar.toString() + "L";
+         }
+         else
+         {
+            return scalar.toString();
+         }
+      }
+   }
+
    /** returns an empty hashmap scalar */
    public static Scalar getHashScalar()
    {

Modified: sleep/tests/output/args.sl
===================================================================
--- sleep/tests/output/args.sl	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/tests/output/args.sl	2006-09-08 02:05:32 UTC (rev 107)
@@ -2,7 +2,7 @@
 Arg2: b 
 Arg3: c
 Total Args: 10 and now...
-Test: [a, b, c, d, e, f, g, h, i, j]
+Test: @('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j')
 Argument: a
 Argument: b
 Argument: c
@@ -17,7 +17,7 @@
 Arg2: 2 
 Arg3: 3
 Total Args: 5 and now...
-Test: [1, 2, 3, 4, 5]
+Test: @(1, 2, 3, 4, 5)
 Argument: 1
 Argument: 2
 Argument: 3
@@ -27,7 +27,7 @@
 Arg2:  
 Arg3: 
 Total Args: 0 and now...
-Test: []
+Test: @()
 Arg1: 1 
 Arg2: 2 
 Arg3: 3

Modified: sleep/tests/output/foreach.sl
===================================================================
--- sleep/tests/output/foreach.sl	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/tests/output/foreach.sl	2006-09-08 02:05:32 UTC (rev 107)
@@ -8,8 +8,8 @@
 This is a test of 10
 This is a test of blah
 Aftermath: blah
-Pre print: [blah, bleh, sluts]
-Array [blarg, bleh, sluts] and blarg
-Array [blarg, blarg, sluts] and blarg
-Array [blarg, blarg, blarg] and blarg
-Test: [blarg, blarg, blarg]
+Pre print: @('blah', 'bleh', 'sluts')
+Array @('blarg', 'bleh', 'sluts') and blarg
+Array @('blarg', 'blarg', 'sluts') and blarg
+Array @('blarg', 'blarg', 'blarg') and blarg
+Test: @('blarg', 'blarg', 'blarg')

Modified: sleep/tests/output/native_arrays.sl
===================================================================
--- sleep/tests/output/native_arrays.sl	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/tests/output/native_arrays.sl	2006-09-08 02:05:32 UTC (rev 107)
@@ -18,14 +18,14 @@
 $temp[1][1][1] = 11
 $temp[1][1][2] = 12
 <--------------------------------------------------->
-We have [1, 2, 3, 4, 5, 6] and class sleep.engine.types.ArrayContainer
+We have @(1, 2, 3, 4, 5, 6) and class sleep.engine.types.ArrayContainer
 $temp[0][0] = 1
 $temp[0][1] = 2
 $temp[0][2] = 3
 $temp[0][3] = 4
 $temp[0][4] = 5
 $temp[0][5] = 6
-We have [7, 8, 9, 10, 11, 12] and class sleep.engine.types.ArrayContainer
+We have @(7, 8, 9, 10, 11, 12) and class sleep.engine.types.ArrayContainer
 $temp[1][0] = 7
 $temp[1][1] = 8
 $temp[1][2] = 9

Modified: sleep/tests/output/passarrays.sl
===================================================================
--- sleep/tests/output/passarrays.sl	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/tests/output/passarrays.sl	2006-09-08 02:05:32 UTC (rev 107)
@@ -5,4 +5,4 @@
 Hrm.. value is : with
 Hrm.. value is : 7
 Hrm.. value is : words
-This should be empty: []
+This should be empty: @()

Added: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/tests/output/trace.sl	2006-09-08 02:05:32 UTC (rev 107)
@@ -0,0 +1,15 @@
+this is a test
+Trace: [[java.io.PrintStream at 884a40] println: 'this is a test'] at line 6
+Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 7
+81.0
+Trace: [[java.io.PrintStream at 884a40] println: 81.0] at line 7
+Trace: [java.lang.Math pow: 3, 5] = 243.0 at line 8
+243.0
+Trace: &println(243.0) at line 8
+testing again...
+Trace: [[java.io.PrintStream at 884a40] println: 'testing again...'] at line 9
+Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [[a, b, c]] at line 11
+Trace: [new java.util.LinkedList: [[a, b, c]]] = [[a, b, c]] at line 11
+Warning: variable '$list' not declared at line 11
+[a, b, c]
+Trace: &println([[a, b, c]]) at line 13

Added: sleep/tests/trace.sl
===================================================================
--- sleep/tests/trace.sl	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/tests/trace.sl	2006-09-08 02:05:32 UTC (rev 107)
@@ -0,0 +1,13 @@
+#
+# test out the function call traceing stuff...
+#
+debug(15);
+
+[[System out] println: "this is a test" ];
+[[System out] println: [Math pow:3, 4]];
+println([Math pow: 3, 5]);
+[[java.lang.System out] println: "testing again..."];
+
+$list = [new LinkedList: [sleep.runtime.SleepUtils getListFromArray: @("a", "b", "c")]];
+
+println($list);

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-08-19 17:45:38 UTC (rev 106)
+++ sleep/whatsnew.txt	2006-09-08 02:05:32 UTC (rev 107)
@@ -3,6 +3,13 @@
 - added a literal form for arrays and hashes:
   @("a", "b", "c", "d", "e", @("f", "g", "h", "i"), "j", "k")
   %(a => "apple", b => "batman", c => "cow")
+- fixed a bug in the Sleep parser transforming long/int literals
+  into ObjectValues rather than LongValue/IntValue.
+- string form of arrays and hashes (when converted to a string) is now 
+  consistent with the sleep literal form
+- added another debug level (8) for function call tracing.  while this
+  flag is set all function calls with their arguments and return value
+  will be displayed to the user as a runtime warning.  
 
 2.1-beta 3
 ===========



From rsmudge at mail.berlios.de  Sun Sep 10 20:32:34 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sun, 10 Sep 2006 20:32:34 +0200
Subject: [Sleep-svn] r108 - in sleep: . src/sleep/engine tests tests/output
Message-ID: <200609101832.k8AIWYKq024508@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-10 20:32:33 +0200 (Sun, 10 Sep 2006)
New Revision: 108

Added:
   sleep/tests/convertds.sl
   sleep/tests/output/convertds.sl
Modified:
   sleep/build.xml
   sleep/src/sleep/engine/ObjectUtilities.java
   sleep/tests/output/trace.sl
   sleep/whatsnew.txt
Log:
HOES now allows Sleep data structures to be passed as Java List or Map data.



Modified: sleep/build.xml
===================================================================
--- sleep/build.xml	2006-09-08 02:05:32 UTC (rev 107)
+++ sleep/build.xml	2006-09-10 18:32:33 UTC (rev 108)
@@ -18,6 +18,7 @@
            depend="yes"
            debug="false"
            source="1.4"
+           target="1.4"
            optimize="yes"
     >
     </javac>

Modified: sleep/src/sleep/engine/ObjectUtilities.java
===================================================================
--- sleep/src/sleep/engine/ObjectUtilities.java	2006-09-08 02:05:32 UTC (rev 107)
+++ sleep/src/sleep/engine/ObjectUtilities.java	2006-09-10 18:32:33 UTC (rev 108)
@@ -81,42 +81,68 @@
          {
              // do nothing, this argument is a give me
          }
-         else if (check[z].isArray() && scalar.getArray() != null)
+         else if (scalar.getArray() != null)
          {
-             if (check[z].getComponentType() == OBJECT_TYPE)
-             {
-                value = ARG_MATCH_MAYBE;
-             }
-             else
-             {
-                Class mytype = getArrayType(scalar, null);
+            if (check[z].isArray())
+            {
+               if (check[z].getComponentType() == OBJECT_TYPE)
+               {
+                  value = ARG_MATCH_MAYBE;
+               }
+               else
+               {
+                  Class mytype = getArrayType(scalar, null);
  
-                if (mytype == check[z].getComponentType())
-                {
-                   value = ARG_MATCH_YES;
-                }
-                else
-                {
-                   value = ARG_MATCH_NO;
-                }
-             }
+                  if (mytype == check[z].getComponentType())
+                  {
+                     value = ARG_MATCH_YES;
+                  }
+                  else
+                  {
+                     // why are we not returning this?!? a test case should be devised to test the
+                     // implications...
+                     value = ARG_MATCH_NO;
+                  }
+               }
+            }
+            else if (check[z].isAssignableFrom(java.util.List.class))
+            {
+               // would a java.util.List or java.util.Collection satisfy the argument?
+               value = ARG_MATCH_YES;
+            }
+            else if (!check[z].isInstance(scalar.objectValue()))
+            {
+               return ARG_MATCH_NO;
+            }
          }
+         else if (scalar.getHash() != null)
+         {
+            if (check[z].isAssignableFrom(java.util.Map.class))
+            {
+               // would a java.util.Map or java.util.Collection satisfy the argument?
+               value = ARG_MATCH_YES;
+            }
+            else if (!check[z].isInstance(scalar.objectValue()))
+            {
+               return ARG_MATCH_NO;
+            }
+         }
          else if (check[z].isPrimitive() && !(stemp == INT_SCALAR || stemp == DOUBLE_SCALAR || stemp == LONG_SCALAR))
          {
-             value = ARG_MATCH_MAYBE;
+            value = ARG_MATCH_MAYBE;
          }
          else if (check[z].isInterface())
          {
-             if (!SleepUtils.isFunctionScalar(scalar) && !check[z].isInstance(scalar.objectValue()))
-                  return ARG_MATCH_NO;
+            if (!SleepUtils.isFunctionScalar(scalar) && !check[z].isInstance(scalar.objectValue()))
+               return ARG_MATCH_NO;
          }
          else if (check[z] == STRING_TYPE && stemp != STRING_SCALAR)
          {
-             value = ARG_MATCH_MAYBE;
+            value = ARG_MATCH_MAYBE;
          }
          else if (!check[z].isInstance(scalar.objectValue()))
          {
-             return ARG_MATCH_NO;
+            return ARG_MATCH_NO;
          }
       }
  
@@ -177,22 +203,48 @@
 
    public static Object buildArgument(Class type, Scalar value, ScriptInstance script)
    {
-      if (type.isArray() && value.getArray() != null)
+      if (type == STRING_TYPE)
       {
-         Class atype = getArrayType(value, type.getComponentType());
+         return value.toString();
+      }
+      else if (value.getArray() != null)
+      {
+         if (type.isArray())
+         {
+            Class atype = getArrayType(value, type.getComponentType());
 
-         Object arrayV = Array.newInstance(atype, value.getArray().size());
-         Iterator i = value.getArray().scalarIterator();
-         int x = 0;
-         while (i.hasNext())
+            Object arrayV = Array.newInstance(atype, value.getArray().size());
+            Iterator i = value.getArray().scalarIterator();
+            int x = 0;
+            while (i.hasNext())
+            {
+               Scalar temp = (Scalar)i.next();
+               Array.set(arrayV, x, buildArgument(atype, temp, script));
+               x++;
+            }
+
+            return arrayV;
+         }
+         else if (type.isAssignableFrom(java.util.List.class))
          {
-            Scalar temp = (Scalar)i.next();
-            Array.set(arrayV, x, buildArgument(atype, temp, script));
-            x++;
+            return SleepUtils.getListFromArray(value);
          }
-
-         return arrayV;
+         else
+         {
+            return value.objectValue();
+         }
       }
+      else if (value.getHash() != null)
+      {
+         if (type.isAssignableFrom(java.util.Map.class))
+         {
+            return SleepUtils.getMapFromHash(value);
+         }
+         else
+         {
+            return value.objectValue();
+         }
+      }
       else if (type.isPrimitive())
       {
          if (type == Boolean.TYPE)
@@ -236,10 +288,6 @@
       {
          return BuildInterface(type, SleepUtils.getFunctionFromScalar(value, script), script);
       }
-      else if (type == STRING_TYPE)
-      {
-         return value.toString();
-      }
 
       return value.objectValue();
    }

Added: sleep/tests/convertds.sl
===================================================================
--- sleep/tests/convertds.sl	2006-09-08 02:05:32 UTC (rev 107)
+++ sleep/tests/convertds.sl	2006-09-10 18:32:33 UTC (rev 108)
@@ -0,0 +1,32 @@
+#
+# a test of converting sleep data structures to java data structures
+# (no vice versa)
+#
+
+#
+# Scalar Arrays
+#
+
+# convert to a java.util.List
+ at test = @("a", "b", "c", "d");
+
+println("b4 - @test is: " . @test);
+
+$x = [Collections binarySearch: @test, "c"];
+
+println("Found element 'c' at $x");
+
+# convert to a java.util.Collection
+
+$set = [new TreeSet: @("a", "b", "c", "d", "e", "f", "b1", "c1", "a1")];
+println("A treeset: $set");
+
+#
+# Scalar Hashes (eeh :))
+# 
+
+# convert to a java.util.Map
+
+$sortedmap = [new TreeMap: %(z => "zebra", a => "apple", b => "bannana", c => "cod")];
+println("A sortedmap: $sortedmap");
+

Added: sleep/tests/output/convertds.sl
===================================================================
--- sleep/tests/output/convertds.sl	2006-09-08 02:05:32 UTC (rev 107)
+++ sleep/tests/output/convertds.sl	2006-09-10 18:32:33 UTC (rev 108)
@@ -0,0 +1,4 @@
+b4 - @test is: @('a', 'b', 'c', 'd')
+Found element 'c' at 2
+A treeset: [a, a1, b, b1, c, c1, d, e, f]
+A sortedmap: {a=apple, b=bannana, c=cod, z=zebra}

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2006-09-08 02:05:32 UTC (rev 107)
+++ sleep/tests/output/trace.sl	2006-09-10 18:32:33 UTC (rev 108)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [[java.io.PrintStream at 884a40] println: 'this is a test'] at line 6
+Trace: [[java.io.PrintStream at d4d66b] println: 'this is a test'] at line 6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 7
 81.0
-Trace: [[java.io.PrintStream at 884a40] println: 81.0] at line 7
+Trace: [[java.io.PrintStream at d4d66b] println: 81.0] at line 7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at line 8
 243.0
 Trace: &println(243.0) at line 8
 testing again...
-Trace: [[java.io.PrintStream at 884a40] println: 'testing again...'] at line 9
+Trace: [[java.io.PrintStream at d4d66b] println: 'testing again...'] at line 9
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [[a, b, c]] at line 11
 Trace: [new java.util.LinkedList: [[a, b, c]]] = [[a, b, c]] at line 11
 Warning: variable '$list' not declared at line 11

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-08 02:05:32 UTC (rev 107)
+++ sleep/whatsnew.txt	2006-09-10 18:32:33 UTC (rev 108)
@@ -10,6 +10,10 @@
 - added another debug level (8) for function call tracing.  while this
   flag is set all function calls with their arguments and return value
   will be displayed to the user as a runtime warning.  
+- HOES will now allow sleep data structures (arrays and hashes) to be passed
+  as java.util.List and java.util.Map data structures (via an expensive
+  conversion process).  This conversion only applies one way i.e. a Java List
+  or Java Map can not be used as a Sleep array or hash.
 
 2.1-beta 3
 ===========



From rsmudge at mail.berlios.de  Sun Sep 10 21:08:56 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sun, 10 Sep 2006 21:08:56 +0200
Subject: [Sleep-svn] r109 - in sleep: . src/sleep/runtime tests tests/output
Message-ID: <200609101908.k8AJ8ujS028246@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-10 21:08:55 +0200 (Sun, 10 Sep 2006)
New Revision: 109

Added:
   sleep/tests/fe_generatordb.sl
   sleep/tests/output/fe_generatordb.sl
Modified:
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/tests/output/trace.sl
   sleep/whatsnew.txt
Log:
Altered the debugging output stuff and made it handle key/value pair args w/o a problem.



Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2006-09-10 18:32:33 UTC (rev 108)
+++ sleep/src/sleep/runtime/SleepUtils.java	2006-09-10 19:08:55 UTC (rev 109)
@@ -34,8 +34,7 @@
 
 import java.io.*;
 
-import sleep.bridges.BridgeUtilities;
-import sleep.bridges.SleepClosure;
+import sleep.bridges.*;
 
 /** This class contains generalized utilities for instantiating/wrapping data into the sleep Scalar type. 
   * Included for free are methods for executing sleep blocks as well. 
@@ -415,9 +414,14 @@
          {
             return scalar.toString();
          }
+         else if (scalar.objectValue() instanceof KeyValuePair)
+         {
+            KeyValuePair kvp = (KeyValuePair)scalar.objectValue();
+            return kvp.getKey().toString() + " => " + describe(kvp.getValue());
+         }
          else if (scalar.getValue() instanceof ObjectValue)
          {
-            return "[" + scalar.toString() + "]";
+            return scalar.toString();
          }
          else if (scalar.getValue() instanceof LongValue)
          {

Added: sleep/tests/fe_generatordb.sl
===================================================================
--- sleep/tests/fe_generatordb.sl	2006-09-10 18:32:33 UTC (rev 108)
+++ sleep/tests/fe_generatordb.sl	2006-09-10 19:08:55 UTC (rev 109)
@@ -0,0 +1,45 @@
+#
+# test out foreach with closures...
+#
+debug(15);
+
+foreach $index => $value ({ this('$x'); for ($x = 0; $x < 10; $x++) { yield "val: $x"; } return $null; })
+{
+   println("$index => $value");
+}
+
+sub _range
+{
+   while ($start < $stop)
+   {
+      yield $start;
+      $start++;
+   }
+
+   return $null;
+}
+
+foreach $index => $value (lambda(&_range, $start => 50, $stop => 60))
+{
+   println("Testing out range stuff: $index => $value");
+}
+
+sub _range2
+{
+   this('$start $stop');
+   ($start, $stop) = @_;
+   yield $this;
+
+   while ($start < $stop)
+   {
+      yield $start;
+      $start++;
+   }
+
+   return $null;
+}
+
+foreach $index => $value (_range2(70, 80))
+{
+   println("My third test: $index => $value");
+}

Added: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-10 18:32:33 UTC (rev 108)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-10 19:08:55 UTC (rev 109)
@@ -0,0 +1,64 @@
+Trace: &this('$x') at line 6
+0 => val: 0
+Trace: &println('0 => val: 0') at line 8
+1 => val: 1
+Trace: &println('1 => val: 1') at line 8
+2 => val: 2
+Trace: &println('2 => val: 2') at line 8
+3 => val: 3
+Trace: &println('3 => val: 3') at line 8
+4 => val: 4
+Trace: &println('4 => val: 4') at line 8
+5 => val: 5
+Trace: &println('5 => val: 5') at line 8
+6 => val: 6
+Trace: &println('6 => val: 6') at line 8
+7 => val: 7
+Trace: &println('7 => val: 7') at line 8
+8 => val: 8
+Trace: &println('8 => val: 8') at line 8
+9 => val: 9
+Trace: &println('9 => val: 9') at line 8
+Trace: &lambda(&closure16668447, $start => 50, $stop => 60) = &closure649878 at line 22
+Testing out range stuff: 0 => 50
+Trace: &println('Testing out range stuff: 0 => 50') at line 24
+Testing out range stuff: 1 => 51
+Trace: &println('Testing out range stuff: 1 => 51') at line 24
+Testing out range stuff: 2 => 52
+Trace: &println('Testing out range stuff: 2 => 52') at line 24
+Testing out range stuff: 3 => 53
+Trace: &println('Testing out range stuff: 3 => 53') at line 24
+Testing out range stuff: 4 => 54
+Trace: &println('Testing out range stuff: 4 => 54') at line 24
+Testing out range stuff: 5 => 55
+Trace: &println('Testing out range stuff: 5 => 55') at line 24
+Testing out range stuff: 6 => 56
+Trace: &println('Testing out range stuff: 6 => 56') at line 24
+Testing out range stuff: 7 => 57
+Trace: &println('Testing out range stuff: 7 => 57') at line 24
+Testing out range stuff: 8 => 58
+Trace: &println('Testing out range stuff: 8 => 58') at line 24
+Testing out range stuff: 9 => 59
+Trace: &println('Testing out range stuff: 9 => 59') at line 24
+Trace: &this('$start $stop') at line 29
+Trace: &_range2(70, 80) = &closure539419 at line 42
+My third test: 0 => 70
+Trace: &println('My third test: 0 => 70') at line 44
+My third test: 1 => 71
+Trace: &println('My third test: 1 => 71') at line 44
+My third test: 2 => 72
+Trace: &println('My third test: 2 => 72') at line 44
+My third test: 3 => 73
+Trace: &println('My third test: 3 => 73') at line 44
+My third test: 4 => 74
+Trace: &println('My third test: 4 => 74') at line 44
+My third test: 5 => 75
+Trace: &println('My third test: 5 => 75') at line 44
+My third test: 6 => 76
+Trace: &println('My third test: 6 => 76') at line 44
+My third test: 7 => 77
+Trace: &println('My third test: 7 => 77') at line 44
+My third test: 8 => 78
+Trace: &println('My third test: 8 => 78') at line 44
+My third test: 9 => 79
+Trace: &println('My third test: 9 => 79') at line 44

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2006-09-10 18:32:33 UTC (rev 108)
+++ sleep/tests/output/trace.sl	2006-09-10 19:08:55 UTC (rev 109)
@@ -1,15 +1,15 @@
 this is a test
-Trace: [[java.io.PrintStream at d4d66b] println: 'this is a test'] at line 6
+Trace: [java.io.PrintStream at d4d66b println: 'this is a test'] at line 6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 7
 81.0
-Trace: [[java.io.PrintStream at d4d66b] println: 81.0] at line 7
+Trace: [java.io.PrintStream at d4d66b println: 81.0] at line 7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at line 8
 243.0
 Trace: &println(243.0) at line 8
 testing again...
-Trace: [[java.io.PrintStream at d4d66b] println: 'testing again...'] at line 9
-Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [[a, b, c]] at line 11
-Trace: [new java.util.LinkedList: [[a, b, c]]] = [[a, b, c]] at line 11
+Trace: [java.io.PrintStream at d4d66b println: 'testing again...'] at line 9
+Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at line 11
+Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at line 11
 Warning: variable '$list' not declared at line 11
 [a, b, c]
-Trace: &println([[a, b, c]]) at line 13
+Trace: &println([a, b, c]) at line 13

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-10 18:32:33 UTC (rev 108)
+++ sleep/whatsnew.txt	2006-09-10 19:08:55 UTC (rev 109)
@@ -9,7 +9,8 @@
   consistent with the sleep literal form
 - added another debug level (8) for function call tracing.  while this
   flag is set all function calls with their arguments and return value
-  will be displayed to the user as a runtime warning.  
+  will be displayed to the user as a runtime warning.  Enable with:
+  debug(debug() & 8);
 - HOES will now allow sleep data structures (arrays and hashes) to be passed
   as java.util.List and java.util.Map data structures (via an expensive
   conversion process).  This conversion only applies one way i.e. a Java List



From rsmudge at mail.berlios.de  Mon Sep 11 03:08:38 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 11 Sep 2006 03:08:38 +0200
Subject: [Sleep-svn] r110 - in sleep: . src/sleep/bridges src/sleep/parser
	src/sleep/runtime tests tests/data tests/data/src/org/hick
	tests/data/src/org/hick/blah tests/output
Message-ID: <200609110108.k8B18ciQ008109@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-11 03:08:36 +0200 (Mon, 11 Sep 2006)
New Revision: 110

Added:
   sleep/tests/data/src/org/hick/blah/
   sleep/tests/data/src/org/hick/blah/SqueezeBox.java
   sleep/tests/impfrom.sl
   sleep/tests/output/impfrom.sl
Modified:
   sleep/build.xml
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/parser/CodeGenerator.java
   sleep/src/sleep/parser/Parser.java
   sleep/src/sleep/parser/ParserConfig.java
   sleep/src/sleep/parser/TokenParser.java
   sleep/src/sleep/runtime/ScriptLoader.java
   sleep/tests/data/test.jar
   sleep/tests/output/fe_generatordb.sl
   sleep/tests/output/trace.sl
   sleep/tests/trace.sl
   sleep/whatsnew.txt
Log:
Added the ability to import 3rd party jar files... oooh.



Modified: sleep/build.xml
===================================================================
--- sleep/build.xml	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/build.xml	2006-09-11 01:08:36 UTC (rev 110)
@@ -16,7 +16,7 @@
            destdir="${project.build}"
            nowarn="yes"
            depend="yes"
-           debug="false"
+           debug="true"
            source="1.4"
            target="1.4"
            optimize="yes"

Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -182,12 +182,12 @@
 
           if (l.size() == 2)
           {
-             parent    = BridgeUtilities.getFile(l);
+             parent    = sleep.parser.ParserConfig.findJarFile(l.pop().toString());
              className = BridgeUtilities.getString(l, "");
           }
           else
           {
-             File a    = BridgeUtilities.getFile(l);
+             File a    = sleep.parser.ParserConfig.findJarFile(l.pop().toString());
              parent    = a.getParentFile();
              className = a.getName();
           }

Modified: sleep/src/sleep/parser/CodeGenerator.java
===================================================================
--- sleep/src/sleep/parser/CodeGenerator.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/src/sleep/parser/CodeGenerator.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -1014,7 +1014,14 @@
            add(atom, tokens[1]);
            break;
          case OBJECT_IMPORT:
-           parser.importPackage(strings[0]);
+           if (strings.length == 1)
+           {
+              parser.importPackage(strings[0], null);
+           }
+           else
+           {
+              parser.importPackage(strings[0], strings[1]);
+           }
            break;           
          case EXPR_RETURN:                     // implemented
            atom = GeneratedSteps.CreateFrame();

Modified: sleep/src/sleep/parser/Parser.java
===================================================================
--- sleep/src/sleep/parser/Parser.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/src/sleep/parser/Parser.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -48,6 +48,7 @@
 import sleep.engine.Block;
 
 import java.io.*;
+import java.net.*;
 
 public class Parser
 {
@@ -69,53 +70,90 @@
 
    public    char       EndOfTerm  = ';';
 
-   protected LinkedList imports   = new LinkedList();
+   protected Map        imports   = new LinkedHashMap();
    protected HashMap    classes   = new HashMap();
 
+   protected HashMap    jars      = new HashMap(); /* resolved jar files, key=jar name value=ClassLoader */
+
    /** Used by hoes to import package names... */
-   public void importPackage(String packagez)
+   public void importPackage(String packagez, String from)
    {
-       if (packagez.endsWith(".*"))
+       String pack, clas;
+       clas = packagez.substring(packagez.lastIndexOf(".") + 1, packagez.length());
+       pack = packagez.substring(0, packagez.lastIndexOf("."));
+
+       /* resolve and setup our class loader for the specified jar file */
+
+       if (from != null && !jars.containsKey(from))
        {
-          imports.add(packagez.substring(0, packagez.length() - 2));
+          try
+          {
+             URLClassLoader loader = new URLClassLoader(new URL[] { ParserConfig.findJarFile(from).toURL() }, Thread.currentThread().getContextClassLoader());
+             jars.put(from, loader);
+          }
+          catch (Exception ex) { }
        }
+
+       /* handle importing our package */
+
+ 
+       if (clas.equals("*"))
+       {
+          imports.put(pack, from);
+       }
        else
        {
-          try
+          Class found = findImportedClass(packagez);
+          classes.put(clas, found);
+       }
+   }
+
+   private Class resolveClass(String pack, String clas, String jar)
+   {
+//       System.out.println("Attempting to resolve: '" + pack + "' + '" + clas + "' + '" + jar + "'");
+
+       try
+       {
+          if (jar != null)
           {
-             Class temp = Class.forName(packagez);
-             classes.put(packagez.substring(packagez.lastIndexOf(".") + 1, packagez.length()), temp);
+             ClassLoader cl = (ClassLoader)jars.get(jar);
+             return Class.forName(pack + "." + clas, true, cl);
           }
-          catch (Exception ex) { }
+          else
+          {
+             return Class.forName(pack + "." + clas);
+          }
        }
+       catch (Exception ex) { }
+
+       return null;
    }
 
    public Class findImportedClass(String name)
    {
        if (classes.get(name) == null)
        {
-          Class temp;
-          try
+          Class rv = null;
+          String clas, pack;
+
+          if (name.indexOf(".") > -1)
           {
-             temp = Class.forName(name);
-             classes.put(name, temp);
-             return temp;
+             clas = name.substring(name.lastIndexOf(".") + 1, name.length());
+             pack = name.substring(0, name.lastIndexOf("."));
+
+	     rv   = resolveClass(pack, clas, null);
           }
-          catch (Exception ex) { }
-          
-
-          Iterator i = imports.iterator();
-          while (i.hasNext())
+          else
           {
-             try
+             Iterator i = imports.entrySet().iterator();
+             while (i.hasNext() && rv == null)
              {
-                temp = Class.forName(i.next().toString() + "." + name);
-                classes.put(name, temp);
-           
-                return temp;
+                Map.Entry en = (Map.Entry)i.next();
+                rv = resolveClass((String)en.getKey(), name, (String)en.getValue());
              }
-             catch (Exception ex) { }
           }
+
+          classes.put(name, rv);
        }
      
        return (Class)classes.get(name);
@@ -129,8 +167,9 @@
    /** initialize the parser with the code you want me to work with */
    public Parser(String _code)
    {
-      imports.add("java.lang");
-      imports.add("java.util");
+      importPackage("java.lang.*", null);
+      importPackage("java.util.*", null);
+      importPackage("sleep.runtime.*", null);
 
       code = _code;
    }

Modified: sleep/src/sleep/parser/ParserConfig.java
===================================================================
--- sleep/src/sleep/parser/ParserConfig.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/src/sleep/parser/ParserConfig.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -23,6 +23,8 @@
  * @see sleep.interfaces.PredicateEnvironment
  * 
  */
+import java.io.*;
+
 public class ParserConfig
 {
    /** Installs an escape constant into the sleep parser.  Any time the escape constant escape is encountered inside of a 
@@ -37,4 +39,41 @@
    {
       Checkers.addKeyword(keyword);
    }
+
+   /** Query the Sleep classpath.  This is a semi-colon separated list of paths where sleep
+       should search for jar files that scripts attempt to import */
+   public static String getSleepClasspath()
+   {
+      return System.getProperty("sleep.classpath", ".");
+   }
+
+   /** Set the Sleep classpath.  A semi-colon separated list of paths where sleep should search for
+       jar files that scripts attempt to import */
+   public static void setSleepClasspath(String path)
+   {
+      System.setProperty("sleep.classpath", path);
+   }
+
+   /** Search the sleep classpath for the specified file.  Returns a File object reflecting where the
+       file was found.  This method does not return null.  If the file does not exist then a File object
+       constructed with just the passed in name is returned */
+   public static File findJarFile(String name)
+   {
+       File cp = new File(name);
+
+       if (cp.exists()) { return cp; }
+
+       String[] paths = System.getProperty("sleep.classpath", ".").split(";");
+
+       for (int x = 0; x < paths.length; x++)
+       {
+          File temp = new File(paths[x], name);
+          if (temp.exists())
+          {
+             return temp;
+          }
+       }
+
+       return cp;
+   }
 }

Modified: sleep/src/sleep/parser/TokenParser.java
===================================================================
--- sleep/src/sleep/parser/TokenParser.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/src/sleep/parser/TokenParser.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -586,16 +586,27 @@
 
             StringBuffer newExpr = new StringBuffer();
 
-            if (x == tokens.length) // if return is the only token, that means we have no EOT, ergo an error
-            {
-               parser.reportError("Missing terminator", new Token(newExpr.toString(), tokens[x - 1].getHint(), newExpr.toString().length()));
-               return null;
-            }
-           
             /* keep looping until we reach an end of term clause */
             while (x < strings.length && !strings[x].equals("EOT"))
             {
-               newExpr.append(strings[x]);
+               if (strings[x].equals("from:"))
+               {
+                  if (newExpr.length() == 0)
+                  {
+                     parser.reportError("Attempted to import '' from:", new Token("import from:", tokens[x].getHint(), "import from:".length()));
+                     return null;
+                  }
+                  else
+                  {
+                     myToken.add(new Token(newExpr.toString(), tokens[x].getHint()));
+                     newExpr = new StringBuffer();
+                  }
+               }
+               else
+               {
+                  newExpr.append(strings[x]);
+               }
+
                x++;
 
                if (x >= tokens.length)

Modified: sleep/src/sleep/runtime/ScriptLoader.java
===================================================================
--- sleep/src/sleep/runtime/ScriptLoader.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/src/sleep/runtime/ScriptLoader.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -100,6 +100,11 @@
     protected LinkedList bridgess;
 
     /**
+     * path to search for jar files imported using [import * from: *] syntax
+     */
+    protected LinkedList paths;
+
+    /**
      * initializes the script loader
      */
     public ScriptLoader()

Added: sleep/tests/data/src/org/hick/blah/SqueezeBox.java
===================================================================
--- sleep/tests/data/src/org/hick/blah/SqueezeBox.java	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/tests/data/src/org/hick/blah/SqueezeBox.java	2006-09-11 01:08:36 UTC (rev 110)
@@ -0,0 +1,12 @@
+package org.hick.blah;
+
+public class SqueezeBox
+{
+   protected int sq = 33;
+
+   public int squeeze()
+   { 
+      sq++;
+      return sq;
+   }
+}

Modified: sleep/tests/data/test.jar
===================================================================
(Binary files differ)

Added: sleep/tests/impfrom.sl
===================================================================
--- sleep/tests/impfrom.sl	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/tests/impfrom.sl	2006-09-11 01:08:36 UTC (rev 110)
@@ -0,0 +1,13 @@
+#
+# a test of import from...
+
+import org.hick.blah.* from: data/test.jar;
+
+$sq = [new SqueezeBox];
+
+for ($x = 0; $x < 10; $x++)
+{
+   println("Test: " . [$sq squeeze]);
+}
+
+

Modified: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-11 01:08:36 UTC (rev 110)
@@ -19,7 +19,7 @@
 Trace: &println('8 => val: 8') at line 8
 9 => val: 9
 Trace: &println('9 => val: 9') at line 8
-Trace: &lambda(&closure16668447, $start => 50, $stop => 60) = &closure649878 at line 22
+Trace: &lambda(&closure5761610, $start => 50, $stop => 60) = &closure14069849 at line 22
 Testing out range stuff: 0 => 50
 Trace: &println('Testing out range stuff: 0 => 50') at line 24
 Testing out range stuff: 1 => 51
@@ -41,7 +41,7 @@
 Testing out range stuff: 9 => 59
 Trace: &println('Testing out range stuff: 9 => 59') at line 24
 Trace: &this('$start $stop') at line 29
-Trace: &_range2(70, 80) = &closure539419 at line 42
+Trace: &_range2(70, 80) = &closure13878877 at line 42
 My third test: 0 => 70
 Trace: &println('My third test: 0 => 70') at line 44
 My third test: 1 => 71

Added: sleep/tests/output/impfrom.sl
===================================================================
--- sleep/tests/output/impfrom.sl	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/tests/output/impfrom.sl	2006-09-11 01:08:36 UTC (rev 110)
@@ -0,0 +1,10 @@
+Test: 34
+Test: 35
+Test: 36
+Test: 37
+Test: 38
+Test: 39
+Test: 40
+Test: 41
+Test: 42
+Test: 43

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/tests/output/trace.sl	2006-09-11 01:08:36 UTC (rev 110)
@@ -1,15 +1,15 @@
 this is a test
-Trace: [java.io.PrintStream at d4d66b println: 'this is a test'] at line 6
+Trace: [java.io.PrintStream at fe8ce8 println: 'this is a test'] at line 6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 7
 81.0
-Trace: [java.io.PrintStream at d4d66b println: 81.0] at line 7
+Trace: [java.io.PrintStream at fe8ce8 println: 81.0] at line 7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at line 8
 243.0
 Trace: &println(243.0) at line 8
 testing again...
-Trace: [java.io.PrintStream at d4d66b println: 'testing again...'] at line 9
-Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at line 11
-Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at line 11
-Warning: variable '$list' not declared at line 11
+Trace: [java.io.PrintStream at fe8ce8 println: 'testing again...'] at line 10
+Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at line 12
+Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at line 12
+Warning: variable '$list' not declared at line 12
 [a, b, c]
-Trace: &println([a, b, c]) at line 13
+Trace: &println([a, b, c]) at line 14

Modified: sleep/tests/trace.sl
===================================================================
--- sleep/tests/trace.sl	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/tests/trace.sl	2006-09-11 01:08:36 UTC (rev 110)
@@ -6,6 +6,7 @@
 [[System out] println: "this is a test" ];
 [[System out] println: [Math pow:3, 4]];
 println([Math pow: 3, 5]);
+
 [[java.lang.System out] println: "testing again..."];
 
 $list = [new LinkedList: [sleep.runtime.SleepUtils getListFromArray: @("a", "b", "c")]];

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-10 19:08:55 UTC (rev 109)
+++ sleep/whatsnew.txt	2006-09-11 01:08:36 UTC (rev 110)
@@ -15,7 +15,15 @@
   as java.util.List and java.util.Map data structures (via an expensive
   conversion process).  This conversion only applies one way i.e. a Java List
   or Java Map can not be used as a Sleep array or hash.
+- added the ability to import classes from external jar files into sleep:
+  import org.jdom.* from: jdom.jar;
+  
+  Sleep also has a concept of a Sleep classpath, definable with sleep.classpath
+  or through the static methods in sleep.parser.ParserConfig.
+- updated the use() function to use the sleep classpath to search for the
+  specified jar file.
 
+
 2.1-beta 3
 ===========
 - added an optional timeout parameter for the socket connect function i.e.:



From rsmudge at mail.berlios.de  Mon Sep 11 04:11:49 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 11 Sep 2006 04:11:49 +0200
Subject: [Sleep-svn] r111 - in sleep: . src/sleep/bridges src/sleep/runtime
	tests tests/output
Message-ID: <200609110211.k8B2BnLA017705@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-11 04:11:48 +0200 (Mon, 11 Sep 2006)
New Revision: 111

Added:
   sleep/tests/nosharel.sl
   sleep/tests/output/nosharel.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/whatsnew.txt
Log:
Fixed a bug with lambda sharing the vars used to initialize the closure...  



Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2006-09-11 01:08:36 UTC (rev 110)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2006-09-11 02:11:48 UTC (rev 111)
@@ -413,7 +413,7 @@
           while (!l.isEmpty())
           {
              KeyValuePair kvp = BridgeUtilities.getKeyValuePair(l);
-             vars.putScalar(kvp.getKey().toString(), kvp.getValue());
+             vars.putScalar(kvp.getKey().toString(), SleepUtils.getScalar(kvp.getValue()));
           }
 
           return SleepUtils.getScalar(value);

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2006-09-11 01:08:36 UTC (rev 110)
+++ sleep/src/sleep/runtime/SleepUtils.java	2006-09-11 02:11:48 UTC (rev 111)
@@ -49,7 +49,7 @@
 public class SleepUtils
 {
    /** A date stamp of this Sleep release in YYYYMMDD format */
-   public static final int    SLEEP_RELEASE = 20060818;
+   public static final int    SLEEP_RELEASE = 20060911;
 
    /** A string description of this Sleep release */
    public static final String SLEEP_VERSION = "Sleep 2.1";

Added: sleep/tests/nosharel.sl
===================================================================
--- sleep/tests/nosharel.sl	2006-09-11 01:08:36 UTC (rev 110)
+++ sleep/tests/nosharel.sl	2006-09-11 02:11:48 UTC (rev 111)
@@ -0,0 +1,8 @@
+$x = 4;
+
+$l = lambda({ println($x); }, $x => $x);
+
+$x = 5;
+
+[$l]; # pre Sleep2.1-b4 this would print 5 instead of 4 because lambda was sharing var containers when it shouldn't be
+

Added: sleep/tests/output/nosharel.sl
===================================================================
--- sleep/tests/output/nosharel.sl	2006-09-11 01:08:36 UTC (rev 110)
+++ sleep/tests/output/nosharel.sl	2006-09-11 02:11:48 UTC (rev 111)
@@ -0,0 +1 @@
+4

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-11 01:08:36 UTC (rev 110)
+++ sleep/whatsnew.txt	2006-09-11 02:11:48 UTC (rev 111)
@@ -22,8 +22,9 @@
   or through the static methods in sleep.parser.ParserConfig.
 - updated the use() function to use the sleep classpath to search for the
   specified jar file.
+- fixed lambda({}, $x => $y) sharing scalar container references (caused a 
+  change to $x inside of the closure to affect the value of $y)
 
-
 2.1-beta 3
 ===========
 - added an optional timeout parameter for the socket connect function i.e.:



From rsmudge at mail.berlios.de  Mon Sep 11 04:24:45 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 11 Sep 2006 04:24:45 +0200
Subject: [Sleep-svn] r112 - in sleep: . docs
Message-ID: <200609110224.k8B2Ojwe018974@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-11 04:24:44 +0200 (Mon, 11 Sep 2006)
New Revision: 112

Modified:
   sleep/docs/sleeplang.html
   sleep/readme.txt
Log:
Sleep 2.1 ready for release maaaaster



Modified: sleep/docs/sleeplang.html
===================================================================
--- sleep/docs/sleeplang.html	2006-09-11 02:11:48 UTC (rev 111)
+++ sleep/docs/sleeplang.html	2006-09-11 02:24:44 UTC (rev 112)
@@ -806,7 +806,7 @@
 <p>These functions are useful if you would like to easily implement your own sorting function.  For example to implement a case
 insensitive sort:</P>
 
-<pre>@array = array("Jill", "Jack", "BoB", "iReNE", "aDaWG");
+<pre>@array = @("Jill", "Jack", "BoB", "iReNE", "aDaWG");
 
 sub my_sort
 {
@@ -822,10 +822,10 @@
 <p>Sleep arrays are just arrays of scalars.  It is possible for one of the elements of a scalar array to contain another scalar 
 array (or hash for that matter).  The following sets up a multidimensional array:</p>
 
-<pre>@data = array(
-          array("a", "b", "c"),
-          array(1, 2, 3, 4),
-          array('.', '!', '#', '*')
+<pre>@data = @(
+          @("a", "b", "c"),
+          @(1, 2, 3, 4),
+          @('.', '!', '#', '*')
        );</pre>
 
 <p>In the example above @data is an array of arrays.  To access an individual element of @data:</p>
@@ -876,10 +876,10 @@
 
 <h3>The Key/Value Operator</h3>
 
-<p>Hashes can quickly be created using the <code>hash()</code> function.  The hash() function takes a special kind of parameter 
-known as a key/value pair:</p>
+<p>Sleep has a literal form for dictionary data structures (hashes).  To construct a hash in place use a % followed
+by a comma separated list of key/value pairs enclosed in parantheses.  i.e.</P>
 
-<pre>%hash = hash(key1 => "this is a value", key2 => 3 * (9 % 7));</pre>
+<pre>%hash = %(key1 => "this is a value", key2 => 3 * (9 % 7));</pre>
 
 <p>The => is the key/value pair operator.  Any time a key/value pair is required as a parameter it can be specified with => or 
 as a string separating the key/value by an equal sign i.e. 'key=value'.  The => operator is special because the left hand side (key) is taken 
@@ -890,10 +890,10 @@
 <p>Multidimensional hashes work exactly the same as Sleep arrays.  It is also possible to have an array of hashes, or a hash of 
 arrays.  Sleep even allows these two data structures to be mixed and matched as you please.</p>
 
-<pre>%hash = hash(letters => array("a", "b", "c", "d"),
-             names   => hash(
-                          rsm => "Raphael Mudge",
-                          fvm => "Frances Mudge")
+<pre>%hash = %(letters => @("a", "b", "c", "d"),
+               names   => %(
+                            rsm => "Raphael Mudge",
+                            fvm => "Frances Mudge")
             );</pre>
 
 <p>When a script tries to index to a level that is deeper than has been indexed prior Sleep will create a new hash/array as 
@@ -1344,6 +1344,26 @@
 <p>The above example breaks the string "this is a test" down by the delimeter " " using the java.util.StringTokenizer 
 class.</p>
 
+<h4>Using 3rd Party Jars</h4>
+
+<p>Sleep can also import packages from jar files not loaded in the classpath.  For example to use the JDOM XML API in
+a Sleep script one would:</p>
+
+<pre>import org.jdom.*        from: jdom.jar;
+import org.jdom.input.*  from: jdom.jar;
+import org.jdom.output.* from: jdom.jar;
+
+# load the document in
+$builder  = [new SAXBuilder];
+$document = [$builder build: @ARGV[0]];
+
+# print the document out.
+$output   = [new XMLOutputter: [Format getPrettyFormat]];
+[$output output: $document, [System out]];</pre>
+
+<p>Sleep will try to find the specified jar file (i.e. jdom.jar) using the Sleep classpath.  This value is the
+sleep.classpath accessible as systemProperties()["sleep.classpath"].</p>
+
 <h3>Sleep Interfaces</h3>
 
 <p>A neat feature of HOES is how interfaces can be quickly and easily created and passed to Java objects.  A Java interface
@@ -1405,13 +1425,16 @@
 <p>If the automatic casting is not enough, Sleep includes a <code>&amp;cast</code> function.  The <code>&amp;cast</code> 
 function will cast an @array into any Java type.  Dimensions can be specified as well.  For example:</p>
 
-<pre>@array = array("a", "b", "c", "d", "e", "f");
+<pre>@array = @("a", "b", "c", "d", "e", "f");
 $casted = cast(@array, "*", 2, 3); # create a 2x3 array</pre>
 
 <p>The example above creates an object scalar <var>$casted</var> that references a 2x3 array of Strings.  The elements of 
 $casted are (("a, "b", "c"), ("d", "e", "f")).  Note that the @array argument passed to <code>&amp;cast</code> is flattened 
 prior to casting.</p>
 
+<p>Sleep will also convert a Sleep array scalar into a java.util.List if need be.  Likewise a Sleep hash scalar
+is converted into a java.util.Map if a function requires such an argument.</p>
+
 <h3>Catching Exceptions</h3>
 
 <p>Often times Java API's acessed via HOES can throw an "exception".  Exceptions are a mechanism used to notify programs that some type of error has occured.  You can check for an exception using the <code>checkError($scalar)</code> function.</p>
@@ -2395,7 +2418,7 @@
  <tr>
   <td>$</td>
   <td>debug(level)</td>
-  <td>explicitly enables the specified debug level for this script: 0 - no debugging; 1 - show only critical errors (default); 2 - show all warnings; 4 - show first time use of non-declared variables.  any of the levels can be |'d together.</td>
+  <td>explicitly enables the specified debug level for this script: 0 - no debugging; 1 - show only critical errors (default); 2 - show all warnings; 4 - show first time use of non-declared variables; 8 - trace all function calls.  any of the levels can be |'d together.</td>
  </tr>
  <tr>
   <td>$</td>

Modified: sleep/readme.txt
===================================================================
--- sleep/readme.txt	2006-09-11 02:11:48 UTC (rev 111)
+++ sleep/readme.txt	2006-09-11 02:24:44 UTC (rev 112)
@@ -1,5 +1,5 @@
  ------- -------------------- ---------   ---------------  ------- ---------
-Sleep - 2.1 beta 3 - README   
+Sleep - 2.1 beta 4 - README   
 -  ------------- -------- -   ---------------- --       -    -     -     - - -
 
 "You got the language, all you need now is the O'Reilly book".  That is



From rsmudge at mail.berlios.de  Tue Sep 12 01:36:15 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Tue, 12 Sep 2006 01:36:15 +0200
Subject: [Sleep-svn] r113 - in sleep: . src/sleep/parser tests tests/output
Message-ID: <200609112336.k8BNaEie013826@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-12 01:36:12 +0200 (Tue, 12 Sep 2006)
New Revision: 113

Added:
   sleep/tests/impfrom2.sl
   sleep/tests/output/impfrom2.sl
Modified:
   sleep/src/sleep/parser/Parser.java
   sleep/whatsnew.txt
Log:
Fixed a bug with import.



Modified: sleep/src/sleep/parser/Parser.java
===================================================================
--- sleep/src/sleep/parser/Parser.java	2006-09-11 02:24:44 UTC (rev 112)
+++ sleep/src/sleep/parser/Parser.java	2006-09-11 23:36:12 UTC (rev 113)
@@ -96,13 +96,14 @@
 
        /* handle importing our package */
 
- 
        if (clas.equals("*"))
        {
           imports.put(pack, from);
        }
        else
        {
+          imports.put(packagez, from);
+         
           Class found = findImportedClass(packagez);
           classes.put(clas, found);
        }
@@ -141,7 +142,7 @@
              clas = name.substring(name.lastIndexOf(".") + 1, name.length());
              pack = name.substring(0, name.lastIndexOf("."));
 
-	     rv   = resolveClass(pack, clas, null);
+	     rv   = resolveClass(pack, clas, (String)imports.get(name));
           }
           else
           {

Added: sleep/tests/impfrom2.sl
===================================================================
--- sleep/tests/impfrom2.sl	2006-09-11 02:24:44 UTC (rev 112)
+++ sleep/tests/impfrom2.sl	2006-09-11 23:36:12 UTC (rev 113)
@@ -0,0 +1,13 @@
+#
+# a test of import from... (testing full path import, eh?!?)
+
+import org.hick.blah.SqueezeBox from: data/test.jar;
+
+$sq = [new SqueezeBox];
+
+for ($x = 0; $x < 10; $x++)
+{
+   println("Test: " . [$sq squeeze]);
+}
+
+

Added: sleep/tests/output/impfrom2.sl
===================================================================
--- sleep/tests/output/impfrom2.sl	2006-09-11 02:24:44 UTC (rev 112)
+++ sleep/tests/output/impfrom2.sl	2006-09-11 23:36:12 UTC (rev 113)
@@ -0,0 +1,10 @@
+Test: 34
+Test: 35
+Test: 36
+Test: 37
+Test: 38
+Test: 39
+Test: 40
+Test: 41
+Test: 42
+Test: 43

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-11 02:24:44 UTC (rev 112)
+++ sleep/whatsnew.txt	2006-09-11 23:36:12 UTC (rev 113)
@@ -1,3 +1,9 @@
+2.1-beta 5
+===========
+- fixed a bug with import [path] from: [jar] not working when a package.class
+  combination was specified.
+
+
 2.1-beta 4
 ===========
 - added a literal form for arrays and hashes:



From rsmudge at mail.berlios.de  Wed Sep 13 01:06:05 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Wed, 13 Sep 2006 01:06:05 +0200
Subject: [Sleep-svn] r114 - in sleep: . src/sleep/bridges src/sleep/engine
	src/sleep/engine/atoms src/sleep/engine/types tests
	tests/data tests/data/src/org/hick/blah tests/output
Message-ID: <200609122306.k8CN659G010770@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-13 01:06:03 +0200 (Wed, 13 Sep 2006)
New Revision: 114

Added:
   sleep/tests/multih.sl
   sleep/tests/output/multih.sl
   sleep/tests/output/wrong.sl
   sleep/tests/wrong.sl
Modified:
   sleep/src/sleep/bridges/BasicNumbers.java
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/engine/ObjectUtilities.java
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/src/sleep/engine/types/ObjectValue.java
   sleep/tests/data/src/org/hick/blah/SqueezeBox.java
   sleep/tests/data/test.jar
   sleep/tests/output/fe_generatordb.sl
   sleep/tests/trace.sl
   sleep/whatsnew.txt
Log:
Broke the language... or added lots of cool stuff... take your pick.



Modified: sleep/src/sleep/bridges/BasicNumbers.java
===================================================================
--- sleep/src/sleep/bridges/BasicNumbers.java	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/src/sleep/bridges/BasicNumbers.java	2006-09-12 23:06:03 UTC (rev 114)
@@ -40,16 +40,9 @@
   
     public BasicNumbers()
     {
-       try
-       {
-          TYPE_LONG   = Class.forName("sleep.engine.types.LongValue");
-          TYPE_INT    = Class.forName("sleep.engine.types.IntValue");
-          TYPE_DOUBLE = Class.forName("sleep.engine.types.DoubleValue");
-       }
-       catch (Exception ex)
-       {
-          ex.printStackTrace();
-       }
+       TYPE_LONG   = sleep.engine.types.LongValue.class;
+       TYPE_INT    = sleep.engine.types.IntValue.class;
+       TYPE_DOUBLE = sleep.engine.types.DoubleValue.class;
     }
 
     public boolean scriptUnloaded(ScriptInstance aScript)

Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2006-09-12 23:06:03 UTC (rev 114)
@@ -75,8 +75,11 @@
 
         temp.put("&map",    map_f);
         temp.put("&filter",    map_f);
-        temp.put("&cast",   new f_cast());
 
+        Function f_cast = new f_cast();
+        temp.put("&cast",    f_cast);
+        temp.put("&casti",   f_cast);
+
         temp.put("&addAll", this);
         temp.put("&removeAll", this);
         temp.put("&retainAll", this);
@@ -253,6 +256,21 @@
 
           if (type.length() == 0) { type = " "; }
 
+          if (n.equals("&casti"))
+          {
+             Class  atype = ObjectUtilities.convertDescriptionToClass(type);
+
+             if (atype != null)
+             {
+                Object tempo = ObjectUtilities.buildArgument(atype, value, si);
+                return SleepUtils.getScalar(tempo);
+             }
+             else
+             {
+                throw new RuntimeException("&casti: '" + type + "' is an invalid primitive cast identifier");
+             }
+          }
+
           if (value.getArray() == null)
           {
              if (type.charAt(0) == 'c')
@@ -291,37 +309,10 @@
 
           Object rv;
 
-          Class atype = null;
+          Class atype = ObjectUtilities.convertDescriptionToClass(type);
 
-          switch (type.charAt(0))
-          {
-             case 'z':
-                atype = Boolean.TYPE;
-                break;
-             case 'c':
-                atype = Character.TYPE;
-                break;
-             case 'b':
-                atype = Byte.TYPE;
-                break;
-             case 'h':
-                atype = Short.TYPE;
-                break;
-             case 'i':
-                atype = Integer.TYPE;
-                break;
-             case 'l':
-                atype = Long.TYPE;
-                break;
-             case 'f':
-                atype = Float.TYPE;
-                break;
-             case 'd':
-                atype = Double.TYPE;
-                break;
-             default:
-                atype = ObjectUtilities.getArrayType(value, ObjectUtilities.OBJECT_TYPE);
-          }
+          if (atype == null)
+              atype = ObjectUtilities.getArrayType(value, ObjectUtilities.OBJECT_TYPE);
 
           Scalar flat = BridgeUtilities.flattenArray(value, null);
 

Modified: sleep/src/sleep/engine/ObjectUtilities.java
===================================================================
--- sleep/src/sleep/engine/ObjectUtilities.java	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/src/sleep/engine/ObjectUtilities.java	2006-09-12 23:06:03 UTC (rev 114)
@@ -33,40 +33,48 @@
 
 import sleep.bridges.*;
 
+/** This class is sort of the center of the HOES universe containing several methods for mapping 
+    between Sleep and Java and resolving which mappings make sense. */
 public class ObjectUtilities
 {
    private static Class STRING_SCALAR;
    private static Class INT_SCALAR; 
    private static Class DOUBLE_SCALAR;
    private static Class LONG_SCALAR;
-   public  static Class BOOLEAN_TYPE, BYTE_TYPE, CHARACTER_TYPE, DOUBLE_TYPE, FLOAT_TYPE, INTEGER_TYPE, LONG_TYPE, STRING_TYPE, OBJECT_TYPE;
+   private static Class OBJECT_SCALAR;
 
+   /** various primitives... doo doo doo */
+   public static Class BOOLEAN_TYPE, BYTE_TYPE, CHARACTER_TYPE, DOUBLE_TYPE, FLOAT_TYPE, INTEGER_TYPE, LONG_TYPE, STRING_TYPE, OBJECT_TYPE;
+
    static
    {
-      try
-      {
-         STRING_SCALAR = Class.forName("sleep.engine.types.StringValue");
-         INT_SCALAR    = Class.forName("sleep.engine.types.IntValue");
-         DOUBLE_SCALAR = Class.forName("sleep.engine.types.DoubleValue");
-         LONG_SCALAR   = Class.forName("sleep.engine.types.LongValue");
+      STRING_SCALAR = sleep.engine.types.StringValue.class;
+      INT_SCALAR    = sleep.engine.types.IntValue.class;
+      DOUBLE_SCALAR = sleep.engine.types.DoubleValue.class;
+      LONG_SCALAR   = sleep.engine.types.LongValue.class;
+      OBJECT_SCALAR = sleep.engine.types.ObjectValue.class;
 
-         BOOLEAN_TYPE    = Class.forName("java.lang.Boolean");
-         BYTE_TYPE       = Class.forName("java.lang.Byte");
-         CHARACTER_TYPE  = Class.forName("java.lang.Character");
-         DOUBLE_TYPE     = Class.forName("java.lang.Double");
-         FLOAT_TYPE      = Class.forName("java.lang.Float");
-         INTEGER_TYPE    = Class.forName("java.lang.Integer");
-         LONG_TYPE       = Class.forName("java.lang.Long");
-         OBJECT_TYPE     = Class.forName("java.lang.Object");
-         STRING_TYPE     = Class.forName("java.lang.String");
-      }
-      catch (Exception ex) { }
+      BOOLEAN_TYPE    = java.lang.Boolean.class;
+      BYTE_TYPE       = java.lang.Byte.class;
+      CHARACTER_TYPE  = java.lang.Character.class;
+      DOUBLE_TYPE     = java.lang.Double.class;
+      FLOAT_TYPE      = java.lang.Float.class;
+      INTEGER_TYPE    = java.lang.Integer.class;
+      LONG_TYPE       = java.lang.Long.class;
+      OBJECT_TYPE     = java.lang.Object.class;
+      STRING_TYPE     = java.lang.String.class;
    }
 
-   public static final int ARG_MATCH_YES   = 1;
-   public static final int ARG_MATCH_NO    = 2;
-   public static final int ARG_MATCH_MAYBE = 3;
+   /** when looking for a Java method that matches the sleep args, we use a Yes match immediately */
+   public static final int ARG_MATCH_YES   = 3;
+  
+   /** when looking for a Java method that matches the sleep args, we immediately drop all of the no answers. */
+   public static final int ARG_MATCH_NO    = 0;
 
+   /** when looking for a Java method that matches the sleep args, we save the maybes and use them as a last resort if no yes match is found */
+   public static final int ARG_MATCH_MAYBE = 1;
+
+   /** convienence method to determine wether or not the stack of values is a safe match for the specified method signature */
    public static int isArgMatch(Class[] check, Stack arguments)
    {
       int value = ARG_MATCH_YES;
@@ -74,79 +82,157 @@
       for (int z = 0; z < check.length; z++)
       {
          Scalar scalar = (Scalar)arguments.get(check.length - z - 1);
-         Class stemp   = scalar.getClass();
-         String sstring = scalar.toString();
 
-         if (SleepUtils.isEmptyScalar(scalar))
+         value = value & isArgMatch(check[z], scalar);
+
+//         System.out.println("Matching: " + scalar + "(" + scalar.getValue().getClass() + "): to " + check[z] + ": " + value);
+ 
+         if (value == ARG_MATCH_NO)
          {
-             // do nothing, this argument is a give me
+            return ARG_MATCH_NO;
          }
-         else if (scalar.getArray() != null)
+      }
+
+      return value;
+   }
+
+   /** converts the primitive version of the specified class to a regular usable version */
+   private static Class normalizePrimitive(Class check)
+   {
+      if (check == Integer.TYPE) { check = Integer.class; }
+      else if (check == Double.TYPE)   { check = Double.class; }
+      else if (check == Long.TYPE)     { check = Long.class; }
+      else if (check == Float.TYPE)    { check = Float.class; }
+      else if (check == Boolean.TYPE)  { check = Boolean.class; }
+      else if (check == Byte.TYPE)     { check = Byte.class; }
+      else if (check == Character.TYPE) { check = Character.class; }
+      else if (check == Short.TYPE)    { check = Short.class; }
+
+      return check;
+   }
+
+   /** determined if the specified scalar can be rightfully cast to the specified class */
+   public static int isArgMatch(Class check, Scalar scalar)
+   {
+      if (SleepUtils.isEmptyScalar(scalar))
+      {
+         return ARG_MATCH_YES;
+      }
+      else if (scalar.getArray() != null)
+      {
+         if (check.isArray())
          {
-            if (check[z].isArray())
+            Class compType = check.getComponentType(); /* find the actual nuts and bolts component type so we can work with it */
+            while (compType.isArray())
             {
-               if (check[z].getComponentType() == OBJECT_TYPE)
+               compType = compType.getComponentType();
+            }
+
+            if (compType == OBJECT_TYPE)
+            {
+               return ARG_MATCH_MAYBE;
+            }
+            else
+            {
+               Class mytype = getArrayType(scalar, null);
+ 
+               if (mytype == compType)
                {
-                  value = ARG_MATCH_MAYBE;
+                  return ARG_MATCH_YES;
                }
                else
                {
-                  Class mytype = getArrayType(scalar, null);
- 
-                  if (mytype == check[z].getComponentType())
-                  {
-                     value = ARG_MATCH_YES;
-                  }
-                  else
-                  {
-                     // why are we not returning this?!? a test case should be devised to test the
-                     // implications...
-                     value = ARG_MATCH_NO;
-                  }
+                  return ARG_MATCH_NO;
                }
             }
-            else if (check[z].isAssignableFrom(java.util.List.class))
-            {
-               // would a java.util.List or java.util.Collection satisfy the argument?
-               value = ARG_MATCH_YES;
-            }
-            else if (!check[z].isInstance(scalar.objectValue()))
-            {
-               return ARG_MATCH_NO;
-            }
          }
-         else if (scalar.getHash() != null)
+         else if (check.isAssignableFrom(java.util.List.class))
          {
-            if (check[z].isAssignableFrom(java.util.Map.class))
-            {
-               // would a java.util.Map or java.util.Collection satisfy the argument?
-               value = ARG_MATCH_YES;
-            }
-            else if (!check[z].isInstance(scalar.objectValue()))
-            {
-               return ARG_MATCH_NO;
-            }
+            // would a java.util.List or java.util.Collection satisfy the argument?
+            return ARG_MATCH_YES;
          }
-         else if (check[z].isPrimitive() && !(stemp == INT_SCALAR || stemp == DOUBLE_SCALAR || stemp == LONG_SCALAR))
+         else if (check.isInstance(scalar.objectValue()))
          {
-            value = ARG_MATCH_MAYBE;
+            return ARG_MATCH_YES;
          }
-         else if (check[z].isInterface())
+         else
          {
-            if (!SleepUtils.isFunctionScalar(scalar) && !check[z].isInstance(scalar.objectValue()))
-               return ARG_MATCH_NO;
+            return ARG_MATCH_NO;
          }
-         else if (check[z] == STRING_TYPE && stemp != STRING_SCALAR)
+      }
+      else if (scalar.getHash() != null)
+      {
+         if (check.isAssignableFrom(java.util.Map.class))
          {
-            value = ARG_MATCH_MAYBE;
+            // would a java.util.Map or java.util.Collection satisfy the argument?
+            return ARG_MATCH_YES;
          }
-         else if (!check[z].isInstance(scalar.objectValue()))
+         else if (check.isInstance(scalar.objectValue()))
          {
+            return ARG_MATCH_YES;
+         }
+         else
+         {
             return ARG_MATCH_NO;
          }
       }
- 
-      return value;
+      else if (check.isPrimitive())
+      {
+         Class stemp = scalar.getValue().getClass();
+
+         if (stemp == INT_SCALAR && check == Integer.TYPE)
+         {
+            return ARG_MATCH_YES;
+         }
+         else if (stemp == DOUBLE_SCALAR && check == Double.TYPE)
+         {
+            return ARG_MATCH_YES;
+         }
+         else if (stemp == LONG_SCALAR && check == Long.TYPE)
+         {
+            return ARG_MATCH_YES;
+         }
+         else if (stemp == OBJECT_SCALAR)
+         {
+            check = normalizePrimitive(check);
+            return (scalar.objectValue().getClass() == check) ? ARG_MATCH_YES : ARG_MATCH_NO;
+         }
+         else
+         {
+            /* this is my lazy way of saying allow Long, Int, and Double scalar types to be considered
+               maybes... */
+            return (stemp == STRING_SCALAR) ? ARG_MATCH_NO : ARG_MATCH_MAYBE;
+         }
+      }
+      else if (check.isInterface())
+      {
+         if (SleepUtils.isFunctionScalar(scalar) || check.isInstance(scalar.objectValue()))
+         {
+            return ARG_MATCH_YES;
+         }
+         else
+         {
+            return ARG_MATCH_NO;
+         }
+      }
+      else if (check == STRING_TYPE)
+      {
+         Class stemp = scalar.getValue().getClass();
+         return (stemp == STRING_SCALAR) ? ARG_MATCH_YES : ARG_MATCH_MAYBE;
+      }
+      else if (check == OBJECT_TYPE)
+      {
+         return ARG_MATCH_MAYBE; /* we're vying for anything and this will match anything */
+      }
+      else if (check.isInstance(scalar.objectValue()))
+      {
+         Class stemp = scalar.getValue().getClass();
+         return (stemp == OBJECT_SCALAR) ? ARG_MATCH_YES : ARG_MATCH_MAYBE;
+      }
+      else
+      {
+         return ARG_MATCH_NO;
+      }
    }
 
    public static Method findMethod(Class theClass, String method, Stack arguments)
@@ -201,6 +287,42 @@
       return temp;
    }
 
+   /** converts the one character class description to the specified Class type, i.e. z = boolean, c = char, b = byte, i = integer, etc.. */
+   public static Class convertDescriptionToClass(String description)
+   {
+      Class atype = null;
+
+      switch (description.charAt(0))
+      {
+         case 'z':
+            atype = Boolean.TYPE;
+            break;
+         case 'c':
+            atype = Character.TYPE;
+            break;
+         case 'b':
+            atype = Byte.TYPE;
+            break;
+         case 'h':
+            atype = Short.TYPE;
+            break;
+         case 'i':
+            atype = Integer.TYPE;
+            break;
+         case 'l':
+            atype = Long.TYPE;
+            break;
+         case 'f':
+            atype = Float.TYPE;
+            break;
+         case 'd':
+            atype = Double.TYPE;
+            break;
+      }
+
+      return atype;
+   }
+
    public static Object buildArgument(Class type, Scalar value, ScriptInstance script)
    {
       if (type == STRING_TYPE)
@@ -211,19 +333,26 @@
       {
          if (type.isArray())
          {
-            Class atype = getArrayType(value, type.getComponentType());
+            try
+            {
+               Class atype = getArrayType(value, type.getComponentType());
 
-            Object arrayV = Array.newInstance(atype, value.getArray().size());
-            Iterator i = value.getArray().scalarIterator();
-            int x = 0;
-            while (i.hasNext())
+               Object arrayV = Array.newInstance(atype, value.getArray().size());
+               Iterator i = value.getArray().scalarIterator();
+               int x = 0;
+               while (i.hasNext())
+               {
+                   Scalar temp = (Scalar)i.next();
+                   Array.set(arrayV, x, buildArgument(atype, temp, script));
+                   x++;
+               }
+
+               return arrayV;
+            }
+            catch (Exception ex)
             {
-               Scalar temp = (Scalar)i.next();
-               Array.set(arrayV, x, buildArgument(atype, temp, script));
-               x++;
+               throw new RuntimeException(ex.getMessage() + " - maybe the dimensions are wrong?");
             }
-
-            return arrayV;
          }
          else if (type.isAssignableFrom(java.util.List.class))
          {
@@ -334,7 +463,6 @@
       return parameters;
    }
 
-
    public static Scalar BuildScalar(boolean primitives, Object value)
    {
       if (value == null)

Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-12 23:06:03 UTC (rev 114)
@@ -57,7 +57,7 @@
 
    public Scalar evaluate(ScriptEnvironment e)
    {
-      boolean isTrace = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
+      boolean isTrace   = (e.getScriptInstance().getDebugFlags() & ScriptInstance.DEBUG_TRACE_CALLS) == ScriptInstance.DEBUG_TRACE_CALLS;
 
       Scalar result = SleepUtils.getEmptyScalar();
 

Modified: sleep/src/sleep/engine/types/ObjectValue.java
===================================================================
--- sleep/src/sleep/engine/types/ObjectValue.java	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/src/sleep/engine/types/ObjectValue.java	2006-09-12 23:06:03 UTC (rev 114)
@@ -18,17 +18,56 @@
 
    public int intValue()
    {
-      return value.hashCode();
+      String str = toString();
+
+      if (str.length() == 0) { return 0; }
+      if (str.equals("true")) { return 1; }
+      if (str.equals("false")) { return 0; }
+
+      try
+      {
+         return Integer.decode(str).intValue();
+      }
+      catch (Exception ex)
+      {
+         return 0;
+      }
    }
 
    public long longValue()
    {
-      return (long)intValue();
+      String str = toString();
+
+      if (str.length() == 0) { return 0L; }
+      if (str.equals("true")) { return 1L; }
+      if (str.equals("false")) { return 0L; }
+
+      try
+      {
+         return Long.decode(str).longValue();
+      }
+      catch (Exception ex)
+      {
+         return 0L;
+      }
    }
 
    public double doubleValue()
    {
-      return (double)intValue();
+      String str = toString();
+
+      if (str.length() == 0) { return 0.0; }
+      if (str.equals("true")) { return 1.0; }
+      if (str.equals("false")) { return 0.0; }
+
+      try
+      {
+         return Double.parseDouble(str);
+      }
+      catch (Exception ex)
+      {
+         return 0;
+      }
    }
 
    public String toString()

Modified: sleep/tests/data/src/org/hick/blah/SqueezeBox.java
===================================================================
--- sleep/tests/data/src/org/hick/blah/SqueezeBox.java	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/data/src/org/hick/blah/SqueezeBox.java	2006-09-12 23:06:03 UTC (rev 114)
@@ -9,4 +9,19 @@
       sq++;
       return sq;
    }
+
+   public void doStuff(double[][] matrix)
+   {
+      System.out.println("Printing the table:");
+
+      for (int x = 0; x < matrix.length; x++)
+      {
+         for (int y = 0; y < matrix[x].length; y++)
+         {
+            System.out.print(matrix[x][y] + "; ");
+         } 
+
+         System.out.println("");
+      }
+   } 
 }

Modified: sleep/tests/data/test.jar
===================================================================
(Binary files differ)

Added: sleep/tests/multih.sl
===================================================================
--- sleep/tests/multih.sl	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/multih.sl	2006-09-12 23:06:03 UTC (rev 114)
@@ -0,0 +1,14 @@
+#
+# test passing of a multidim data structure as a sleep array
+#
+
+import org.hick.blah.SqueezeBox from: data/test.jar;
+
+$sb = [new SqueezeBox];
+[$sb doStuff: @(@(1.0, 2.0, 3.0), @(4.0, 5.0, 6.0, 6.5), @(7.0, 8.0, 9.0))];
+
+[$sb doStuff: cast(@(@(1.0, 2.0, 3.0), @(4.0, 5.0, 6.0, 6.5), @(7.0, 8.0, 9.0)), "d", 2, 5)];
+[$sb doStuff: cast(@(@(1.0, 2.0, 3.0), @(4.0, 5.0, 6.0, 6.5), @(7.0, 8.0, 9.0)), "d", 5, 2)];
+
+[$sb doStuff: @(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)];
+

Modified: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-12 23:06:03 UTC (rev 114)
@@ -19,7 +19,7 @@
 Trace: &println('8 => val: 8') at line 8
 9 => val: 9
 Trace: &println('9 => val: 9') at line 8
-Trace: &lambda(&closure5761610, $start => 50, $stop => 60) = &closure14069849 at line 22
+Trace: &lambda(&closure1708953, $start => 50, $stop => 60) = &closure16564386 at line 22
 Testing out range stuff: 0 => 50
 Trace: &println('Testing out range stuff: 0 => 50') at line 24
 Testing out range stuff: 1 => 51
@@ -41,7 +41,7 @@
 Testing out range stuff: 9 => 59
 Trace: &println('Testing out range stuff: 9 => 59') at line 24
 Trace: &this('$start $stop') at line 29
-Trace: &_range2(70, 80) = &closure13878877 at line 42
+Trace: &_range2(70, 80) = &closure13301441 at line 42
 My third test: 0 => 70
 Trace: &println('My third test: 0 => 70') at line 44
 My third test: 1 => 71

Added: sleep/tests/output/multih.sl
===================================================================
--- sleep/tests/output/multih.sl	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/output/multih.sl	2006-09-12 23:06:03 UTC (rev 114)
@@ -0,0 +1,14 @@
+Printing the table:
+1.0; 2.0; 3.0; 
+4.0; 5.0; 6.0; 6.5; 
+7.0; 8.0; 9.0; 
+Printing the table:
+1.0; 2.0; 3.0; 4.0; 5.0; 
+6.0; 6.5; 7.0; 8.0; 9.0; 
+Printing the table:
+1.0; 2.0; 
+3.0; 4.0; 
+5.0; 6.0; 
+6.5; 7.0; 
+8.0; 9.0; 
+Warning: array element type mismatch - maybe the dimensions are wrong? at line 13

Added: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/output/wrong.sl	2006-09-12 23:06:03 UTC (rev 114)
@@ -0,0 +1,32 @@
+Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 6
+81.0
+Trace: [java.io.PrintStream at d6b059 println: 81.0] at line 6
+Trace: &casti(1, 'z') = true at line 9
+true
+Trace: [java.io.PrintStream at d6b059 println: true] at line 9
+Trace: &casti(0, 'z') = false at line 10
+false
+Trace: [java.io.PrintStream at d6b059 println: false] at line 10
+Trace: &casti(1, 'd') = 1.0 at line 13
+1.0
+Trace: [java.io.PrintStream at d6b059 println: 1.0] at line 13
+Trace: &casti(1, 'b') = 1 at line 16
+1
+Trace: [java.io.PrintStream at d6b059 println: 1] at line 16
+Trace: &casti(100, 'f') = 100.0 at line 19
+100.0
+Trace: [java.io.PrintStream at d6b059 println: 100.0] at line 19
+Trace: &casti('b', 'c') = b at line 22
+b
+Trace: [java.io.PrintStream at d6b059 println: b] at line 22
+Trace: &casti(63, 'i') = 63 at line 25
+63
+Trace: [java.io.PrintStream at d6b059 println: 63] at line 25
+this is a string y0
+Trace: [java.io.PrintStream at d6b059 println: 'this is a string y0'] at line 28
+Trace: [new java.lang.StringBuilder: 'test'] = test at line 31
+test
+Trace: [java.io.PrintStream at d6b059 println: test] at line 31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at b03c1a at line 34
+abcd
+Trace: [java.io.PrintStream at d6b059 println: [C at b03c1a] at line 34

Modified: sleep/tests/trace.sl
===================================================================
--- sleep/tests/trace.sl	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/trace.sl	2006-09-12 23:06:03 UTC (rev 114)
@@ -4,7 +4,7 @@
 debug(15);
 
 [[System out] println: "this is a test" ];
-[[System out] println: [Math pow:3, 4]];
+[[System out] println: [Math pow: 3, 4]];
 println([Math pow: 3, 5]);
 
 [[java.lang.System out] println: "testing again..."];

Added: sleep/tests/wrong.sl
===================================================================
--- sleep/tests/wrong.sl	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/tests/wrong.sl	2006-09-12 23:06:03 UTC (rev 114)
@@ -0,0 +1,34 @@
+#
+# this should print out as 81.0
+
+debug(15);
+
+[[System out] println: [Math pow: 3, 4]];
+
+# boolean test
+[[System out] println: casti(1, "z")];
+[[System out] println: casti(0, "z")];
+
+# double test
+[[System out] println: casti(1, "d")];
+
+# byte test
+[[System out] println: casti(1, "b")];
+
+# float test
+[[System out] println: casti(100, "f")];
+
+# char test
+[[System out] println: casti("b", "c")];
+
+# int test
+[[System out] println: casti(63, "i")];
+
+# string test
+[[System out] println: "this is a string y0"];
+
+# object test
+[[System out] println: [new StringBuilder: "test"]];
+
+# char array test
+[[System out] println: cast(@("a", "b", "c", "d"), "c")];

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-11 23:36:12 UTC (rev 113)
+++ sleep/whatsnew.txt	2006-09-12 23:06:03 UTC (rev 114)
@@ -2,7 +2,22 @@
 ===========
 - fixed a bug with import [path] from: [jar] not working when a package.class
   combination was specified.
+- fixed a bug where HOES was not recognizing sleep arrays as a valid argument
+  for methods/constructs expecting multidimensional arrays.
+- HOES mapping scalars to Java arguments is now a little bit stricter and more 
+  accurate.
+- added &casti(value, "t") to cast the specified value into a Java primitive type.
+- altered the semtantics for how Java Object values are converted to Sleep
+  scalar number values.  Essentially the Object is converted to a string and the
+  string is parsed with the following meaning:
+  <not a number> = 0
+  "true"         = 1
+  "false"        = 0
+  ""             = 0
+  <a number>     = <a number>
 
+  The old semantics (object hashcode) were worthless so I doubt there will be 
+  many complaints.
 
 2.1-beta 4
 ===========



From rsmudge at mail.berlios.de  Fri Sep 15 04:33:39 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 15 Sep 2006 04:33:39 +0200
Subject: [Sleep-svn] r115 - in sleep: . src/sleep/bridges
	src/sleep/bridges/io tests tests/output
Message-ID: <200609150233.k8F2Xda5031141@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-15 04:33:38 +0200 (Fri, 15 Sep 2006)
New Revision: 115

Added:
   sleep/tests/checksum.sl
   sleep/tests/output/checksum.sl
Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/bridges/io/IOObject.java
   sleep/tests/output/fe_generatordb.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
Added checksum capability to sleep



Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/src/sleep/bridges/BasicIO.java	2006-09-15 02:33:38 UTC (rev 115)
@@ -34,6 +34,9 @@
 import java.nio.*;
 import sleep.bridges.io.*;
 
+import java.util.zip.*;
+import javax.crypto.*;
+
 /** provides IO functions for the sleep language */
 public class BasicIO implements Loadable, Function
 {
@@ -94,9 +97,32 @@
 
         temp.put("&getConsole", new getConsoleObject());
 
+        /* integrity functions */
+        temp.put("&checksum", this);
+        temp.put("&digest",   this);
+
         return true;
     }
 
+    private static byte[] toByteArrayNoConversion(String textz)
+    {
+        char[] text = textz.toCharArray();
+        byte[] data = new byte[text.length];
+        for (int x = 0; x < text.length; x++)
+        {
+           data[x] = (byte)text[x];
+        }
+
+        return data;
+    }
+
+    private static Checksum getChecksum(String algorithm)
+    {
+       if (algorithm.equals("Adler32")) { return new Adler32(); }
+       if (algorithm.equals("CRC32")) { return new CRC32(); }
+       return null;
+    }
+
     public Scalar evaluate(String n, ScriptInstance i, Stack l)
     {
        if (n.equals("&wait"))
@@ -106,7 +132,53 @@
 
           return a.wait(i.getScriptEnvironment(), to);
        }
+       else if (n.equals("&checksum"))
+       {
+          Scalar   s = BridgeUtilities.getScalar(l);
+          if (s.objectValue() != null && s.objectValue() instanceof IOObject)
+          {
+             /* do our fun stuff to setup a checksum object */
 
+             boolean isRead  = true;
+
+             String temp = BridgeUtilities.getString(l, "CRC32");
+             if (temp.charAt(0) == '>')
+             {
+                isRead  = false;
+                temp    = temp.substring(1);
+             }
+             
+             IOObject io = (IOObject)s.objectValue();
+
+             if (isRead)
+             {
+                CheckedInputStream cis = new CheckedInputStream(io.getInputStream(), getChecksum(temp));
+                io.openRead(cis);
+                return SleepUtils.getScalar(cis.getChecksum());
+             }
+             else
+             {
+                CheckedOutputStream cos = new CheckedOutputStream(io.getOutputStream(), getChecksum(temp));
+                io.openWrite(cos);
+                return SleepUtils.getScalar(cos.getChecksum());
+             }
+          }
+          else if (s.objectValue() != null && s.objectValue() instanceof Checksum)
+          {
+             Checksum sum = (Checksum)s.objectValue();
+             return SleepUtils.getScalar(sum.getValue());
+          }
+          else
+          {
+             String temp = s.toString();
+             String algo = BridgeUtilities.getString(l, "CRC32");
+
+             Checksum doit = getChecksum(algo);
+             doit.update(toByteArrayNoConversion(temp), 0, temp.length());
+             return SleepUtils.getScalar(doit.getValue());
+          }
+       }
+
        System.out.println("apparently we were wrong about '" + n + "'");
 
        return SleepUtils.getEmptyScalar();

Modified: sleep/src/sleep/bridges/io/IOObject.java
===================================================================
--- sleep/src/sleep/bridges/io/IOObject.java	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/src/sleep/bridges/io/IOObject.java	2006-09-15 02:33:38 UTC (rev 115)
@@ -116,6 +116,18 @@
       return console;
    }
 
+   /** Returns the latest hooking point into the input stream */
+   public InputStream getInputStream()
+   {
+      return in;
+   }
+
+   /** Returns the latest hooking point into the output stream */
+   public OutputStream getOutputStream()
+   {
+      return out;
+   }
+
    /** Initializes a binary reader (a DataInputStream) and a text reader (a BufferedReader) against this input stream.  Calling this effectively makes this IOObject useable with Sleep's IO read* functions. */
    public void openRead(InputStream _in)
    {

Added: sleep/tests/checksum.sl
===================================================================
--- sleep/tests/checksum.sl	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/tests/checksum.sl	2006-09-15 02:33:38 UTC (rev 115)
@@ -0,0 +1,35 @@
+#
+# test the checksum API
+#
+
+$REAL = 990741747; # output of UNIX crc32 command for test.jar
+
+# first test... checksumming an I/O handle :)
+
+$handle = openf("data/test.jar");
+$summer = checksum($handle);
+readAll($handle); # read in the entire contents but we'll discard it...
+$sum    = checksum($summer);
+println("(1) Checksum value of test.jar is: " . $sum . " good? " . iff($sum eq $REAL, "yes", "no"));
+closef($handle);
+
+# second test... checksumming raw data
+
+$handle = openf("data/test.jar");
+$data   = readb($handle, lof("data/test.jar")); # read in the entire file
+$sum    = checksum($data, "CRC32");
+println("(2) Checksum value of test.jar is: " . $sum . " good? " . iff($sum eq $REAL, "yes", "no"));
+closef($handle);
+
+# third test.. the kewlest test of them all...
+
+$sumfork = fork({
+   readb($source, lof("data/test.jar"));
+});
+
+$summer = checksum($sumfork, ">CRC32");
+writeb($sumfork, $data);
+closef($sumfork);
+wait($sumfork);
+println("Checksum of written data is: " . checksum($summer));
+

Added: sleep/tests/output/checksum.sl
===================================================================
--- sleep/tests/output/checksum.sl	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/tests/output/checksum.sl	2006-09-15 02:33:38 UTC (rev 115)
@@ -0,0 +1,3 @@
+(1) Checksum value of test.jar is: 990741747 good? yes
+(2) Checksum value of test.jar is: 990741747 good? yes
+Checksum of written data is: 990741747

Modified: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-15 02:33:38 UTC (rev 115)
@@ -19,7 +19,7 @@
 Trace: &println('8 => val: 8') at line 8
 9 => val: 9
 Trace: &println('9 => val: 9') at line 8
-Trace: &lambda(&closure1708953, $start => 50, $stop => 60) = &closure16564386 at line 22
+Trace: &lambda(&closure2881682, $start => 50, $stop => 60) = &closure13389929 at line 22
 Testing out range stuff: 0 => 50
 Trace: &println('Testing out range stuff: 0 => 50') at line 24
 Testing out range stuff: 1 => 51
@@ -41,7 +41,7 @@
 Testing out range stuff: 9 => 59
 Trace: &println('Testing out range stuff: 9 => 59') at line 24
 Trace: &this('$start $stop') at line 29
-Trace: &_range2(70, 80) = &closure13301441 at line 42
+Trace: &_range2(70, 80) = &closure11742932 at line 42
 My third test: 0 => 70
 Trace: &println('My third test: 0 => 70') at line 44
 My third test: 1 => 71

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/tests/output/trace.sl	2006-09-15 02:33:38 UTC (rev 115)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at fe8ce8 println: 'this is a test'] at line 6
+Trace: [java.io.PrintStream at d6b059 println: 'this is a test'] at line 6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 7
 81.0
-Trace: [java.io.PrintStream at fe8ce8 println: 81.0] at line 7
+Trace: [java.io.PrintStream at d6b059 println: 81.0] at line 7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at line 8
 243.0
 Trace: &println(243.0) at line 8
 testing again...
-Trace: [java.io.PrintStream at fe8ce8 println: 'testing again...'] at line 10
+Trace: [java.io.PrintStream at d6b059 println: 'testing again...'] at line 10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at line 12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at line 12
 Warning: variable '$list' not declared at line 12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/tests/output/wrong.sl	2006-09-15 02:33:38 UTC (rev 115)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 6
 81.0
-Trace: [java.io.PrintStream at d6b059 println: 81.0] at line 6
+Trace: [java.io.PrintStream at 94257f println: 81.0] at line 6
 Trace: &casti(1, 'z') = true at line 9
 true
-Trace: [java.io.PrintStream at d6b059 println: true] at line 9
+Trace: [java.io.PrintStream at 94257f println: true] at line 9
 Trace: &casti(0, 'z') = false at line 10
 false
-Trace: [java.io.PrintStream at d6b059 println: false] at line 10
+Trace: [java.io.PrintStream at 94257f println: false] at line 10
 Trace: &casti(1, 'd') = 1.0 at line 13
 1.0
-Trace: [java.io.PrintStream at d6b059 println: 1.0] at line 13
+Trace: [java.io.PrintStream at 94257f println: 1.0] at line 13
 Trace: &casti(1, 'b') = 1 at line 16
 1
-Trace: [java.io.PrintStream at d6b059 println: 1] at line 16
+Trace: [java.io.PrintStream at 94257f println: 1] at line 16
 Trace: &casti(100, 'f') = 100.0 at line 19
 100.0
-Trace: [java.io.PrintStream at d6b059 println: 100.0] at line 19
+Trace: [java.io.PrintStream at 94257f println: 100.0] at line 19
 Trace: &casti('b', 'c') = b at line 22
 b
-Trace: [java.io.PrintStream at d6b059 println: b] at line 22
+Trace: [java.io.PrintStream at 94257f println: b] at line 22
 Trace: &casti(63, 'i') = 63 at line 25
 63
-Trace: [java.io.PrintStream at d6b059 println: 63] at line 25
+Trace: [java.io.PrintStream at 94257f println: 63] at line 25
 this is a string y0
-Trace: [java.io.PrintStream at d6b059 println: 'this is a string y0'] at line 28
+Trace: [java.io.PrintStream at 94257f println: 'this is a string y0'] at line 28
 Trace: [new java.lang.StringBuilder: 'test'] = test at line 31
 test
-Trace: [java.io.PrintStream at d6b059 println: test] at line 31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at b03c1a at line 34
+Trace: [java.io.PrintStream at 94257f println: test] at line 31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at f4bcf7 at line 34
 abcd
-Trace: [java.io.PrintStream at d6b059 println: [C at b03c1a] at line 34
+Trace: [java.io.PrintStream at 94257f println: [C at f4bcf7] at line 34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-12 23:06:03 UTC (rev 114)
+++ sleep/whatsnew.txt	2006-09-15 02:33:38 UTC (rev 115)
@@ -18,8 +18,17 @@
 
   The old semantics (object hashcode) were worthless so I doubt there will be 
   many complaints.
+- added checksumming capability to sleep, the function has the following forms:
 
-2.1-beta 4
+  $summer   = checksum($handle, "[[>]CRC32"|"[>]Adler32");
+  $sumvalue = checksum($summer); # when I/O on $handle is complete
+  or:
+  $sumvalue = checksum("string of data", ["CRC32"|"Adler32"])
+
+  The CRC32 and Adler32 algorithms are supported.  With an I/O handle specifying
+  a > before the algorithm name indicates that written data should be checksummed.
+
+2.1-beta 4  (11 Sept 06)
 ===========
 - added a literal form for arrays and hashes:
   @("a", "b", "c", "d", "e", @("f", "g", "h", "i"), "j", "k")
@@ -46,7 +55,7 @@
 - fixed lambda({}, $x => $y) sharing scalar container references (caused a 
   change to $x inside of the closure to affect the value of $y)
 
-2.1-beta 3
+2.1-beta 3  (18 Aug 06)
 ===========
 - added an optional timeout parameter for the socket connect function i.e.:
   $socket = connect("host", port, [timeout in milliseconds]) 
@@ -91,7 +100,7 @@
   causing arrays/hashes to share scalar references with passed in data. 
   &add, &addAll, &array, &filter, &map, &subarray, and &map.
 
-2.1-beta 2
+2.1-beta 2  (5 Aug 06)
 ===========
 - added a few more FP-style functions to Sleep:
   &reduce(&closure, @array)
@@ -146,7 +155,7 @@
   YourCodeSucksException class.   should make reporting parser errors less of
   a burden when embedding sleep into applications.
 
-2.1-beta 1
+2.1-beta 1  (16 Jun 06)
 ===========
 - fixed the clean target in the sleep build.xml file
 - added a continue keyword for flow control of while/for/foreach



From rsmudge at mail.berlios.de  Sat Sep 16 01:31:33 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 16 Sep 2006 01:31:33 +0200
Subject: [Sleep-svn] r116 - in sleep: . src/sleep/bridges src/sleep/runtime
	tests tests/output
Message-ID: <200609152331.k8FNVXQH028267@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-16 01:31:29 +0200 (Sat, 16 Sep 2006)
New Revision: 116

Added:
   sleep/tests/digest.sl
   sleep/tests/output/digest.sl
Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/tests/output/fe_generatordb.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
Lots of new stuff :)



Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/src/sleep/bridges/BasicIO.java	2006-09-15 23:31:29 UTC (rev 116)
@@ -36,6 +36,7 @@
 
 import java.util.zip.*;
 import javax.crypto.*;
+import java.security.*;
 
 /** provides IO functions for the sleep language */
 public class BasicIO implements Loadable, Function
@@ -132,6 +133,67 @@
 
           return a.wait(i.getScriptEnvironment(), to);
        }
+       else if (n.equals("&digest"))
+       {
+          Scalar   s = BridgeUtilities.getScalar(l);
+          if (s.objectValue() != null && s.objectValue() instanceof IOObject)
+          {
+             /* do our fun stuff to setup a checksum object */
+
+             boolean isRead  = true;
+
+             String temp = BridgeUtilities.getString(l, "MD5");
+             if (temp.charAt(0) == '>')
+             {
+                isRead  = false;
+                temp    = temp.substring(1);
+             }
+             
+             IOObject io = (IOObject)s.objectValue();
+
+             try
+             {
+                if (isRead)             {
+                   DigestInputStream cis = new DigestInputStream(io.getInputStream(), MessageDigest.getInstance(temp));
+                   io.openRead(cis);
+                   return SleepUtils.getScalar(cis.getMessageDigest());
+                }
+                else
+                {
+                   DigestOutputStream cos = new DigestOutputStream(io.getOutputStream(), MessageDigest.getInstance(temp));
+                   io.openWrite(cos);
+                   return SleepUtils.getScalar(cos.getMessageDigest());
+                }
+             }
+             catch (NoSuchAlgorithmException ex)
+             {
+                i.getScriptEnvironment().flagError("&digest: no such algorithm: " + temp);
+             }
+          }
+          else if (s.objectValue() != null && s.objectValue() instanceof MessageDigest)
+          {
+             MessageDigest sum = (MessageDigest)s.objectValue();
+             return SleepUtils.getScalar(sum.digest());
+          }
+          else
+          {
+             String temp = s.toString();
+             String algo = BridgeUtilities.getString(l, "MD5");
+             try
+             {
+
+                MessageDigest doit = MessageDigest.getInstance(algo);
+                doit.update(toByteArrayNoConversion(temp), 0, temp.length());
+                return SleepUtils.getScalar(doit.digest());
+             }
+             catch (NoSuchAlgorithmException ex)
+             {
+                i.getScriptEnvironment().flagError("&digest: no such algorithm: " + algo);
+             }
+          }
+
+          return SleepUtils.getEmptyScalar();
+       }
        else if (n.equals("&checksum"))
        {
           Scalar   s = BridgeUtilities.getScalar(l);
@@ -456,6 +518,7 @@
        byte        bdata[] = new byte[8]; 
        ByteBuffer  buffer  = ByteBuffer.wrap(bdata);
        int         read    = 0;
+       int         early, later;
 
        while (pattern != null)
        {
@@ -476,6 +539,42 @@
              }
              catch (Exception ex) { }
           }
+          else if (pattern.value == 'h' || pattern.value == 'H')
+          {
+             StringBuffer temps = new StringBuffer();
+
+             try
+             {
+                for (int z = 0; (z < pattern.count || pattern.count == -1); z++)
+                {
+                   read = in.read(bdata, 0, 1);
+
+                   if (read < 1) throw new EOFException();
+ 
+                   early = (buffer.get(0) & 0x00F0) >> 4;
+                   later = (buffer.get(0) & 0x000F);
+
+                   if (pattern.value == 'h')
+                   {
+                      temps.append(Integer.toHexString(later));
+                      temps.append(Integer.toHexString(early));
+                   }
+                   else
+                   {
+                      temps.append(Integer.toHexString(early));
+                      temps.append(Integer.toHexString(later));
+                   }
+                }
+             }
+             catch (Exception fex) 
+             { 
+                if (control != null) control.close();
+                temp.getArray().push(SleepUtils.getScalar(temps.toString()));       
+                return temp;
+             }
+ 
+             temp.getArray().push( SleepUtils.getScalar(temps.toString()) ); // reads in a full on string :)
+          }
           else if (pattern.value == 'z' || pattern.value == 'Z' || pattern.value == 'U' || pattern.value == 'u')
           {
              StringBuffer temps = new StringBuffer();
@@ -722,6 +821,37 @@
                 return;
              }
           }
+          else if (pattern.value == 'h' || pattern.value == 'H')
+          {
+             try
+             {
+                StringBuffer number = new StringBuffer("FF");
+                char[] tempchars = BridgeUtilities.getString(arguments, "").toCharArray();
+
+                for (int y = 0; y < tempchars.length; y += 2)
+                {
+                   if (pattern.value == 'H')
+                   {
+                      number.setCharAt(0, tempchars[y]);
+                      number.setCharAt(1, tempchars[y+1]);
+                   }
+                   else
+                   {
+                      number.setCharAt(0, tempchars[y+1]);
+                      number.setCharAt(1, tempchars[y]);
+                   }
+
+                   buffer.putInt(0, Integer.parseInt(number.toString(), 16));
+                   out.write(bdata, 3, 1);
+                }
+             }
+             catch (Exception ex)
+             {
+                ex.printStackTrace();
+                if (control != null) control.close();
+                return;
+             }
+          }
           else
           {
              for (int z = 0; z != pattern.count && !arguments.isEmpty(); z++)
@@ -929,7 +1059,7 @@
 
           for (int x = 0; x < data.length; x++)
           {
-             value.append((char)data[x]);
+             value.append((char)(data[x] & 0x00FF));
           }
 
           return SleepUtils.getScalar(value.toString());

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/src/sleep/runtime/SleepUtils.java	2006-09-15 23:31:29 UTC (rev 116)
@@ -500,6 +500,22 @@
       return temp;
    }
 
+   /** constructs a string scalar with value x interpreted as an array of unsigned bytes */
+   public static Scalar getScalar(byte[] x)
+   {
+      Scalar temp = new Scalar();
+      StringBuffer buff = new StringBuffer(x.length);
+      for (int y = 0; y < x.length; y++)
+      {
+         char append = (char)(x[y] & 0x00FF);
+         buff.append(append);
+      }
+
+      temp.setValue(new StringValue(buff.toString()));
+ 
+      return temp;
+   }
+
    /** returns a string scalar with value x */
    public static Scalar getScalar(String x)
    {

Added: sleep/tests/digest.sl
===================================================================
--- sleep/tests/digest.sl	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/tests/digest.sl	2006-09-15 23:31:29 UTC (rev 116)
@@ -0,0 +1,40 @@
+#
+# test the digest API
+#
+
+$REAL = '17bc99c1ea48937e2f702c7ef1c5025c'; # output of UNIX md5 command for test.jar
+
+# first test... digest an I/O handle :)
+
+$handle = openf("data/test.jar");
+$summer = digest($handle);
+readAll($handle); 
+$bytes  = digest($summer);
+
+$sum    = unpack("H*", $bytes)[0];
+
+println("(1) Digest value of test.jar is: " . $sum . " good? " . iff($sum eq $REAL, "yes", "no"));
+closef($handle);
+
+println("(2) Another test of repacked data: " . iff(pack("H", $sum) eq $bytes, "good", "broken"));
+
+# second test... checksumming raw data
+
+$handle = openf("data/test.jar");
+$data   = readb($handle, lof("data/test.jar")); # read in the entire file
+$sum    = unpack("H*", digest($data, "MD5"))[0];
+println("(3) Digest value of test.jar is: " . $sum . " good? " . iff($sum eq $REAL, "yes", "no"));
+closef($handle);
+
+# third test.. the kewlest test of them all...
+
+$sumfork = fork({
+   readb($source, lof("data/test.jar"));
+});
+
+$summer = digest($sumfork, ">MD5");
+writeb($sumfork, $data);
+closef($sumfork);
+wait($sumfork);
+println("Digest of written data is: " . unpack("H*", digest($summer))[0]);
+

Added: sleep/tests/output/digest.sl
===================================================================
--- sleep/tests/output/digest.sl	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/tests/output/digest.sl	2006-09-15 23:31:29 UTC (rev 116)
@@ -0,0 +1,4 @@
+(1) Digest value of test.jar is: 17bc99c1ea48937e2f702c7ef1c5025c good? yes
+(2) Another test of repacked data: good
+(3) Digest value of test.jar is: 17bc99c1ea48937e2f702c7ef1c5025c good? yes
+Digest of written data is: 17bc99c1ea48937e2f702c7ef1c5025c

Modified: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-15 23:31:29 UTC (rev 116)
@@ -19,7 +19,7 @@
 Trace: &println('8 => val: 8') at line 8
 9 => val: 9
 Trace: &println('9 => val: 9') at line 8
-Trace: &lambda(&closure2881682, $start => 50, $stop => 60) = &closure13389929 at line 22
+Trace: &lambda(&closure10481832, $start => 50, $stop => 60) = &closure7388808 at line 22
 Testing out range stuff: 0 => 50
 Trace: &println('Testing out range stuff: 0 => 50') at line 24
 Testing out range stuff: 1 => 51
@@ -41,7 +41,7 @@
 Testing out range stuff: 9 => 59
 Trace: &println('Testing out range stuff: 9 => 59') at line 24
 Trace: &this('$start $stop') at line 29
-Trace: &_range2(70, 80) = &closure11742932 at line 42
+Trace: &_range2(70, 80) = &closure15531527 at line 42
 My third test: 0 => 70
 Trace: &println('My third test: 0 => 70') at line 44
 My third test: 1 => 71

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/tests/output/trace.sl	2006-09-15 23:31:29 UTC (rev 116)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at d6b059 println: 'this is a test'] at line 6
+Trace: [java.io.PrintStream at 94257f println: 'this is a test'] at line 6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 7
 81.0
-Trace: [java.io.PrintStream at d6b059 println: 81.0] at line 7
+Trace: [java.io.PrintStream at 94257f println: 81.0] at line 7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at line 8
 243.0
 Trace: &println(243.0) at line 8
 testing again...
-Trace: [java.io.PrintStream at d6b059 println: 'testing again...'] at line 10
+Trace: [java.io.PrintStream at 94257f println: 'testing again...'] at line 10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at line 12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at line 12
 Warning: variable '$list' not declared at line 12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/tests/output/wrong.sl	2006-09-15 23:31:29 UTC (rev 116)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at line 6
 81.0
-Trace: [java.io.PrintStream at 94257f println: 81.0] at line 6
+Trace: [java.io.PrintStream at a4488 println: 81.0] at line 6
 Trace: &casti(1, 'z') = true at line 9
 true
-Trace: [java.io.PrintStream at 94257f println: true] at line 9
+Trace: [java.io.PrintStream at a4488 println: true] at line 9
 Trace: &casti(0, 'z') = false at line 10
 false
-Trace: [java.io.PrintStream at 94257f println: false] at line 10
+Trace: [java.io.PrintStream at a4488 println: false] at line 10
 Trace: &casti(1, 'd') = 1.0 at line 13
 1.0
-Trace: [java.io.PrintStream at 94257f println: 1.0] at line 13
+Trace: [java.io.PrintStream at a4488 println: 1.0] at line 13
 Trace: &casti(1, 'b') = 1 at line 16
 1
-Trace: [java.io.PrintStream at 94257f println: 1] at line 16
+Trace: [java.io.PrintStream at a4488 println: 1] at line 16
 Trace: &casti(100, 'f') = 100.0 at line 19
 100.0
-Trace: [java.io.PrintStream at 94257f println: 100.0] at line 19
+Trace: [java.io.PrintStream at a4488 println: 100.0] at line 19
 Trace: &casti('b', 'c') = b at line 22
 b
-Trace: [java.io.PrintStream at 94257f println: b] at line 22
+Trace: [java.io.PrintStream at a4488 println: b] at line 22
 Trace: &casti(63, 'i') = 63 at line 25
 63
-Trace: [java.io.PrintStream at 94257f println: 63] at line 25
+Trace: [java.io.PrintStream at a4488 println: 63] at line 25
 this is a string y0
-Trace: [java.io.PrintStream at 94257f println: 'this is a string y0'] at line 28
+Trace: [java.io.PrintStream at a4488 println: 'this is a string y0'] at line 28
 Trace: [new java.lang.StringBuilder: 'test'] = test at line 31
 test
-Trace: [java.io.PrintStream at 94257f println: test] at line 31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at f4bcf7 at line 34
+Trace: [java.io.PrintStream at a4488 println: test] at line 31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 1d98a at line 34
 abcd
-Trace: [java.io.PrintStream at 94257f println: [C at f4bcf7] at line 34
+Trace: [java.io.PrintStream at a4488 println: [C at 1d98a] at line 34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-15 02:33:38 UTC (rev 115)
+++ sleep/whatsnew.txt	2006-09-15 23:31:29 UTC (rev 116)
@@ -27,6 +27,15 @@
 
   The CRC32 and Adler32 algorithms are supported.  With an I/O handle specifying
   a > before the algorithm name indicates that written data should be checksummed.
+- added digest capability to sleep, the function is similar to checksum except
+  the function name is &digest.  The MD5 and SHA-1 algorithms are supported.
+  This function returns a string of bytes (can be converted to hex using 
+  unpack("H*", $digest_data")[0]).
+- added H/h to the binary format templates to allow byte data to be converted
+  to/from hex characters.  The H puts the high nybble first and the h puts the
+  low nybble first.
+- fixed a bug with &pack destroying the binary string thanks to Java's lack
+  of unsigned types.
 
 2.1-beta 4  (11 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Sat Sep 16 07:01:19 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 16 Sep 2006 07:01:19 +0200
Subject: [Sleep-svn] r117 - in sleep: . src/sleep/engine tests tests/output
Message-ID: <200609160501.k8G51JRZ032515@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-16 07:01:16 +0200 (Sat, 16 Sep 2006)
New Revision: 117

Added:
   sleep/tests/byteconvert.sl
   sleep/tests/output/byteconvert.sl
Modified:
   sleep/src/sleep/engine/ObjectUtilities.java
   sleep/whatsnew.txt
Log:
byte conversion...



Modified: sleep/src/sleep/engine/ObjectUtilities.java
===================================================================
--- sleep/src/sleep/engine/ObjectUtilities.java	2006-09-15 23:31:29 UTC (rev 116)
+++ sleep/src/sleep/engine/ObjectUtilities.java	2006-09-16 05:01:16 UTC (rev 117)
@@ -468,21 +468,33 @@
       if (value == null)
          return SleepUtils.getEmptyScalar();
 
-      if (value.getClass().isArray())
+      Class check = value.getClass();
+
+      if (check.isArray())
       {
-         Scalar array = SleepUtils.getArrayScalar();
-         for (int x = 0; x < Array.getLength(value); x++)
+         if (check.getComponentType() == Byte.TYPE || check.getComponentType() == BYTE_TYPE)
          {
-            array.getArray().push(BuildScalar(true, Array.get(value, x)));
+            return SleepUtils.getScalar((byte[])value);            
          }
+         else
+         {
+            Scalar array = SleepUtils.getArrayScalar();
+            for (int x = 0; x < Array.getLength(value); x++)
+            {
+               array.getArray().push(BuildScalar(true, Array.get(value, x)));
+            }
 
-         return array;
+            return array;
+         }
       }
 
-      Class check = value.getClass();
-
       if (primitives)
       {
+         if (check.isPrimitive()) 
+         { 
+            check = normalizePrimitive(check); /* just in case, shouldn't be needed typically */
+         }
+
          if (check == BOOLEAN_TYPE)
          {
             return SleepUtils.getScalar(  ((Boolean)value).booleanValue() ? 1 : 0 );

Added: sleep/tests/byteconvert.sl
===================================================================
--- sleep/tests/byteconvert.sl	2006-09-15 23:31:29 UTC (rev 116)
+++ sleep/tests/byteconvert.sl	2006-09-16 05:01:16 UTC (rev 117)
@@ -0,0 +1,17 @@
+#
+# ensure that byte[] arrays returned by Java functions are converted to sleep byte strings
+#
+
+debug(7);
+
+import java.security.MessageDigest;
+
+$data = readb(openf("data/test.jar"), lof("data/test.jar"));
+
+$summer = [MessageDigest getInstance: "MD5"];
+[$summer update: cast($data, "b")]; # to pass a string as a byte array it must be
+                                    # explicitly cast
+
+$bytes  = [$summer digest];
+
+println("The MD5 value of test.jar is: " . unpack("H*", $bytes)[0]);

Added: sleep/tests/output/byteconvert.sl
===================================================================
--- sleep/tests/output/byteconvert.sl	2006-09-15 23:31:29 UTC (rev 116)
+++ sleep/tests/output/byteconvert.sl	2006-09-16 05:01:16 UTC (rev 117)
@@ -0,0 +1,4 @@
+Warning: variable '$data' not declared at line 9
+Warning: variable '$summer' not declared at line 11
+Warning: variable '$bytes' not declared at line 15
+The MD5 value of test.jar is: 17bc99c1ea48937e2f702c7ef1c5025c

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-15 23:31:29 UTC (rev 116)
+++ sleep/whatsnew.txt	2006-09-16 05:01:16 UTC (rev 117)
@@ -36,6 +36,8 @@
   low nybble first.
 - fixed a bug with &pack destroying the binary string thanks to Java's lack
   of unsigned types.
+- When a Java byte array is returned by a HOES call, a sleep byte string will 
+  be created from this value.
 
 2.1-beta 4  (11 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Sat Sep 16 07:13:38 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 16 Sep 2006 07:13:38 +0200
Subject: [Sleep-svn] r118 - in sleep: src/sleep/engine/atoms tests/output
Message-ID: <200609160513.k8G5Dcok021289@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-16 07:13:38 +0200 (Sat, 16 Sep 2006)
New Revision: 118

Modified:
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/src/sleep/engine/atoms/ObjectNew.java
   sleep/tests/output/hoeswarning.sl
Log:
Better error messages for failed method/constructor resolution



Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-16 05:01:16 UTC (rev 117)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-16 05:13:38 UTC (rev 118)
@@ -243,7 +243,7 @@
       {
          if (!e.getCurrentFrame().isEmpty())
          {
-            e.getScriptInstance().fireWarning("there is no method " + name + " that takes " + e.getCurrentFrame().size() + " arguments in " + theClass, getLineNumber());
+            e.getScriptInstance().fireWarning("there is no method that matches " + name + "("+SleepUtils.describe(e.getCurrentFrame()) + ") in " + theClass.getName(), getLineNumber());
          }
          else
          {

Modified: sleep/src/sleep/engine/atoms/ObjectNew.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectNew.java	2006-09-16 05:01:16 UTC (rev 117)
+++ sleep/src/sleep/engine/atoms/ObjectNew.java	2006-09-16 05:13:38 UTC (rev 118)
@@ -103,7 +103,7 @@
          }
          else
          {
-            e.getScriptInstance().fireWarning("no " + e.getCurrentFrame().size() + " argument constructor exists for class " + name.getName(), getLineNumber());
+            e.getScriptInstance().fireWarning("no constructor matching "+name.getName()+"(" + SleepUtils.describe(e.getCurrentFrame()) + ")", getLineNumber());
          }
       }
       catch (InvocationTargetException ite)

Modified: sleep/tests/output/hoeswarning.sl
===================================================================
--- sleep/tests/output/hoeswarning.sl	2006-09-16 05:01:16 UTC (rev 117)
+++ sleep/tests/output/hoeswarning.sl	2006-09-16 05:13:38 UTC (rev 118)
@@ -1,6 +1,6 @@
 Warning: java.lang.NumberFormatException: For input string: "4782378478324474fjjsdfjsdjkfjk3" at line 4
 Trouble converting long: java.lang.NumberFormatException: For input string: "4782378478324474fjjsdfjsdjkfjk3"
 Warning: no field/method named tHiS_FiElD_DoES_nOT_EXIsT in class java.lang.Long at line 15
-Warning: there is no method valueOf that takes 8 arguments in class java.lang.Long at line 21
-Warning: no 0 argument constructor exists for class java.util.StringTokenizer at line 27
+Warning: there is no method that matches valueOf(3, 4, 5, 6, 7, 8, 9, 10) in java.lang.Long at line 21
+Warning: no constructor matching java.util.StringTokenizer() at line 27
 Warning: unable to instantiate abstract class javax.swing.AbstractListModel at line 33



From rsmudge at mail.berlios.de  Sat Sep 16 16:39:21 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 16 Sep 2006 16:39:21 +0200
Subject: [Sleep-svn] r119 - in sleep: . src/sleep/bridges/io tests
	tests/output
Message-ID: <200609161439.k8GEdLCL029705@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-16 16:39:21 +0200 (Sat, 16 Sep 2006)
New Revision: 119

Added:
   sleep/tests/forkdl.sl
   sleep/tests/output/forkdl.sl
Modified:
   sleep/src/sleep/bridges/io/IOObject.java
   sleep/whatsnew.txt
Log:
fixed a silly deadlock bug with fork



Modified: sleep/src/sleep/bridges/io/IOObject.java
===================================================================
--- sleep/src/sleep/bridges/io/IOObject.java	2006-09-16 05:13:38 UTC (rev 118)
+++ sleep/src/sleep/bridges/io/IOObject.java	2006-09-16 14:39:21 UTC (rev 119)
@@ -156,9 +156,13 @@
    {
       try
       {
-         in.notifyAll();  // done to prevent a deadlock, trust me it works
-         out.notifyAll(); // done to prevent a deadlock, trust me it works
-
+         if (in != null) { in.notifyAll(); } // done to prevent a deadlock, trust me it works
+         if (out != null) { out.notifyAll(); } // done to prevent a deadlock, trust me it works
+      }
+      catch (Exception ex) { } /* we might get an illegal monitor state type exception if we don't own
+                                  the lock from this thread... in that case we move on with our lives */
+      try
+      {
          if (reader != null)
            reader.close();
 
@@ -176,7 +180,6 @@
       }
       catch (Exception ex)
       {
-
       }
       finally
       {

Added: sleep/tests/forkdl.sl
===================================================================
--- sleep/tests/forkdl.sl	2006-09-16 05:13:38 UTC (rev 118)
+++ sleep/tests/forkdl.sl	2006-09-16 14:39:21 UTC (rev 119)
@@ -0,0 +1,19 @@
+#
+# reproduce a deadlock problem with fork...
+#
+
+$REAL = 990741747; # output of UNIX crc32 command for test.jar
+
+# third test.. the kewlest test of them all...
+
+$sumfork = fork({
+   $summer = checksum($source);
+   readAll($source);
+   return checksum($summer);
+});
+
+writeb($sumfork, readb(openf("data/test.jar"), lof("data/test.jar")));
+closef($sumfork);
+
+println("Checksum of written data is: " . wait($sumfork));
+

Added: sleep/tests/output/forkdl.sl
===================================================================
--- sleep/tests/output/forkdl.sl	2006-09-16 05:13:38 UTC (rev 118)
+++ sleep/tests/output/forkdl.sl	2006-09-16 14:39:21 UTC (rev 119)
@@ -0,0 +1 @@
+Checksum of written data is: 990741747

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-16 05:13:38 UTC (rev 118)
+++ sleep/whatsnew.txt	2006-09-16 14:39:21 UTC (rev 119)
@@ -38,6 +38,8 @@
   of unsigned types.
 - When a Java byte array is returned by a HOES call, a sleep byte string will 
   be created from this value.
+- fixed a deadlock issue with fork/wait with close being called on fork while
+  in the middle of a read.
 
 2.1-beta 4  (11 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Sat Sep 16 17:12:28 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 16 Sep 2006 17:12:28 +0200
Subject: [Sleep-svn] r120 - in sleep: . src/sleep/bridges
	src/sleep/bridges/io
Message-ID: <200609161512.k8GFCSac032088@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-16 17:12:28 +0200 (Sat, 16 Sep 2006)
New Revision: 120

Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/bridges/io/IOObject.java
   sleep/whatsnew.txt
Log:
Fun...



Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2006-09-16 14:39:21 UTC (rev 119)
+++ sleep/src/sleep/bridges/BasicIO.java	2006-09-16 15:12:28 UTC (rev 120)
@@ -401,7 +401,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject a = chooseSource(l, 1);
+          IOObject a = chooseSource(l, 1, i);
     
           String temp = a.readLine();
 
@@ -418,7 +418,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject a = chooseSource(l, 1);
+          IOObject a = chooseSource(l, 1, i);
 
           Scalar ar = SleepUtils.getArrayScalar();
           
@@ -436,7 +436,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject a = chooseSource(l, 2);
+          IOObject a = chooseSource(l, 2, i);
 
           String temp = BridgeUtilities.getString(l, "");
           a.printLine(temp);
@@ -449,7 +449,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance inst, Stack l)
        {
-          IOObject a       = chooseSource(l, 2);
+          IOObject a       = chooseSource(l, 2, inst);
 
           Iterator i = BridgeUtilities.getIterator(l, inst);
           while (i.hasNext())
@@ -465,7 +465,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject a = chooseSource(l, 2);
+          IOObject a = chooseSource(l, 2, i);
 
           String temp = BridgeUtilities.getString(l, "");
           a.print(temp);
@@ -479,14 +479,14 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject a = chooseSource(l, 1);
+          IOObject a = chooseSource(l, 1, i);
           a.sendEOF();
 
           return SleepUtils.getEmptyScalar();
        }
     }
 
-    private static IOObject chooseSource(Stack l, int args)
+    private static IOObject chooseSource(Stack l, int args, ScriptInstance i)
     {
        IOObject a;
 
@@ -496,7 +496,7 @@
        }
        else
        {
-          a = IOObject.getConsole();
+          a = IOObject.getConsole(i.getScriptEnvironment());
        }  
 
        return a;
@@ -928,7 +928,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject        a = chooseSource(l, 2);
+          IOObject        a = chooseSource(l, 2, i);
           String    pattern = BridgeUtilities.getString(l, "");
 
           return ReadFormatted(pattern, a.getReader(), i.getScriptEnvironment(), a);
@@ -939,7 +939,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject        a = chooseSource(l, 3);
+          IOObject        a = chooseSource(l, 3, i);
           String    pattern = BridgeUtilities.getString(l, "");
 
           WriteFormatted(pattern, a.getWriter(), l, a);
@@ -951,7 +951,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject        a = chooseSource(l, 2);
+          IOObject        a = chooseSource(l, 2, i);
           a.getInputBuffer().mark(BridgeUtilities.getInt(l, 1024 * 10 * 10));
 
           return SleepUtils.getEmptyScalar();
@@ -964,7 +964,7 @@
        {
           try
           {
-             IOObject        a = chooseSource(l, 1);
+             IOObject        a = chooseSource(l, 1, i);
 
              if (l.isEmpty())
              {
@@ -1001,7 +1001,7 @@
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
           try {
-          IOObject        a = chooseSource(l, 2);
+          IOObject        a = chooseSource(l, 2, i);
           a.getInputBuffer().skip(BridgeUtilities.getLong(l, 0));
           } catch (Exception ex) { }
 
@@ -1014,7 +1014,7 @@
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
           try {
-          IOObject        a = chooseSource(l, 1);
+          IOObject        a = chooseSource(l, 1, i);
           a.getInputBuffer().reset();
           } catch (Exception ex) { }
 
@@ -1070,7 +1070,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject     a = chooseSource(l, 2);
+          IOObject     a = chooseSource(l, 2, i);
           String    data = BridgeUtilities.getString(l, "");
 
           try
@@ -1095,7 +1095,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject         a = chooseSource(l, 2);
+          IOObject         a = chooseSource(l, 2, i);
           int             to = BridgeUtilities.getInt(l, 1);
 
           StringBuffer temp = new StringBuffer(to);
@@ -1121,7 +1121,7 @@
     {
        public Scalar evaluate(String n, ScriptInstance i, Stack l)
        {
-          IOObject     a = chooseSource(l, 2);
+          IOObject     a = chooseSource(l, 2, i);
           SleepClosure b = BridgeUtilities.getFunction(l, i);
 
           Thread fred = new Thread(new CallbackReader(a, i, b, BridgeUtilities.getInt(l, 0)));

Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2006-09-16 14:39:21 UTC (rev 119)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2006-09-16 15:12:28 UTC (rev 120)
@@ -275,7 +275,7 @@
           {
              if (type.charAt(0) == 'c')
              {
-                return SleepUtils.getScalar(value.toString().toCharArray());
+                return SleepUtils.getScalar((Object)value.toString().toCharArray());
              }             
              else if (type.charAt(0) == 'b')
              {
@@ -289,7 +289,7 @@
                    tempb[x] = (byte)tempc[x];
                 }
 
-                return SleepUtils.getScalar(tempb);
+                return SleepUtils.getScalar((Object)tempb);
              }             
 
              return SleepUtils.getEmptyScalar();

Modified: sleep/src/sleep/bridges/io/IOObject.java
===================================================================
--- sleep/src/sleep/bridges/io/IOObject.java	2006-09-16 14:39:21 UTC (rev 119)
+++ sleep/src/sleep/bridges/io/IOObject.java	2006-09-16 15:12:28 UTC (rev 120)
@@ -22,8 +22,6 @@
 
 public class IOObject
 {
-   private static IOObject console = null;
-
    /* input pipeline */ 
 
    protected DataInputStream     readerb = null; /* used to support the binary read/write stuffz */
@@ -94,25 +92,20 @@
       token = t;
    }
 
-   /** this method is no longer the preferred way for obtaining the console IOObject */
-   public static IOObject getConsole()
-   {
-      IOObject temp = new IOObject();
-      temp.openRead(System.in);
-      temp.openWrite(System.out);
-
-      return temp;
-   }
-
-   /** returns an IOObject that represents stdin/stdout */
+   /** returns an IOObject that represents stdin/stdout to Sleep's I/O API.  To set a script's console
+       object install an IOObject into a script environment under the variable name %console% */
    public static IOObject getConsole(ScriptEnvironment environment)
    {
+      IOObject console = (IOObject)environment.getEnvironment().get("%console%");
+
       if (console == null)
       {
          console = new IOObject();
          console.openRead(System.in);
          console.openWrite(System.out);
+         environment.getEnvironment().put("%console%", console);
       }
+
       return console;
    }
 

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-16 14:39:21 UTC (rev 119)
+++ sleep/whatsnew.txt	2006-09-16 15:12:28 UTC (rev 120)
@@ -40,6 +40,9 @@
   be created from this value.
 - fixed a deadlock issue with fork/wait with close being called on fork while
   in the middle of a read.
+- sleep I/O now uses the IOObject stored in the environment under %consol% as
+  the source for stdin/stdout (this is set to System.in and System.out by 
+  default).
 
 2.1-beta 4  (11 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Mon Sep 18 00:14:49 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 18 Sep 2006 00:14:49 +0200
Subject: [Sleep-svn] r121 - in sleep: . docs src/sleep/runtime
Message-ID: <200609172214.k8HMEnBe018679@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-18 00:14:48 +0200 (Mon, 18 Sep 2006)
New Revision: 121

Modified:
   sleep/docs/sleeplang.html
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/whatsnew.txt
Log:
Sleep 2.1-b5 release



Modified: sleep/docs/sleeplang.html
===================================================================
--- sleep/docs/sleeplang.html	2006-09-16 15:12:28 UTC (rev 120)
+++ sleep/docs/sleeplang.html	2006-09-17 22:14:48 UTC (rev 121)
@@ -2184,6 +2184,21 @@
  </tr>
  <tr>
   <td>$</td>
+  <td>checksum($handle, ">algorithm")</td>
+  <td>setups the specified handle so that all reads (or if > is specified in the algorithm, writes) are checksummed using the specified algorithm.  This function returns a $checksum object that can be used to obtain the final digest value.  Valid algorithms are Adler32 and CRC32</td>
+ </tr>
+ <tr>
+  <td>$</td>
+  <td>checksum($checksum)</td>
+  <td>returns (as a scalar long) the checksum of the handle being checksummed with $checksum</td>
+ </tr>
+ <tr>
+  <td>$</td>
+  <td>checksum("string", "algorithm")</td>
+  <td>returns (as a scalar long) the checksum of the specified byte string using the specified algorithm</td>
+ </tr>
+ <tr>
+  <td>$</td>
   <td>cos($scalar)</td>
   <td>returns the cosine value of angle $scalar (radians)</td>
  </tr>
@@ -2194,6 +2209,21 @@
  </tr>
  <tr>
   <td>$</td>
+  <td>digest($handle, ">algorithm")</td>
+  <td>setups the specified handle so that all reads (or if > is specified in the algorithm, writes) are digested using the specified algorithm.  This function returns a $digest object that can be used to obtain the final digest value.  Valid algorithms are MD5 and SHA-1</td>
+ </tr>
+ <tr>
+  <td>$</td>
+  <td>digest($digest)</td>
+  <td>returns (as bytes) the digest of the handle being digested with $digest</td>
+ </tr>
+ <tr>
+  <td>$</td>
+  <td>digest("string", "algorithm")</td>
+  <td>returns (as bytes) the digest of the specified byte string using the specified algorithm</td>
+ </tr>
+ <tr>
+  <td>$</td>
   <td>double($scalar)</td>
   <td>returns a copy of $scalar as a double scalar</td>
  </tr>
@@ -2417,6 +2447,12 @@
  </tr>
  <tr>
   <td>$</td>
+  <td>casti($scalar, 't')</td>
+  <td>casts $scalar into an object scalar representing a native java value of type t where t can be b = byte, c = char, d = 
+      double, f = float, h = short, i = int, l = long, z = boolean.</td>
+ </tr>
+ <tr>
+  <td>$</td>
   <td>debug(level)</td>
   <td>explicitly enables the specified debug level for this script: 0 - no debugging; 1 - show only critical errors (default); 2 - show all warnings; 4 - show first time use of non-declared variables; 8 - trace all function calls.  any of the levels can be |'d together.</td>
  </tr>
@@ -3192,6 +3228,16 @@
   <td>float (uses IEEE 754 floating-point "single format" bit layout)</td>
  </tr>
  <tr>
+  <td>h</td>
+  <td>1</td>
+  <td>a hex byte (low nybble first)</td>
+ </tr>
+ <tr>
+  <td>H</td>
+  <td>1</td>
+  <td>a hex byte (high nybble first)</td>
+ </tr>
+ <tr>
   <td>i</td>
   <td>4</td>
   <td>integer</td>

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2006-09-16 15:12:28 UTC (rev 120)
+++ sleep/src/sleep/runtime/SleepUtils.java	2006-09-17 22:14:48 UTC (rev 121)
@@ -49,7 +49,7 @@
 public class SleepUtils
 {
    /** A date stamp of this Sleep release in YYYYMMDD format */
-   public static final int    SLEEP_RELEASE = 20060911;
+   public static final int    SLEEP_RELEASE = 20060917;
 
    /** A string description of this Sleep release */
    public static final String SLEEP_VERSION = "Sleep 2.1";

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-16 15:12:28 UTC (rev 120)
+++ sleep/whatsnew.txt	2006-09-17 22:14:48 UTC (rev 121)
@@ -1,4 +1,4 @@
-2.1-beta 5
+2.1-beta 5  (17 Sept 06)
 ===========
 - fixed a bug with import [path] from: [jar] not working when a package.class
   combination was specified.
@@ -40,7 +40,7 @@
   be created from this value.
 - fixed a deadlock issue with fork/wait with close being called on fork while
   in the middle of a read.
-- sleep I/O now uses the IOObject stored in the environment under %consol% as
+- sleep I/O now uses the IOObject stored in the environment under %console% as
   the source for stdin/stdout (this is set to System.in and System.out by 
   default).
 



From rsmudge at mail.berlios.de  Mon Sep 18 00:40:49 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 18 Sep 2006 00:40:49 +0200
Subject: [Sleep-svn] r122 - sleep
Message-ID: <200609172240.k8HMenSo014671@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-18 00:40:48 +0200 (Mon, 18 Sep 2006)
New Revision: 122

Modified:
   sleep/whatsnew.txt
Log:
typo in the whatsnew file, doh!@



Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-17 22:14:48 UTC (rev 121)
+++ sleep/whatsnew.txt	2006-09-17 22:40:48 UTC (rev 122)
@@ -30,7 +30,7 @@
 - added digest capability to sleep, the function is similar to checksum except
   the function name is &digest.  The MD5 and SHA-1 algorithms are supported.
   This function returns a string of bytes (can be converted to hex using 
-  unpack("H*", $digest_data")[0]).
+  unpack("H*", $digest_data)[0]).
 - added H/h to the binary format templates to allow byte data to be converted
   to/from hex characters.  The H puts the high nybble first and the h puts the
   low nybble first.



From rsmudge at mail.berlios.de  Mon Sep 18 21:08:16 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Mon, 18 Sep 2006 21:08:16 +0200
Subject: [Sleep-svn] r123 - in sleep: . src/sleep/bridges
	src/sleep/engine/atoms
Message-ID: <200609181908.k8IJ8GRB030235@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-18 21:08:16 +0200 (Mon, 18 Sep 2006)
New Revision: 123

Modified:
   sleep/build.xml
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/engine/atoms/Call.java
   sleep/src/sleep/engine/atoms/ObjectAccess.java
   sleep/src/sleep/engine/atoms/ObjectNew.java
   sleep/whatsnew.txt
Log:
named parameters and improvements to tracing.



Modified: sleep/build.xml
===================================================================
--- sleep/build.xml	2006-09-17 22:40:48 UTC (rev 122)
+++ sleep/build.xml	2006-09-18 19:08:16 UTC (rev 123)
@@ -37,6 +37,7 @@
            <include name="sleep/console/ConsoleImplementation.java" />
            <include name="sleep/console/ConsoleProxy.java" />
            <include name="sleep/engine/Block.java" />
+           <include name="sleep/engine/ObjectUtilities.java" />
            <include name="sleep/engine/atoms/Check.java" />
            <include name="sleep/error/*.java" />
            <include name="sleep/interfaces/*.java" />

Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2006-09-17 22:40:48 UTC (rev 122)
+++ sleep/src/sleep/bridges/SleepClosure.java	2006-09-18 19:08:16 UTC (rev 123)
@@ -25,6 +25,7 @@
 import java.io.*;
 
 import sleep.engine.*;
+import sleep.engine.types.*;
 import sleep.interfaces.*;
 import sleep.runtime.*;
 
@@ -174,8 +175,26 @@
           int name = 1;
           while (!locals.isEmpty())
           {
-             vars.setScalarLevel("$"+name, (Scalar)locals.pop(), localLevel);
-             name++;
+             Scalar lvar = (Scalar)locals.pop();
+
+             if (lvar.getValue() != null && lvar.getValue().getClass() == ObjectValue.class && lvar.getValue().objectValue() != null && lvar.getValue().objectValue().getClass() == KeyValuePair.class)
+             {
+                KeyValuePair kvp = (KeyValuePair)lvar.getValue().objectValue();
+
+                if (kvp.getKey().toString().charAt(0) != '$')
+                {
+                   throw new IllegalArgumentException("unreachable named parameter: " + kvp.getKey());
+                }
+                else
+                {
+                   vars.setScalarLevel(kvp.getKey().toString(), kvp.getValue(), localLevel);
+                }
+             } 
+             else
+             {
+                vars.setScalarLevel("$"+name, lvar, localLevel);
+                name++;
+             }
           }
 
           vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(name, localLevel)), localLevel);

Modified: sleep/src/sleep/engine/atoms/Call.java
===================================================================
--- sleep/src/sleep/engine/atoms/Call.java	2006-09-17 22:40:48 UTC (rev 122)
+++ sleep/src/sleep/engine/atoms/Call.java	2006-09-18 19:08:16 UTC (rev 123)
@@ -60,16 +60,24 @@
          {
              String args = SleepUtils.describe(e.getCurrentFrame());
 
-             temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
-             e.clearReturn();
-             
-             if (SleepUtils.isEmptyScalar(temp))
+             try
              {
-                e.getScriptInstance().fireWarning(function + "(" + args + ")", getLineNumber(), true);
+                temp = callme.evaluate(function, e.getScriptInstance(), e.getCurrentFrame());
+                e.clearReturn();
+              
+                if (SleepUtils.isEmptyScalar(temp))
+                {
+                   e.getScriptInstance().fireWarning(function + "(" + args + ")", getLineNumber(), true);
+                }
+                else
+                {
+                   e.getScriptInstance().fireWarning(function + "(" + args + ") = " + SleepUtils.describe(temp), getLineNumber(), true);
+                }
              }
-             else
+             catch (RuntimeException rex)
              {
-                e.getScriptInstance().fireWarning(function + "(" + args + ") = " + SleepUtils.describe(temp), getLineNumber(), true);
+                e.getScriptInstance().fireWarning(function + "(" + args + ") - FAILED!", getLineNumber(), true);
+                throw(rex);
              }
          }
          else

Modified: sleep/src/sleep/engine/atoms/ObjectAccess.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-17 22:40:48 UTC (rev 122)
+++ sleep/src/sleep/engine/atoms/ObjectAccess.java	2006-09-18 19:08:16 UTC (rev 123)
@@ -99,11 +99,9 @@
          {
             String args = SleepUtils.describe(e.getCurrentFrame());
 
-            result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
-
             /* construct the actual trace message */
 
-            StringBuffer trace = new StringBuffer("[&closure");
+            StringBuffer trace = new StringBuffer("[" + SleepUtils.describe(scalar));
            
             if (name != null && name.length() > 0)
             {
@@ -119,12 +117,23 @@
                trace.append("]");
             }
 
-            if (!SleepUtils.isEmptyScalar(result))
+            try
             {
-               trace.append(" = " + SleepUtils.describe(result));
+               result = func.evaluate(name, e.getScriptInstance(), e.getCurrentFrame());
+
+               if (!SleepUtils.isEmptyScalar(result))
+               {
+                  trace.append(" = " + SleepUtils.describe(result));
+               }
+
+               e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
             }
-
-            e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
+            catch (RuntimeException rex)
+            {
+               trace.append(" - FAILED!");
+               e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
+               throw(rex);
+            }
          }
          else
          {
@@ -172,7 +181,6 @@
                if (args.length() > 0) { args = ": " + args; }
 
                parameters = ObjectUtilities.buildArgumentArray(theMethod.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-               result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
 
                /* construct the actual trace message */
 
@@ -187,12 +195,23 @@
                   trace.append(SleepUtils.describe(scalar) + " " + name + args + "]");
                }
 
-               if (!SleepUtils.isEmptyScalar(result))
+               try
                {
-                  trace.append(" = " + SleepUtils.describe(result));
+                  result = ObjectUtilities.BuildScalar(true, theMethod.invoke(accessMe, parameters));
+
+                  if (!SleepUtils.isEmptyScalar(result))
+                  {
+                     trace.append(" = " + SleepUtils.describe(result));
+                  }
+
+                  e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
                }
-
-               e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
+               catch (RuntimeException rex)
+               {
+                  trace.append(" - FAILED!");
+                  e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true); 
+                  throw(rex);
+               }
             }
             else
             {

Modified: sleep/src/sleep/engine/atoms/ObjectNew.java
===================================================================
--- sleep/src/sleep/engine/atoms/ObjectNew.java	2006-09-17 22:40:48 UTC (rev 122)
+++ sleep/src/sleep/engine/atoms/ObjectNew.java	2006-09-18 19:08:16 UTC (rev 123)
@@ -77,7 +77,6 @@
                String args = SleepUtils.describe(e.getCurrentFrame());
 
                parameters = ObjectUtilities.buildArgumentArray(theConstructor.getParameterTypes(), e.getCurrentFrame(), e.getScriptInstance());
-               result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
 
                StringBuffer trace = new StringBuffer("[new " + name.getName());
 
@@ -88,12 +87,23 @@
 
                trace.append("]");
 
-               if (!SleepUtils.isEmptyScalar(result))
+               try
                {
-                  trace.append(" = " + SleepUtils.describe(result));
+                  result = ObjectUtilities.BuildScalar(false, theConstructor.newInstance(parameters));
+
+                  if (!SleepUtils.isEmptyScalar(result))
+                  {
+                     trace.append(" = " + SleepUtils.describe(result));
+                  }
+
+                  e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
                }
-
-               e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
+               catch (RuntimeException rex)
+               {
+                  trace.append(" - FAILED!");
+                  e.getScriptInstance().fireWarning(trace.toString(), getLineNumber(), true);
+                  throw(rex);
+               }
             }
             else
             {

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-17 22:40:48 UTC (rev 122)
+++ sleep/whatsnew.txt	2006-09-18 19:08:16 UTC (rev 123)
@@ -1,3 +1,12 @@
+2.1-beta 6 
+===========
+- added named parameters for Sleep closures.  When a $key => value argument is
+  passed to a sleep closure the value will be installed into the local scope of
+  the function as variable $key.  This breaks the old behavior which was to 
+  convert the key/value pair into a string i.e. $key=value
+- improved function call traceing to detect when a function call failed and to
+  indicate that such an event occured.
+
 2.1-beta 5  (17 Sept 06)
 ===========
 - fixed a bug with import [path] from: [jar] not working when a package.class



From rsmudge at mail.berlios.de  Sun Sep 24 20:13:22 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sun, 24 Sep 2006 20:13:22 +0200
Subject: [Sleep-svn] r124 - in sleep: . src/sleep/bridges src/sleep/engine
	src/sleep/parser src/sleep/runtime tests tests/output
Message-ID: <200609241813.k8OIDMdO024547@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-24 20:13:22 +0200 (Sun, 24 Sep 2006)
New Revision: 124

Added:
   sleep/tests/nparams.sl
   sleep/tests/output/nparams.sl
   sleep/tests/output/pep255.sl
   sleep/tests/pep255.sl
Modified:
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/engine/GeneratedSteps.java
   sleep/src/sleep/engine/Step.java
   sleep/src/sleep/parser/CodeGenerator.java
   sleep/src/sleep/runtime/ScriptVariables.java
   sleep/tests/cor_return.sl
   sleep/whatsnew.txt
Log:
Recursive coroutines!



Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/src/sleep/bridges/SleepClosure.java	2006-09-24 18:13:22 UTC (rev 124)
@@ -73,7 +73,7 @@
     Block                code;
 
     /** the owning script associated with this sleep closure */
-    ScriptInstance      owner; 
+    ScriptInstance      owner;
 
     /** the saved context of this closure */
     Stack             context;
@@ -81,6 +81,27 @@
     /** the meta data for this closure context */
     HashMap          metadata; 
 
+    /** saves the top level context */
+    private void saveToplevelContext(Stack _context, Variable localLevel)
+    {
+       if (!_context.isEmpty())
+       {
+          _context.push(localLevel); /* push the local vars on to the top of the context stack,
+                                        this better be popped before use!!! */
+          context.push(_context);
+       }
+    }
+
+    /** returns the top most context stack... */
+    private Stack getToplevelContext()
+    {
+       if (context.isEmpty())
+       {
+          return new Stack();
+       }
+       return (Stack)context.pop();
+    }
+
     public String toString()
     {
        return "&closure" + hashCode();
@@ -155,16 +176,27 @@
        ScriptVariables   vars = si.getScriptVariables();
        ScriptEnvironment env  = si.getScriptEnvironment();
 
+       Variable          localLevel;
+
        Scalar temp; // return value of subroutine.
 
        synchronized (vars)
        {
-          env.loadContext(context, metadata);
+          Stack toplevel = getToplevelContext();
+          env.loadContext(toplevel, metadata);
 
           vars.pushClosureLevel(this);
-          vars.pushLocalLevel();
 
-          Variable localLevel = vars.getLocalVariables();
+          if (toplevel.isEmpty()) /* a normal closure call */
+          {
+             vars.pushLocalLevel();
+             localLevel = vars.getLocalVariables();
+          }
+          else /* restoring from a coroutine */
+          {
+             localLevel = (Variable)toplevel.pop();
+             vars.pushLocalLevel(localLevel);
+          }
 
           vars.setScalarLevel("$0", SleepUtils.getScalar(message), localLevel);
 
@@ -202,7 +234,7 @@
           //
           // call the function, save the scalar that was returned. 
           //
-          if (context.isEmpty())
+          if (toplevel.isEmpty())
           {
              temp = code.evaluate(env);
           }
@@ -211,7 +243,7 @@
              temp = env.evaluateOldContext();
           }
 
-          context = env.saveContext();
+          saveToplevelContext(env.saveContext(), localLevel);
 
           vars.popLocalLevel();
           vars.popClosureLevel();

Modified: sleep/src/sleep/engine/GeneratedSteps.java
===================================================================
--- sleep/src/sleep/engine/GeneratedSteps.java	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/src/sleep/engine/GeneratedSteps.java	2006-09-24 18:13:22 UTC (rev 124)
@@ -46,6 +46,12 @@
        return temp;
     }
 
+    public static Step NullOperation()
+    {
+       Step temp = new Step();
+       return temp;
+    }
+
     public static Step IteratorCreate(String key, String value)
     {
        return new Iterate(key, value, Iterate.ITERATOR_CREATE);

Modified: sleep/src/sleep/engine/Step.java
===================================================================
--- sleep/src/sleep/engine/Step.java	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/src/sleep/engine/Step.java	2006-09-24 18:13:22 UTC (rev 124)
@@ -30,7 +30,7 @@
 </pre> */
 
 
-public abstract class Step implements Serializable
+public class Step implements Serializable
 {
    /** the script line number that this step was generated from */
    protected int  line;
@@ -57,6 +57,9 @@
    }
 
    /** evaluate this atomic step. */
-   public abstract Scalar evaluate(ScriptEnvironment e);
+   public Scalar evaluate(ScriptEnvironment e) 
+   {
+      return SleepUtils.getEmptyScalar();
+   }
 }
 

Modified: sleep/src/sleep/parser/CodeGenerator.java
===================================================================
--- sleep/src/sleep/parser/CodeGenerator.java	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/src/sleep/parser/CodeGenerator.java	2006-09-24 18:13:22 UTC (rev 124)
@@ -1058,6 +1058,15 @@
            {
               atom = GeneratedSteps.Return(ScriptEnvironment.FLOW_CONTROL_YIELD);
               add(atom, tokens[0]);
+
+              /* for some reason, yield breaks in certain cases if a yield happens
+                 at the end of a block and no other steps come after it.  this has
+                 only reared its head once I started allowing recursive coroutines
+                 to combat the problem I've opted to introduce a null operation
+                 after each yield, this fixes the problem.  hopefully it doesn't
+                 show itself in some other way in the future.  :~( *cry* */
+              atom = GeneratedSteps.NullOperation();
+              add(atom, tokens[0]);
            }
            else
            {

Modified: sleep/src/sleep/runtime/ScriptVariables.java
===================================================================
--- sleep/src/sleep/runtime/ScriptVariables.java	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/src/sleep/runtime/ScriptVariables.java	2006-09-24 18:13:22 UTC (rev 124)
@@ -207,6 +207,12 @@
        closure.removeFirst();
     }
 
+    /** makes the specified variable container active for the local scope.  once the code that is using this has finished, it really should be popped. */
+    public void pushLocalLevel(Variable localVariables)
+    {
+       locals.addFirst(localVariables);
+    }
+
     /** starts a new local variable scope.  once the code that is using this has finished, it should be popped */
     public void pushLocalLevel()
     {

Modified: sleep/tests/cor_return.sl
===================================================================
--- sleep/tests/cor_return.sl	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/tests/cor_return.sl	2006-09-24 18:13:22 UTC (rev 124)
@@ -15,7 +15,9 @@
 
    yield 3;
   
-   yield 4;
+   return 4; # this last return is required, if this was a yield we would resume execution of this
+             # coroutine after this statement which would cause the sub to immediately return an
+             # implied $null.
 }
 
 println("Test 1: ");
@@ -35,10 +37,10 @@
 println(a());
 println(a());
 println(a("boogidy boogidy"));
-println(a());
 
 println(a());
 println(a());
 println(a());
 println(a());
+println(a());
 

Added: sleep/tests/nparams.sl
===================================================================
--- sleep/tests/nparams.sl	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/tests/nparams.sl	2006-09-24 18:13:22 UTC (rev 124)
@@ -0,0 +1,56 @@
+#
+# a test of named parameters... fun eh?!?
+#
+
+debug(15);
+
+sub test1
+{
+   local('$test');
+   println("test1: $test");
+}
+
+test1($test => "success!");
+test1();
+
+sub test2
+{
+   println("test2: $test");
+}
+
+test2($test => "yes, another one");
+test2();
+
+sub test3
+{
+   this('$test');
+   println("test3: $test");
+   $test = ':)';
+}
+
+test3($test => 'eh?!?');
+test3(); # should print nothing because $test when it was set was in the local scope, higher priority over the this scope
+test3(); # should print a smiley since $test would have been in the this scope at this time
+
+sub test4
+{
+   local('$count $var');
+
+   foreach $count => $var (@_)
+   {
+      println("$[3]count = $var");
+   }
+
+   println("a: $a and b: $b and c: $c");
+}
+
+test4("a", "b", $a => "apple", "c", $b => "boy", "d", $c => "cat");
+
+sub test5
+{
+   println("Test 5 has been called, executing action:");
+   [$action];
+}
+
+test5($action => { println("The passed in closure has been called"); });
+test5(action => { println("This will never happen! muah!"); });

Added: sleep/tests/output/nparams.sl
===================================================================
--- sleep/tests/output/nparams.sl	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/tests/output/nparams.sl	2006-09-24 18:13:22 UTC (rev 124)
@@ -0,0 +1,47 @@
+Trace: &local('$test') at line 9
+test1: success!
+Trace: &println('test1: success!') at line 10
+Trace: &test1($test => 'success!') at line 13
+Trace: &local('$test') at line 9
+test1: 
+Trace: &println('test1: ') at line 10
+Trace: &test1() at line 14
+test2: yes, another one
+Trace: &println('test2: yes, another one') at line 18
+Trace: &test2($test => 'yes, another one') at line 21
+Warning: variable '$test' not declared at line 18
+test2: 
+Trace: &println('test2: ') at line 18
+Trace: &test2() at line 22
+Trace: &this('$test') at line 26
+test3: eh?!?
+Trace: &println('test3: eh?!?') at line 27
+Trace: &test3($test => 'eh?!?') at line 31
+Trace: &this('$test') at line 26
+test3: 
+Trace: &println('test3: ') at line 27
+Trace: &test3() at line 32
+Trace: &this('$test') at line 26
+test3: :)
+Trace: &println('test3: :)') at line 27
+Trace: &test3() at line 33
+Trace: &local('$count $var') at line 37
+0   = a
+Trace: &println('0   = a') at line 41
+1   = b
+Trace: &println('1   = b') at line 41
+2   = c
+Trace: &println('2   = c') at line 41
+3   = d
+Trace: &println('3   = d') at line 41
+a: apple and b: boy and c: cat
+Trace: &println('a: apple and b: boy and c: cat') at line 44
+Trace: &test4('a', 'b', $a => 'apple', 'c', $b => 'boy', 'd', $c => 'cat') at line 47
+Test 5 has been called, executing action:
+Trace: &println('Test 5 has been called, executing action:') at line 51
+The passed in closure has been called
+Trace: &println('The passed in closure has been called') at line 55
+Trace: [&closure10363227] at line 52
+Trace: &test5($action => &closure10363227) at line 55
+Trace: &test5(action => &closure10481832) - FAILED! at line 56
+Warning: unreachable named parameter: action at line 56

Added: sleep/tests/output/pep255.sl
===================================================================
--- sleep/tests/output/pep255.sl	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/tests/output/pep255.sl	2006-09-24 18:13:22 UTC (rev 124)
@@ -0,0 +1,30 @@
+In order tree traversal
+3
++
+4
+root
+6
+-
+2
+*
+30
+Pre order tree traversal
+3
+4
++
+6
+2
+-
+30
+*
+root
+Post order tree traversal
+root
++
+3
+4
+*
+-
+6
+2
+30

Added: sleep/tests/pep255.sl
===================================================================
--- sleep/tests/pep255.sl	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/tests/pep255.sl	2006-09-24 18:13:22 UTC (rev 124)
@@ -0,0 +1,128 @@
+#
+# inspired by Python PEP 255... recursive generators for Sleep
+#
+
+# do an inorder traversal of a tree closure
+sub inorder
+{
+   local('$x');
+
+   if ($1 !is $null)
+   {
+      while $x (inorder([$1 left]))
+      {
+         yield $x;
+         local('$x');
+      }
+
+      yield [$1 label];
+
+      while $x (inorder([$1 right]))
+      {
+         yield $x;
+      } 
+   }
+
+   return $null;
+}
+
+# do a pre order traversal of a tree closure
+sub preorder
+{
+   local('$x');
+
+   if ($1 !is $null)
+   {
+      while $x (preorder([$1 left]))
+      {
+         yield $x;
+      }
+
+      while $x (preorder([$1 right]))
+      {
+         yield $x;
+      } 
+
+      yield [$1 label];
+   }
+
+   return $null;
+}
+
+# do a post order traversal of a tree closure
+sub postorder
+{
+   local('$x');
+
+   if ($1 !is $null)
+   {
+      yield [$1 label];
+
+      while $x (postorder([$1 left]))
+      {
+         yield $x;
+      }
+
+      while $x (postorder([$1 right]))
+      {
+         yield $x;
+      } 
+   }
+
+   return $null;
+}
+
+
+sub tree
+{
+   this('$label $left $right');
+
+   if ($0 eq "print")
+   {
+      return "( $+ $label $+ " . iff ($left !is $null, " " . [$left print], " ()") . iff($right !is $null, " " . [$right print], " ()") . ")";
+   }
+
+   if ($0 eq "left")
+   {
+      return $left;
+   }
+
+   if ($0 eq "right")
+   {
+      return $right;
+   }
+
+   if ($0 eq "label")
+   {
+      return $label;
+   }
+}
+
+sub node
+{
+   return lambda(&tree, $label => $1, $left => $2, $right => $3);
+} 
+
+$root = node("root", node("+", node(3), node(4)), node("*", node("-", node(6), node(2)), node(30)));
+
+println("In order tree traversal");
+
+while $traversal (inorder($root))
+{
+   println($traversal);
+}
+
+println("Pre order tree traversal");
+
+while $traversal (preorder($root))
+{
+   println($traversal);
+}
+
+println("Post order tree traversal");
+
+while $traversal (postorder($root))
+{
+   println($traversal);
+}
+

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-18 19:08:16 UTC (rev 123)
+++ sleep/whatsnew.txt	2006-09-24 18:13:22 UTC (rev 124)
@@ -6,6 +6,10 @@
   convert the key/value pair into a string i.e. $key=value
 - improved function call traceing to detect when a function call failed and to
   indicate that such an event occured.
+- coroutines are now allowed to call themselves in a recursive manner
+- when yield is called, the local variable state is preserved until the 
+  coroutine is called again (only when the coroutine is reset, i.e. exited w/o
+  a yield is the local variable state dropped).
 
 2.1-beta 5  (17 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Sun Sep 24 20:49:43 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sun, 24 Sep 2006 20:49:43 +0200
Subject: [Sleep-svn] r125 - in sleep: . src/sleep/bridges tests tests/output
Message-ID: <200609241849.k8OInhKf027553@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-24 20:49:43 +0200 (Sun, 24 Sep 2006)
New Revision: 125

Added:
   sleep/tests/hexbites.sl
   sleep/tests/output/hexbites.sl
Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/whatsnew.txt
Log:
Added a better unit tests for packing/unpacking hex data and a check to ensure only even length
strings are being used as a source of hex data to pack.



Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2006-09-24 18:13:22 UTC (rev 124)
+++ sleep/src/sleep/bridges/BasicIO.java	2006-09-24 18:49:43 UTC (rev 125)
@@ -826,8 +826,15 @@
              try
              {
                 StringBuffer number = new StringBuffer("FF");
-                char[] tempchars = BridgeUtilities.getString(arguments, "").toCharArray();
+                String       argzz  = BridgeUtilities.getString(arguments, "");
+             
+                if ((argzz.length() % 2) != 0)
+                {
+                   throw new IllegalArgumentException("can not pack '" + argzz + "' as hex string, number of characters must be even");
+                }
 
+                char[] tempchars = argzz.toCharArray();
+
                 for (int y = 0; y < tempchars.length; y += 2)
                 {
                    if (pattern.value == 'H')
@@ -845,6 +852,11 @@
                    out.write(bdata, 3, 1);
                 }
              }
+             catch (IllegalArgumentException aex)
+             {
+                if (control != null) control.close();
+                throw (aex);
+             }
              catch (Exception ex)
              {
                 ex.printStackTrace();

Added: sleep/tests/hexbites.sl
===================================================================
--- sleep/tests/hexbites.sl	2006-09-24 18:13:22 UTC (rev 124)
+++ sleep/tests/hexbites.sl	2006-09-24 18:49:43 UTC (rev 125)
@@ -0,0 +1,40 @@
+#
+# test some stuff packing and unpacking hex bytes.. dig?!?
+#
+
+$string ="000123456789ABCDEF";
+
+# low nybble first
+$pack   = pack("h*", $string);
+
+for ($x = 0; $x < strlen($pack); $x++)
+{
+   println("low -> $[3]x : " . asc(charAt($pack, $x)));
+}
+
+($unpack) = unpack("h*", $pack);
+println("low: $unpack");
+
+($unpack) = unpack("H*", $pack);
+println("...: $unpack");
+
+# high nybble first
+$pack   = pack("H*", $string);
+
+for ($x = 0; $x < strlen($pack); $x++)
+{
+   println("high -> $[3]x : " . asc(charAt($pack, $x)));
+}
+
+($unpack) = unpack("H*", $pack);
+println("high: $unpack");
+
+($unpack) = unpack("h*", $pack);
+println("....: $unpack");
+
+$string ="0001234567890ABCDEF"; # we want to cause an error here...
+
+# low nybble first
+$pack   = pack("h*", $string);
+
+println("Packed: $pack");

Added: sleep/tests/output/hexbites.sl
===================================================================
--- sleep/tests/output/hexbites.sl	2006-09-24 18:13:22 UTC (rev 124)
+++ sleep/tests/output/hexbites.sl	2006-09-24 18:49:43 UTC (rev 125)
@@ -0,0 +1,23 @@
+low -> 0   : 0
+low -> 1   : 16
+low -> 2   : 50
+low -> 3   : 84
+low -> 4   : 118
+low -> 5   : 152
+low -> 6   : 186
+low -> 7   : 220
+low -> 8   : 254
+low: 000123456789abcdef
+...: 001032547698badcfe
+high -> 0   : 0
+high -> 1   : 1
+high -> 2   : 35
+high -> 3   : 69
+high -> 4   : 103
+high -> 5   : 137
+high -> 6   : 171
+high -> 7   : 205
+high -> 8   : 239
+high: 000123456789abcdef
+....: 001032547698badcfe
+Warning: can not pack '0001234567890ABCDEF' as hex string, number of characters must be even at line 38

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-24 18:13:22 UTC (rev 124)
+++ sleep/whatsnew.txt	2006-09-24 18:49:43 UTC (rev 125)
@@ -10,6 +10,7 @@
 - when yield is called, the local variable state is preserved until the 
   coroutine is called again (only when the coroutine is reset, i.e. exited w/o
   a yield is the local variable state dropped).
+- added an error check for attempts to pack odd length hex strings
 
 2.1-beta 5  (17 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Sat Sep 30 09:22:22 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 30 Sep 2006 09:22:22 +0200
Subject: [Sleep-svn] r126 - in sleep: . src/sleep/bridges src/sleep/parser
	tests tests/data tests/data/src/org/hick/blah
	tests/data/src/org/hick/tests tests/output
Message-ID: <200609300722.k8U7MMZD029498@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-30 09:22:21 +0200 (Sat, 30 Sep 2006)
New Revision: 126

Added:
   sleep/tests/impfrom3.sl
   sleep/tests/output/impfrom3.sl
   sleep/tests/output/setfield.sl
   sleep/tests/setfield.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/parser/Checkers.java
   sleep/src/sleep/parser/CodeGenerator.java
   sleep/src/sleep/parser/Parser.java
   sleep/tests/checksum.sl
   sleep/tests/data/src/org/hick/blah/SqueezeBox.java
   sleep/tests/data/src/org/hick/tests/FooFunction.java
   sleep/tests/data/test.jar
   sleep/tests/digest.sl
   sleep/tests/forkdl.sl
   sleep/tests/output/byteconvert.sl
   sleep/tests/output/checksum.sl
   sleep/tests/output/digest.sl
   sleep/tests/output/fe_generatordb.sl
   sleep/tests/output/forkdl.sl
   sleep/whatsnew.txt
Log:
Added a way to set public fields and a check for import from: to ensure that the jar file 
exists.



Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2006-09-30 07:22:21 UTC (rev 126)
@@ -91,7 +91,8 @@
         temp.put("-istrue", this);    // predicate -istrue <Scalar>, determine wether or not the scalar is null or not.
         temp.put("-isarray", this);   
         temp.put("-ishash",  this); 
-
+        temp.put("&setField", this);
+     
         SetScope scopeFunctions = new SetScope();
 
         temp.put("&local",    scopeFunctions);
@@ -849,7 +850,60 @@
              return temp;
           }
        }
+       else if (n.equals("&setField"))
+       {
+          // setField(class/object, "field", "value")
 
+          Field  setMe  = null;
+          Class  aClass = null;
+          Object inst   = null;
+
+          if (l.size() == 3 && "==CLASS==".equals(value.toString()))
+          {
+             aClass = (Class)(BridgeUtilities.getScalar(l).objectValue());
+          }
+          else if (value.objectValue() == null)
+          {
+             throw new IllegalArgumentException("&setField: can not set field on a null object");
+          }
+          else if (l.size() == 2)
+          {
+             inst   = value.objectValue();
+             aClass = inst.getClass();
+          }
+          else
+          {
+             throw new IllegalArgumentException("&setField: not enough parameters");
+          }
+
+          String name = BridgeUtilities.getString(l, null);
+          Scalar arg  = BridgeUtilities.getScalar(l);
+
+          try
+          {
+             setMe = aClass.getDeclaredField(name);
+
+             if (ObjectUtilities.isArgMatch(setMe.getType(), arg) != 0)
+             {
+                setMe.setAccessible(true);
+                setMe.set(inst, ObjectUtilities.buildArgument(setMe.getType(), arg, i));
+             }
+             else
+             {
+                throw new RuntimeException("unable to convert " + SleepUtils.describe(arg) + " to a " + setMe.getType());
+             }
+          }
+          catch (NoSuchFieldException fex)
+          {
+             throw new RuntimeException("no field named " + name + " in " + aClass);
+          }
+          catch (RuntimeException rex) { throw (rex); }
+          catch (Exception ex)
+          {
+             throw new RuntimeException("cannot set " + name + " in " + aClass + ": " + ex.getMessage());
+          }
+       }
+
        return SleepUtils.getEmptyScalar();
-   }
+    }
 }

Modified: sleep/src/sleep/parser/Checkers.java
===================================================================
--- sleep/src/sleep/parser/Checkers.java	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/src/sleep/parser/Checkers.java	2006-09-30 07:22:21 UTC (rev 126)
@@ -101,7 +101,7 @@
 
    public static final boolean isClassIdentifier(Parser parser, String a)
    {
-       return parser.findImportedClass(a) != null;
+       return !isIndex(a) && parser.findImportedClass(a) != null;
    }
 
    public static final boolean isBindFilter(String a, String b, String c, String d)

Modified: sleep/src/sleep/parser/CodeGenerator.java
===================================================================
--- sleep/src/sleep/parser/CodeGenerator.java	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/src/sleep/parser/CodeGenerator.java	2006-09-30 07:22:21 UTC (rev 126)
@@ -765,6 +765,16 @@
               atom = GeneratedSteps.Decide(parsePredicate(termsAr[0]), a, b);
               add(atom, tokens[0]); 
            }
+           else if (strings[0].equals("&setField"))
+           {
+              atom = GeneratedSteps.CreateFrame();
+              add(atom, tokens[0]);
+
+              parseSpecialParameters(ParserUtilities.extract(tokens[1]));
+
+              atom = GeneratedSteps.Call(strings[0]);
+              add(atom, tokens[0]);
+           }
            else if (tokens.length > 1)
            {
               atom = GeneratedSteps.CreateFrame();
@@ -1020,7 +1030,11 @@
            }
            else
            {
-              parser.importPackage(strings[0], strings[1]);
+              File searchFor = parser.importPackage(strings[0], strings[1]);
+              if (searchFor == null || !searchFor.exists())
+              {
+                 parser.reportError("jar file to import package from was not found!", ParserUtilities.makeToken("import " + strings[0] + " from: " + strings[1], tokens[1]));
+              }
            }
            break;           
          case EXPR_RETURN:                     // implemented
@@ -1078,6 +1092,39 @@
       }     
    }
 
+   /** checks if the first token is potentially a class literal, if it is creates an
+       object scalar for it.  otherwise it is parsed as a normal literal idea */
+   public void parseSpecialParameters(Token token)
+   {
+      TokenList terms   = ParserUtilities.groupByParameterTerm(parser, token);
+      Token[]   termsAr = terms.getTokens();
+
+      for (int x = termsAr.length - 1; x >= 0; x--)
+      {
+         if (x == 0)
+         {
+            Class aClass = parser.findImportedClass(termsAr[x].toString());
+
+            if (aClass == null)
+            {
+               parseIdea(termsAr[x]);
+            }
+            else
+            {
+               Scalar  ascalar = SleepUtils.getScalar(aClass);
+               Step    atom    = GeneratedSteps.SValue(ascalar);
+               add(atom, termsAr[x]);
+
+               parseIdea(ParserUtilities.makeToken("'==CLASS=='", termsAr[x]));
+            }
+         }
+         else
+         {
+            parseIdea(termsAr[x]);
+         }
+      }
+   }
+
    public void parseParameters(Token token)
    {
       TokenList terms   = ParserUtilities.groupByParameterTerm(parser, token);

Modified: sleep/src/sleep/parser/Parser.java
===================================================================
--- sleep/src/sleep/parser/Parser.java	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/src/sleep/parser/Parser.java	2006-09-30 07:22:21 UTC (rev 126)
@@ -76,8 +76,10 @@
    protected HashMap    jars      = new HashMap(); /* resolved jar files, key=jar name value=ClassLoader */
 
    /** Used by hoes to import package names... */
-   public void importPackage(String packagez, String from)
+   public File importPackage(String packagez, String from)
    {
+       File returnValue = null;
+
        String pack, clas;
        clas = packagez.substring(packagez.lastIndexOf(".") + 1, packagez.length());
        pack = packagez.substring(0, packagez.lastIndexOf("."));
@@ -88,10 +90,12 @@
        {
           try
           {
-             URLClassLoader loader = new URLClassLoader(new URL[] { ParserConfig.findJarFile(from).toURL() }, Thread.currentThread().getContextClassLoader());
+             returnValue = ParserConfig.findJarFile(from);
+ 
+             URLClassLoader loader = new URLClassLoader(new URL[] { returnValue.toURL() }, Thread.currentThread().getContextClassLoader());
              jars.put(from, loader);
           }
-          catch (Exception ex) { }
+          catch (Exception ex) { ex.printStackTrace(); }
        }
 
        /* handle importing our package */
@@ -107,12 +111,12 @@
           Class found = findImportedClass(packagez);
           classes.put(clas, found);
        }
+
+       return returnValue;
    }
 
    private Class resolveClass(String pack, String clas, String jar)
    {
-//       System.out.println("Attempting to resolve: '" + pack + "' + '" + clas + "' + '" + jar + "'");
-
        try
        {
           if (jar != null)

Modified: sleep/tests/checksum.sl
===================================================================
--- sleep/tests/checksum.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/checksum.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -1,9 +1,8 @@
 #
 # test the checksum API
 #
+$REAL = 453947233; # output of UNIX crc32 command for test.jar
 
-$REAL = 990741747; # output of UNIX crc32 command for test.jar
-
 # first test... checksumming an I/O handle :)
 
 $handle = openf("data/test.jar");

Modified: sleep/tests/data/src/org/hick/blah/SqueezeBox.java
===================================================================
--- sleep/tests/data/src/org/hick/blah/SqueezeBox.java	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/data/src/org/hick/blah/SqueezeBox.java	2006-09-30 07:22:21 UTC (rev 126)
@@ -2,8 +2,22 @@
 
 public class SqueezeBox
 {
+   public static String aStringField = "this is a string field";
+   public static double aDoubleField = 3.0;
+
+   public String  instanceStringField  = "this is also a string field";
+   public boolean instanceBooleanField = true;
+
    protected int sq = 33;
 
+   public void printValues()
+   {
+      System.out.println("static members:");
+      System.out.println("aStringField '" + aStringField + "' and aDoubleField = " + aDoubleField);
+      System.out.println("instance members:");
+      System.out.println("instanceStringField '" + instanceStringField + "' instanceBooleanField = " + instanceBooleanField);
+   }
+
    public int squeeze()
    { 
       sq++;

Modified: sleep/tests/data/src/org/hick/tests/FooFunction.java
===================================================================
--- sleep/tests/data/src/org/hick/tests/FooFunction.java	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/data/src/org/hick/tests/FooFunction.java	2006-09-30 07:22:21 UTC (rev 126)
@@ -7,6 +7,8 @@
 
 public class FooFunction implements Function
 {
+   public static double aField = 3.0;
+
    private int calls = 0;
 
    public Scalar evaluate(String name, ScriptInstance script, Stack locals)

Modified: sleep/tests/data/test.jar
===================================================================
(Binary files differ)

Modified: sleep/tests/digest.sl
===================================================================
--- sleep/tests/digest.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/digest.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -2,7 +2,7 @@
 # test the digest API
 #
 
-$REAL = '17bc99c1ea48937e2f702c7ef1c5025c'; # output of UNIX md5 command for test.jar
+$REAL = '052168a92bfc545941d9352b35288ac3';# output of UNIX md5 command for test.jar
 
 # first test... digest an I/O handle :)
 

Modified: sleep/tests/forkdl.sl
===================================================================
--- sleep/tests/forkdl.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/forkdl.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -1,9 +1,8 @@
 #
 # reproduce a deadlock problem with fork...
 #
+$REAL = 453947233; # output of UNIX crc32 command for test.jar
 
-$REAL = 990741747; # output of UNIX crc32 command for test.jar
-
 # third test.. the kewlest test of them all...
 
 $sumfork = fork({

Added: sleep/tests/impfrom3.sl
===================================================================
--- sleep/tests/impfrom3.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/impfrom3.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -0,0 +1,14 @@
+#
+# test of the error checking with import from i.e. reporting that the file was not found.
+#
+
+import org.hick.blah.SqueezeBox from: data/tes.jar;
+
+$sq = [new SqueezeBox];
+
+for ($x = 0; $x < 10; $x++)
+{
+   println("Test: " . [$sq squeeze]);
+}
+
+

Modified: sleep/tests/output/byteconvert.sl
===================================================================
--- sleep/tests/output/byteconvert.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/byteconvert.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -1,4 +1,4 @@
 Warning: variable '$data' not declared at line 9
 Warning: variable '$summer' not declared at line 11
 Warning: variable '$bytes' not declared at line 15
-The MD5 value of test.jar is: 17bc99c1ea48937e2f702c7ef1c5025c
+The MD5 value of test.jar is: 052168a92bfc545941d9352b35288ac3

Modified: sleep/tests/output/checksum.sl
===================================================================
--- sleep/tests/output/checksum.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/checksum.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -1,3 +1,3 @@
-(1) Checksum value of test.jar is: 990741747 good? yes
-(2) Checksum value of test.jar is: 990741747 good? yes
-Checksum of written data is: 990741747
+(1) Checksum value of test.jar is: 453947233 good? yes
+(2) Checksum value of test.jar is: 453947233 good? yes
+Checksum of written data is: 453947233

Modified: sleep/tests/output/digest.sl
===================================================================
--- sleep/tests/output/digest.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/digest.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -1,4 +1,4 @@
-(1) Digest value of test.jar is: 17bc99c1ea48937e2f702c7ef1c5025c good? yes
+(1) Digest value of test.jar is: 052168a92bfc545941d9352b35288ac3 good? yes
 (2) Another test of repacked data: good
-(3) Digest value of test.jar is: 17bc99c1ea48937e2f702c7ef1c5025c good? yes
-Digest of written data is: 17bc99c1ea48937e2f702c7ef1c5025c
+(3) Digest value of test.jar is: 052168a92bfc545941d9352b35288ac3 good? yes
+Digest of written data is: 052168a92bfc545941d9352b35288ac3

Modified: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -19,7 +19,7 @@
 Trace: &println('8 => val: 8') at line 8
 9 => val: 9
 Trace: &println('9 => val: 9') at line 8
-Trace: &lambda(&closure10481832, $start => 50, $stop => 60) = &closure7388808 at line 22
+Trace: &lambda(&closure7415377, $start => 50, $stop => 60) = &closure9087808 at line 22
 Testing out range stuff: 0 => 50
 Trace: &println('Testing out range stuff: 0 => 50') at line 24
 Testing out range stuff: 1 => 51
@@ -41,7 +41,7 @@
 Testing out range stuff: 9 => 59
 Trace: &println('Testing out range stuff: 9 => 59') at line 24
 Trace: &this('$start $stop') at line 29
-Trace: &_range2(70, 80) = &closure15531527 at line 42
+Trace: &_range2(70, 80) = &closure15794899 at line 42
 My third test: 0 => 70
 Trace: &println('My third test: 0 => 70') at line 44
 My third test: 1 => 71

Modified: sleep/tests/output/forkdl.sl
===================================================================
--- sleep/tests/output/forkdl.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/forkdl.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -1 +1 @@
-Checksum of written data is: 990741747
+Checksum of written data is: 453947233

Added: sleep/tests/output/impfrom3.sl
===================================================================
--- sleep/tests/output/impfrom3.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/impfrom3.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -0,0 +1,2 @@
+Error: jar file to import package from was not found! at line 5
+       import org.hick.blah.SqueezeBox from: data/tes.jar

Added: sleep/tests/output/setfield.sl
===================================================================
--- sleep/tests/output/setfield.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/output/setfield.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -0,0 +1,2 @@
+Error: jar file to import package from was not found! at line 5
+       import org.hick.blah.SqueezeBox from: tests/data/test.jar

Added: sleep/tests/setfield.sl
===================================================================
--- sleep/tests/setfield.sl	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/tests/setfield.sl	2006-09-30 07:22:21 UTC (rev 126)
@@ -0,0 +1,50 @@
+#
+# test setting of fields...
+#
+
+import org.hick.blah.SqueezeBox from: tests/data/test.jar;
+
+$sb1 = [new SqueezeBox];
+$sb2 = [new SqueezeBox];
+
+println("Pre change:");
+[$sb1 printValues];
+
+setField(SqueezeBox, "aDoubleField", 4);
+[$sb1 printValues];
+[$sb2 printValues];
+
+println("-" x 60);
+
+setField($sb1, "instanceStringField", "squeeze box 1");
+setField($sb2, "instanceStringField", "squeeze box 2");
+[$sb1 printValues];
+[$sb2 printValues];
+
+println("-" x 60);
+
+setField($sb1, "instanceBooleanField", 0);
+[$sb1 printValues];
+[$sb2 printValues];
+
+println("-" x 60);
+
+setField($sb2, "aStringField", "the rain in spain, falls mainly on the plain");
+[$sb1 printValues];
+[$sb2 printValues];
+
+println("-" x 60);
+
+[{
+   setField($sb2, "nofield", 33);
+}];
+
+[{
+   setField($sb2, "instanceBooleanField", "false and true?");
+}];
+
+println([$sb1 squeeze]);
+setField($sb1, "sq", 55);
+println([$sb1 squeeze]);
+
+println("Done?");

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-24 18:49:43 UTC (rev 125)
+++ sleep/whatsnew.txt	2006-09-30 07:22:21 UTC (rev 126)
@@ -11,6 +11,10 @@
   coroutine is called again (only when the coroutine is reset, i.e. exited w/o
   a yield is the local variable state dropped).
 - added an error check for attempts to pack odd length hex strings
+- parser now throws an error if a jar file specified with import * from: is not
+  found.
+- added a &setField(class|$object, "field", value) function for setting the 
+  value of a field in a Java class or object.
 
 2.1-beta 5  (17 Sept 06)
 ===========



From rsmudge at mail.berlios.de  Sat Sep 30 10:10:11 2006
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 30 Sep 2006 10:10:11 +0200
Subject: [Sleep-svn] r127 - in sleep: . src/sleep/bridges tests tests/output
Message-ID: <200609300810.k8U8ABAD000550@sheep.berlios.de>

Author: rsmudge
Date: 2006-09-30 10:10:11 +0200 (Sat, 30 Sep 2006)
New Revision: 127

Added:
   sleep/tests/output/setf.sl
   sleep/tests/setf.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/tests/output/fe_generatordb.sl
   sleep/tests/output/setfield.sl
   sleep/tests/setfield.sl
   sleep/whatsnew.txt
Log:
Added setf for setting functions on the fly.



Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2006-09-30 08:10:11 UTC (rev 127)
@@ -111,7 +111,10 @@
 
         // closure / function handle type stuff
         temp.put("&lambda",    new lambda());
-        temp.put("&function",  new function());
+
+        function funcs = new function();
+        temp.put("&function",  funcs);
+        temp.put("&setf",      funcs);
         temp.put("&compile_closure",    new compile_closure());
         temp.put("&eval",     new eval());
         temp.put("&expr",     new expr());
@@ -368,8 +371,38 @@
     {
        public Scalar evaluate(String n, ScriptInstance si, Stack l)
        {
-          String temp = BridgeUtilities.getString(l, "");
-          return SleepUtils.getScalar(si.getScriptEnvironment().getFunction(temp));
+          if (n.equals("&function"))
+          {
+             String temp = BridgeUtilities.getString(l, "");
+             return SleepUtils.getScalar(si.getScriptEnvironment().getFunction(temp));
+          }
+          else if (n.equals("&setf"))
+          {
+             String   temp = BridgeUtilities.getString(l, "&eh");
+             Object   o    = BridgeUtilities.getObject(l);
+
+             if (temp.charAt(0) == '&' && (o == null || o instanceof Function))
+             {
+                if (o == null)
+                {
+                   si.getScriptEnvironment().getEnvironment().remove(temp);
+                }
+                else
+                {
+                   si.getScriptEnvironment().getEnvironment().put(temp, o);
+                }
+             }
+             else if (temp.charAt(0) != '&')
+             {
+                throw new IllegalArgumentException("&setf: invalid function name '" + temp + "'");
+             }
+             else if (o != null)
+             {
+                throw new IllegalArgumentException("&setf: can not set function " + temp + " to a " + o.getClass());
+             }
+          }
+
+          return SleepUtils.getEmptyScalar();
        }
     }
 

Modified: sleep/tests/output/fe_generatordb.sl
===================================================================
--- sleep/tests/output/fe_generatordb.sl	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/tests/output/fe_generatordb.sl	2006-09-30 08:10:11 UTC (rev 127)
@@ -19,7 +19,7 @@
 Trace: &println('8 => val: 8') at line 8
 9 => val: 9
 Trace: &println('9 => val: 9') at line 8
-Trace: &lambda(&closure7415377, $start => 50, $stop => 60) = &closure9087808 at line 22
+Trace: &lambda(&closure10132325, $start => 50, $stop => 60) = &closure5253145 at line 22
 Testing out range stuff: 0 => 50
 Trace: &println('Testing out range stuff: 0 => 50') at line 24
 Testing out range stuff: 1 => 51
@@ -41,7 +41,7 @@
 Testing out range stuff: 9 => 59
 Trace: &println('Testing out range stuff: 9 => 59') at line 24
 Trace: &this('$start $stop') at line 29
-Trace: &_range2(70, 80) = &closure15794899 at line 42
+Trace: &_range2(70, 80) = &closure7907968 at line 42
 My third test: 0 => 70
 Trace: &println('My third test: 0 => 70') at line 44
 My third test: 1 => 71

Added: sleep/tests/output/setf.sl
===================================================================
--- sleep/tests/output/setf.sl	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/tests/output/setf.sl	2006-09-30 08:10:11 UTC (rev 127)
@@ -0,0 +1,10 @@
+foo
+Warning: Attempted to call non-existent function &foo at line 9
+bar
+Warning: &setf: can not set function &foo to a class java.lang.String at line 19
+Warning: &setf: invalid function name foo at line 20
+bar
+bar
+bar
+not foo
+bar

Modified: sleep/tests/output/setfield.sl
===================================================================
--- sleep/tests/output/setfield.sl	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/tests/output/setfield.sl	2006-09-30 08:10:11 UTC (rev 127)
@@ -1,2 +1,46 @@
-Error: jar file to import package from was not found! at line 5
-       import org.hick.blah.SqueezeBox from: tests/data/test.jar
+Pre change:
+static members:
+aStringField 'this is a string field' and aDoubleField = 3.0
+instance members:
+instanceStringField 'this is also a string field' instanceBooleanField = true
+static members:
+aStringField 'this is a string field' and aDoubleField = 4.0
+instance members:
+instanceStringField 'this is also a string field' instanceBooleanField = true
+static members:
+aStringField 'this is a string field' and aDoubleField = 4.0
+instance members:
+instanceStringField 'this is also a string field' instanceBooleanField = true
+------------------------------------------------------------
+static members:
+aStringField 'this is a string field' and aDoubleField = 4.0
+instance members:
+instanceStringField 'squeeze box 1' instanceBooleanField = true
+static members:
+aStringField 'this is a string field' and aDoubleField = 4.0
+instance members:
+instanceStringField 'squeeze box 2' instanceBooleanField = true
+------------------------------------------------------------
+static members:
+aStringField 'this is a string field' and aDoubleField = 4.0
+instance members:
+instanceStringField 'squeeze box 1' instanceBooleanField = false
+static members:
+aStringField 'this is a string field' and aDoubleField = 4.0
+instance members:
+instanceStringField 'squeeze box 2' instanceBooleanField = true
+------------------------------------------------------------
+static members:
+aStringField 'the rain in spain, falls mainly on the plain' and aDoubleField = 4.0
+instance members:
+instanceStringField 'squeeze box 1' instanceBooleanField = false
+static members:
+aStringField 'the rain in spain, falls mainly on the plain' and aDoubleField = 4.0
+instance members:
+instanceStringField 'squeeze box 2' instanceBooleanField = true
+------------------------------------------------------------
+Warning: no field named nofield in class org.hick.blah.SqueezeBox at line 39
+Warning: unable to convert 'false and true?' to a boolean at line 43
+34
+56
+Done?

Added: sleep/tests/setf.sl
===================================================================
--- sleep/tests/setf.sl	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/tests/setf.sl	2006-09-30 08:10:11 UTC (rev 127)
@@ -0,0 +1,34 @@
+#
+# test setting named closures...
+#
+
+setf('&foo', { println("foo"); });
+foo();
+
+setf('&foo', $null);
+foo();
+
+sub bar
+{ 
+   println("bar");
+}
+
+setf('&foo', &bar);
+foo();
+
+[{ setf('&foo', "ninja moves"); }];
+[{ setf('foo', { println("eh?!?"); }); }];
+
+foo();
+
+[function('&foo')];
+
+$x = &foo;
+
+setf('&foo', { println("not foo"); });
+
+[$x];
+foo();
+
+setf('&foo', $x);
+foo();

Modified: sleep/tests/setfield.sl
===================================================================
--- sleep/tests/setfield.sl	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/tests/setfield.sl	2006-09-30 08:10:11 UTC (rev 127)
@@ -2,7 +2,7 @@
 # test setting of fields...
 #
 
-import org.hick.blah.SqueezeBox from: tests/data/test.jar;
+import org.hick.blah.SqueezeBox from: data/test.jar;
 
 $sb1 = [new SqueezeBox];
 $sb2 = [new SqueezeBox];

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2006-09-30 07:22:21 UTC (rev 126)
+++ sleep/whatsnew.txt	2006-09-30 08:10:11 UTC (rev 127)
@@ -15,6 +15,8 @@
   found.
 - added a &setField(class|$object, "field", value) function for setting the 
   value of a field in a Java class or object.
+- added &setf('&function', { closure }) for setting a named closure (i.e. a 
+  subroutine).
 
 2.1-beta 5  (17 Sept 06)
 ===========



