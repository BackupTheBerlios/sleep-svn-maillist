From rsmudge at mail.berlios.de  Wed Mar 19 18:20:18 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Wed, 19 Mar 2008 18:20:18 +0100
Subject: [Sleep-svn] r319 - in sleep: . src/sleep/bridges src/sleep/engine
	tests tests/output
Message-ID: <200803191720.m2JHKIMJ001581@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-19 18:20:14 +0100 (Wed, 19 Mar 2008)
New Revision: 319

Added:
   sleep/tests/copy.sl
   sleep/tests/forkshare.sl
   sleep/tests/output/copy.sl
   sleep/tests/output/forkshare.sl
   sleep/tests/output/pushl.sl
   sleep/tests/output/round.sl
   sleep/tests/pushl.sl
   sleep/tests/round.sl
Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/bridges/BasicNumbers.java
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/bridges/BridgeUtilities.java
   sleep/src/sleep/bridges/RegexBridge.java
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/engine/CallRequest.java
   sleep/whatsnew.txt
Log:
lots of changes...


Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/bridges/BasicIO.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -457,7 +457,7 @@
           while (!l.isEmpty())
           {
              KeyValuePair kvp = BridgeUtilities.getKeyValuePair(l);
-             vars.putScalar(kvp.getKey().toString(), kvp.getValue());
+             vars.putScalar(kvp.getKey().toString(), SleepUtils.getScalar(kvp.getValue()));
           }
 
           // create a pipe between these two items...

Modified: sleep/src/sleep/bridges/BasicNumbers.java
===================================================================
--- sleep/src/sleep/bridges/BasicNumbers.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/bridges/BasicNumbers.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -110,7 +110,22 @@
        else if (name.equals("&cos")) { return SleepUtils.getScalar(Math.cos(BridgeUtilities.getDouble(args, 0.0))); }
        else if (name.equals("&log") && args.size() == 1) { return SleepUtils.getScalar(Math.log(BridgeUtilities.getDouble(args, 0.0))); }
        else if (name.equals("&log") && args.size() == 2) { return SleepUtils.getScalar(Math.log(BridgeUtilities.getDouble(args, 0.0)) / Math.log(BridgeUtilities.getDouble(args, 0.0))); }
-       else if (name.equals("&round")) { return SleepUtils.getScalar(Math.round(BridgeUtilities.getDouble(args, 0.0))); }
+       else if (name.equals("&round")) { 
+           if (args.size() == 1)
+           {
+              return SleepUtils.getScalar(Math.round(BridgeUtilities.getDouble(args, 0.0))); 
+           }
+           else
+           {
+              /* round to a certain number of places--if the argument is significantly large, this function could break */
+              double number = BridgeUtilities.getDouble(args, 0.0);
+              double places = Math.pow(10, BridgeUtilities.getInt(args, 0));
+
+              number = Math.round(number * places);
+              number = number / places;
+              return SleepUtils.getScalar(number);
+           }
+       }
        else if (name.equals("&sin")) { return SleepUtils.getScalar(Math.sin(BridgeUtilities.getDouble(args, 0.0))); }
        else if (name.equals("&sqrt")) { return SleepUtils.getScalar(Math.sqrt(BridgeUtilities.getDouble(args, 0.0))); }
        else if (name.equals("&tan")) { return SleepUtils.getScalar(Math.tan(BridgeUtilities.getDouble(args, 0.0))); }

Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -95,6 +95,9 @@
         temp.put("&removeAll", this);
         temp.put("&retainAll", this);
 
+        temp.put("&pushl", this);
+        temp.put("&popl", this);
+      
         temp.put("&search", this);
         temp.put("&reduce", this);
         temp.put("&values", this);
@@ -121,6 +124,7 @@
         temp.put("&watch", this);
 
         temp.put("&debug", this);
+        temp.put("&warn", this);
         temp.put("&profile", this);
         temp.put("&getStackTrace", this);
 
@@ -909,6 +913,10 @@
        {
           return SleepUtils.getArrayWrapper(i.getStackTrace());
        }
+       else if (n.equals("&warn"))
+       {
+          return SleepUtils.getEmptyScalar();
+       }
        else if (n.equals("&debug"))
        {
           /* allow the script to programatically set the debug level */
@@ -924,7 +932,27 @@
        {
           return BridgeUtilities.flattenIterator(BridgeUtilities.getIterator(l, i), null);
        }
+       else if (n.equals("&pushl") || n.equals("&popl"))
+       {
+          ScriptVariables vars = i.getScriptVariables();
+ 
+          if (n.equals("&pushl"))
+          {
+             vars.pushLocalLevel();
+          }
+          else if (n.equals("&popl"))
+          {
+             vars.popLocalLevel();
+          }
 
+          if (!l.isEmpty())
+          {
+             BridgeUtilities.initLocalScope(vars, vars.getLocalVariables(), l);
+          }
+
+          return SleepUtils.getEmptyScalar();
+       }
+
        /** Start of many array functions */
 
        Scalar value = BridgeUtilities.getScalar(l);

Modified: sleep/src/sleep/bridges/BridgeUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BridgeUtilities.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/bridges/BridgeUtilities.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -313,7 +313,7 @@
    }
 
    /** initializes local scope based on argument stack */
-   public static void initLocalScope(ScriptVariables vars, Variable localLevel, Stack locals)
+   public static int initLocalScope(ScriptVariables vars, Variable localLevel, Stack locals)
    {
       int name = 1;
 
@@ -341,7 +341,8 @@
          }
       }
 
-      vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(name, localLevel)), localLevel);
+//      vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(name, localLevel)), localLevel);
+      return name;
    }
 
    /** normalizes the index value based on the specified length */

Modified: sleep/src/sleep/bridges/RegexBridge.java
===================================================================
--- sleep/src/sleep/bridges/RegexBridge.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/bridges/RegexBridge.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -240,9 +240,9 @@
     {
        public Scalar evaluate(String n, ScriptInstance script, Stack l)
        {
-          String a = ((Scalar)l.pop()).toString(); // current
-          String b = ((Scalar)l.pop()).toString(); // old
-          String c = ((Scalar)l.pop()).toString(); // new
+          String a = BridgeUtilities.getString(l, ""); // current
+          String b = BridgeUtilities.getString(l, ""); // old
+          String c = BridgeUtilities.getString(l, ""); // new
           int    d = BridgeUtilities.getInt(l, -1);
 
           StringBuffer rv = new StringBuffer();

Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/bridges/SleepClosure.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -211,7 +211,8 @@
           // initialize local variables...
           //
           vars.setScalarLevel("$0", SleepUtils.getScalar(message), localLevel);
-          BridgeUtilities.initLocalScope(vars, localLevel, locals);
+          int targs = BridgeUtilities.initLocalScope(vars, localLevel, locals);
+          vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new ArgumentArray(targs, localLevel)), localLevel);
 
           //
           // call the function, save the scalar that was returned. 

Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/src/sleep/engine/CallRequest.java	2008-03-19 17:20:14 UTC (rev 319)
@@ -285,7 +285,10 @@
          synchronized (vars)
          {
             Variable localLevel = vars.getLocalVariables();
-            sleep.bridges.BridgeUtilities.initLocalScope(vars, localLevel, getScriptEnvironment().getCurrentFrame());
+
+            int targs = sleep.bridges.BridgeUtilities.initLocalScope(vars, localLevel, getScriptEnvironment().getCurrentFrame());
+            vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new sleep.bridges.ArgumentArray(targs, localLevel)), localLevel);
+
             return inline.evaluate(getScriptEnvironment());
          }
       }

Added: sleep/tests/copy.sl
===================================================================
--- sleep/tests/copy.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/copy.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,9 @@
+#
+# copying a hash...
+#
+
+%hash = %(a => "apple", b => "bananna", g => "grape fruit", k => "kiwi");
+%h2   = copy(%hash);
+
+println(%h2);
+println(keys(%h2));

Added: sleep/tests/forkshare.sl
===================================================================
--- sleep/tests/forkshare.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/forkshare.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,26 @@
+#
+# fork, sharing values...  
+#
+
+$counter = 90;
+
+fork({
+  while ($counter < 100)
+  {
+     $counter++;
+     println("A: $counter");
+     [Thread yield];
+  }
+
+}, \$counter);
+
+fork({
+  sleep(500); # I hate time kludges...
+
+  while ($counter < 100)
+  {
+     $counter++;
+     println("B: $counter");
+     [Thread yield];
+  }
+}, \$counter);

Added: sleep/tests/output/copy.sl
===================================================================
--- sleep/tests/output/copy.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/output/copy.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,2 @@
+%(k => 'kiwi', a => 'apple', g => 'grape fruit', b => 'bananna')
+@('k', 'a', 'g', 'b')

Added: sleep/tests/output/forkshare.sl
===================================================================
--- sleep/tests/output/forkshare.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/output/forkshare.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,20 @@
+A: 91
+A: 92
+A: 93
+A: 94
+A: 95
+A: 96
+A: 97
+A: 98
+A: 99
+A: 100
+B: 91
+B: 92
+B: 93
+B: 94
+B: 95
+B: 96
+B: 97
+B: 98
+B: 99
+B: 100

Added: sleep/tests/output/pushl.sl
===================================================================
--- sleep/tests/output/pushl.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/output/pushl.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,3 @@
+This is a test! noPHEAR and 
+pHEAR
+13500 and noPHEAR

Added: sleep/tests/output/round.sl
===================================================================
--- sleep/tests/output/round.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/output/round.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,5 @@
+4.57
+4.569
+4.569
+4.567954
+4.567953

Added: sleep/tests/pushl.sl
===================================================================
--- sleep/tests/pushl.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/pushl.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,22 @@
+#
+# test for scope management...
+#
+
+inline bar
+{
+   pushl($a => $1, $b => $2);
+   $z = "pHEAR";
+   println($z);
+   popl($result => $a * $b);
+}
+
+sub foo
+{
+   local('$z'); 
+   $z = "noPHEAR";
+   println("This is a test! $z and $result");
+   bar(300, 45);
+   println("$result and $z");
+}
+
+foo();

Added: sleep/tests/round.sl
===================================================================
--- sleep/tests/round.sl	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/tests/round.sl	2008-03-19 17:20:14 UTC (rev 319)
@@ -0,0 +1,5 @@
+println(round(4.56734, 2));
+println(round(4.56899, 3));
+println(round(4.56900, 4));
+println(round(4.5679538543795973573789, 6));
+println(round(4.5679532543795973573789, 6));

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-02-16 16:03:15 UTC (rev 318)
+++ sleep/whatsnew.txt	2008-03-19 17:20:14 UTC (rev 319)
@@ -10,6 +10,17 @@
   Java objects (in lieu of sleep.runtime.Scalar objects)
 - updated &copy to accept either a singular scalar or a hash 
   argument.
+- added &pushl and &popl for creating and removing local scope, 
+  arguments to these functions are used to pass data between the
+  current and resulting local scope.
+- fork now passes copies of its arguments into the forked scope.
+  this is in line with how lambda, let, etc.. work.  pass a data
+  structure (such as an array or hash) to have updateable shared
+  values.
+- round function can now round to a certain number of places if
+  desired.
+- replace function can now handle empty arguments, it will use
+  empty strings in their place.
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Wed Mar 19 19:22:50 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Wed, 19 Mar 2008 19:22:50 +0100
Subject: [Sleep-svn] r320 - in sleep: . src/sleep/bridges src/sleep/parser
	tests tests/output
Message-ID: <200803191822.m2JIMoZL011906@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-19 19:22:49 +0100 (Wed, 19 Mar 2008)
New Revision: 320

Added:
   sleep/tests/output/push.sl
   sleep/tests/output/warn2.sl
   sleep/tests/push.sl
   sleep/tests/warn2.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/parser/CodeGenerator.java
   sleep/tests/ifferr.sl
   sleep/tests/output/ifferr.sl
   sleep/whatsnew.txt
Log:
more changes.


Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2008-03-19 18:22:49 UTC (rev 320)
@@ -915,6 +915,9 @@
        }
        else if (n.equals("&warn"))
        {
+          /* for those looking at how to read current line number from an executing function, you can't.  this function
+             is a special case.  the parser looks for &warn and adds an extra argument containing the current line number */
+          i.fireWarning(BridgeUtilities.getString(l, "warning requested"), BridgeUtilities.getInt(l, -1));
           return SleepUtils.getEmptyScalar();
        }
        else if (n.equals("&debug"))
@@ -959,7 +962,14 @@
 
        if (n.equals("&push"))
        {
-          return value.getArray().push(SleepUtils.getScalar((Scalar)l.pop()));
+          Scalar pushed = null;
+          while (!l.isEmpty())
+          {
+             pushed = (Scalar)l.pop();
+             value.getArray().push(SleepUtils.getScalar(pushed));
+          }
+ 
+          return pushed == null ? SleepUtils.getEmptyScalar() : pushed;
        }
        else if ((n.equals("&retainAll") || n.equals("&removeAll")) && value.getArray() != null)
        {

Modified: sleep/src/sleep/parser/CodeGenerator.java
===================================================================
--- sleep/src/sleep/parser/CodeGenerator.java	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/src/sleep/parser/CodeGenerator.java	2008-03-19 18:22:49 UTC (rev 320)
@@ -780,24 +780,31 @@
               strings[0] = '&' + strings[0];
            }
 
-           if (strings[0].equals("&iff") && tokens.length > 1)
+           if ((strings[0].equals("&iff") || strings[0].equals("&?")) && tokens.length > 1)
            {
               TokenList terms = ParserUtilities.groupByParameterTerm(parser, ParserUtilities.extract(tokens[1]));
-
               Token[] termsAr = terms.getTokens();
 
-              if (termsAr.length != 3)
+              backup();
+              if (termsAr.length >= 2)
               {
-                 parser.reportErrorWithMarker("iff(condition, value_t, value_f): invalid form.", tokens[0].copy(strings[0] + strings[1]));
-                 break;
+                 parseIdea(termsAr[1]);
               }
-
-              backup();
-              parseIdea(termsAr[1]);
+              else
+              {
+                 parseIdea(termsAr[0].copy("true"));
+              }
               a = restore();
 
               backup();
-              parseIdea(termsAr[2]);
+              if (termsAr.length == 3)
+              {
+                 parseIdea(termsAr[2]);
+              }
+              else
+              {
+                 parseIdea(termsAr[0].copy("false"));
+              }
               b = restore();
 
               atom = GeneratedSteps.Decide(parsePredicate(termsAr[0]), a, b);
@@ -808,6 +815,13 @@
               atom = GeneratedSteps.CreateFrame();
               add(atom, tokens[0]);
 
+              /* if we're dealing with the warn function, sneak the current line number in as an argument. */
+              if (strings[0].equals("&warn"))
+              {
+                 atom    = GeneratedSteps.SValue(SleepUtils.getScalar(tokens[0].getHint()));
+                 add(atom, tokens[0]);
+              }
+
               parseParameters(ParserUtilities.extract(tokens[1]));
 
               atom = GeneratedSteps.Call(strings[0]);

Modified: sleep/tests/ifferr.sl
===================================================================
--- sleep/tests/ifferr.sl	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/tests/ifferr.sl	2008-03-19 18:22:49 UTC (rev 320)
@@ -1,5 +1,5 @@
 #
-# Testing beloved iff featured
+# Testing beloved iff featured (these forms used to be the cause of an error, as of Sleep 2.1-b21 they are good)
 #
 
 $x = 10;
@@ -7,3 +7,7 @@
 
 $x = 1;
 println("Took " . $x . " second" . iff($x > 1, "s", ""));
+
+println("Last test? " . iff($x == 1));
+println("Last test? " . iff($x != 1));
+

Modified: sleep/tests/output/ifferr.sl
===================================================================
--- sleep/tests/output/ifferr.sl	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/tests/output/ifferr.sl	2008-03-19 18:22:49 UTC (rev 320)
@@ -1,2 +1,4 @@
-Error: iff(condition, value_t, value_f): invalid form. at line 6
-       &iff($x > 1, "s")
+Took 10 seconds
+Took 1 second
+Last test? 1
+Last test? 

Added: sleep/tests/output/push.sl
===================================================================
--- sleep/tests/output/push.sl	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/tests/output/push.sl	2008-03-19 18:22:49 UTC (rev 320)
@@ -0,0 +1,2 @@
+10
+@(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

Added: sleep/tests/output/warn2.sl
===================================================================
--- sleep/tests/output/warn2.sl	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/tests/output/warn2.sl	2008-03-19 18:22:49 UTC (rev 320)
@@ -0,0 +1,2 @@
+Warning: Couldn't open file: java.io.FileNotFoundException: jdfjsjkfjksfjksafjk (No such file or directory) at warn2.sl:15
+This is me acting really kewlios

Added: sleep/tests/push.sl
===================================================================
--- sleep/tests/push.sl	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/tests/push.sl	2008-03-19 18:22:49 UTC (rev 320)
@@ -0,0 +1,4 @@
+ at a = @(1);
+$x = push(@a, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+println($x);
+println(@a);

Added: sleep/tests/warn2.sl
===================================================================
--- sleep/tests/warn2.sl	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/tests/warn2.sl	2008-03-19 18:22:49 UTC (rev 320)
@@ -0,0 +1,20 @@
+debug(7 | 34);
+
+sub foo
+{
+   local('$handle $exception @data');
+
+   try 
+   {
+      $handle = openf("jdfjsjkfjksfjksafjk");
+      @data = readAll($handle);
+      closef($handle);
+   }
+   catch $exception
+   {
+      warn("Couldn't open file: $exception");
+      println("This is me acting really kewlios");
+   }
+}
+
+foo();

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-19 17:20:14 UTC (rev 319)
+++ sleep/whatsnew.txt	2008-03-19 18:22:49 UTC (rev 320)
@@ -8,8 +8,7 @@
   to the same function.
 - added &readAsObject and &writeAsObject to read/write serialized
   Java objects (in lieu of sleep.runtime.Scalar objects)
-- updated &copy to accept either a singular scalar or a hash 
-  argument.
+- updated &copy to also copy scalars and hashes.
 - added &pushl and &popl for creating and removing local scope, 
   arguments to these functions are used to pass data between the
   current and resulting local scope.
@@ -21,6 +20,12 @@
   desired.
 - replace function can now handle empty arguments, it will use
   empty strings in their place.
+- added &warn to send a message to the script warning watcher 
+  installed within the script environment... 
+- true and false arguments are now optional in iff expressions:
+  iff(3 == 3) = 1
+  iff(3 != 3) = $null
+- &push can now push multiple arguments
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Wed Mar 19 19:37:39 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Wed, 19 Mar 2008 19:37:39 +0100
Subject: [Sleep-svn] r321 - in sleep/tests: . output
Message-ID: <200803191837.m2JIbdc1031758@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-19 19:37:39 +0100 (Wed, 19 Mar 2008)
New Revision: 321

Added:
   sleep/tests/output/pureinterop.sl
   sleep/tests/pureinterop.sl
Log:
checking in some unit tests yo.


Added: sleep/tests/output/pureinterop.sl
===================================================================
--- sleep/tests/output/pureinterop.sl	2008-03-19 18:22:49 UTC (rev 320)
+++ sleep/tests/output/pureinterop.sl	2008-03-19 18:37:39 UTC (rev 321)
@@ -0,0 +1,2 @@
+class sleep.runtime.Scalar
+class java.lang.String

Added: sleep/tests/pureinterop.sl
===================================================================
--- sleep/tests/pureinterop.sl	2008-03-19 18:22:49 UTC (rev 320)
+++ sleep/tests/pureinterop.sl	2008-03-19 18:37:39 UTC (rev 321)
@@ -0,0 +1,20 @@
+#
+# test out readAsObject and writeAsObject
+#
+
+$buffer1 = allocate(1024);
+writeObject($buffer1, "this is a string");
+closef($buffer1);
+
+$test1 = readAsObject($buffer1);
+println([$test1 getClass]);
+
+###############
+
+$buffer2 = allocate(1024);
+writeObject($buffer2, "this is a string");
+closef($buffer2);
+
+$test2 = readObject($buffer2);
+println([$test2 getClass]);
+



From rsmudge at mail.berlios.de  Wed Mar 19 20:26:37 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Wed, 19 Mar 2008 20:26:37 +0100
Subject: [Sleep-svn] r322 - in sleep: . src/sleep/bridges src/sleep/engine
	tests tests/output
Message-ID: <200803191926.m2JJQbUQ005113@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-19 20:26:37 +0100 (Wed, 19 Mar 2008)
New Revision: 322

Added:
   sleep/tests/connpipe.sl
   sleep/tests/output/connpipe.sl
   sleep/tests/output/scalar.sl
   sleep/tests/scalar.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/engine/ObjectUtilities.java
   sleep/whatsnew.txt
Log:
added scalar function


Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2008-03-19 19:26:37 UTC (rev 322)
@@ -112,6 +112,7 @@
         temp.put("&setField", this);
         temp.put("&typeOf", this);
         temp.put("&newInstance", this);
+        temp.put("&scalar", this);
 
         temp.put("&exit", this);
      
@@ -829,6 +830,10 @@
              }
           }
        }
+       else if (n.equals("&scalar"))
+       {
+          return ObjectUtilities.BuildScalar(true, BridgeUtilities.getObject(l));
+       }
        else if (n.equals("&newInstance"))
        {
           Scalar top = BridgeUtilities.getScalar(l);

Modified: sleep/src/sleep/engine/ObjectUtilities.java
===================================================================
--- sleep/src/sleep/engine/ObjectUtilities.java	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/src/sleep/engine/ObjectUtilities.java	2008-03-19 19:26:37 UTC (rev 322)
@@ -587,7 +587,6 @@
       {
          return SleepUtils.getScalar(value);
       }
-
    }
 
    /** Determines the primitive type of the specified array.  Primitive Sleep values (int, long, double) will return the appropriate Number.TYPE class.  This is an important distinction as Double.TYPE != new Double().getClass() */

Added: sleep/tests/connpipe.sl
===================================================================
--- sleep/tests/connpipe.sl	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/tests/connpipe.sl	2008-03-19 19:26:37 UTC (rev 322)
@@ -0,0 +1,23 @@
+#
+# some tests on connected pipes...
+# 
+
+$handle = fork({
+   while $text (readln($source))
+   {
+      println("A: read $text");
+   }
+
+   println("A: detected EOF!!!");
+   return "done!";
+});
+
+fork({
+   println($handle, 1);
+   println($handle, 2);
+   println($handle, 3);
+   printEOF($handle);
+
+}, \$handle);
+
+println("Done, received: " . wait($handle));

Added: sleep/tests/output/connpipe.sl
===================================================================
--- sleep/tests/output/connpipe.sl	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/tests/output/connpipe.sl	2008-03-19 19:26:37 UTC (rev 322)
@@ -0,0 +1,5 @@
+A: read 1
+A: read 2
+A: read 3
+A: detected EOF!!!
+Done, received: done!

Added: sleep/tests/output/scalar.sl
===================================================================
--- sleep/tests/output/scalar.sl	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/tests/output/scalar.sl	2008-03-19 19:26:37 UTC (rev 322)
@@ -0,0 +1,4 @@
+3
+6.4567
+[B at 554d32 and class [B
+this is a test and class java.lang.String

Added: sleep/tests/scalar.sl
===================================================================
--- sleep/tests/scalar.sl	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/tests/scalar.sl	2008-03-19 19:26:37 UTC (rev 322)
@@ -0,0 +1,19 @@
+#
+# force java types through scalar conversion process..
+#
+
+# no dice, can't do math on a java.lang.Double
+$double = [new Double: 3.4567];
+$a = 3 + $double;
+println($a);
+
+# this will work though.
+$a = 3 + scalar($double);
+println($a);
+
+# byte arrays got me down?
+$data = cast("this is a test", "b");
+println("$data and " . [$data getClass]);
+
+$d2 = scalar($data);
+println("$d2 and " . [$d2 getClass]);

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-19 18:37:39 UTC (rev 321)
+++ sleep/whatsnew.txt	2008-03-19 19:26:37 UTC (rev 322)
@@ -26,6 +26,8 @@
   iff(3 == 3) = 1
   iff(3 != 3) = $null
 - &push can now push multiple arguments
+- added &scalar($object) to force object through the Sleep scalar 
+  conversion process.  
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Fri Mar 21 23:28:24 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 21 Mar 2008 23:28:24 +0100
Subject: [Sleep-svn] r323 - in sleep: . src/sleep/bridges src/sleep/engine
	src/sleep/runtime tests tests/output
Message-ID: <200803212228.m2LMSOeG003566@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-21 23:28:23 +0100 (Fri, 21 Mar 2008)
New Revision: 323

Added:
   sleep/tests/foreachrecurse.sl
   sleep/tests/localstack.sl
   sleep/tests/output/foreachrecurse.sl
   sleep/tests/output/localstack.sl
   sleep/tests/output/pushl2.sl
   sleep/tests/output/pushl3.sl
   sleep/tests/pushl2.sl
   sleep/tests/pushl3.sl
Modified:
   sleep/src/sleep/bridges/BasicUtilities.java
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/engine/CallRequest.java
   sleep/src/sleep/runtime/ScriptVariables.java
   sleep/tests/inlineb.sl
   sleep/whatsnew.txt
Log:
..


Modified: sleep/src/sleep/bridges/BasicUtilities.java
===================================================================
--- sleep/src/sleep/bridges/BasicUtilities.java	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/src/sleep/bridges/BasicUtilities.java	2008-03-21 22:28:23 UTC (rev 323)
@@ -950,7 +950,14 @@
           }
           else if (n.equals("&popl"))
           {
-             vars.popLocalLevel();
+             if (vars.haveMoreLocals())
+             {
+                vars.popLocalLevel();
+             }
+             else
+             {
+                throw new RuntimeException("&popl: no more local frames exist"); 
+             }
           }
 
           if (!l.isEmpty())

Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/src/sleep/bridges/SleepClosure.java	2008-03-21 22:28:23 UTC (rev 323)
@@ -69,8 +69,8 @@
        return temp;
     }
 
-    /** saves the top level context */
-    private void saveToplevelContext(Stack _context, Variable localLevel)
+    /** saves the top level context; may throw an exception if an error is detected... be sure to move critical cleanup prior to this function. */
+    private void saveToplevelContext(Stack _context, LinkedList localLevel)
     {
        if (!_context.isEmpty())
        {
@@ -78,6 +78,10 @@
                                         this better be popped before use!!! */
           context.push(_context);
        }
+       else if (localLevel.size() != 1)
+       {
+          throw new RuntimeException((localLevel.size() - 1) + " unaccounted local stack frame(s) in " + toString() + " (perhaps you forgot to &popl?)");
+       }
     }
 
     /** returns the top most context stack... */
@@ -198,15 +202,17 @@
 
           if (toplevel.isEmpty()) /* a normal closure call */
           {
+             vars.beginToplevel(new LinkedList());
              vars.pushLocalLevel();
-             localLevel = vars.getLocalVariables();
           }
           else /* restoring from a coroutine */
           {
-             localLevel = (Variable)toplevel.pop();
-             vars.pushLocalLevel(localLevel);
+             LinkedList levels = (LinkedList)toplevel.pop();             
+             vars.beginToplevel(levels);
           }
 
+          localLevel = vars.getLocalVariables();
+
           //
           // initialize local variables...
           //
@@ -226,17 +232,18 @@
              temp = env.evaluateOldContext();
           }
 
-          saveToplevelContext(env.saveContext(), localLevel);
+          LinkedList phear = vars.leaveToplevel();        /* this will simultaneously save and remove all local scopes associated with
+                                                             the current closure context.  Very sexy */
+          vars.popClosureLevel();                         /* still have to do this manually, one day I need to refactor this state saving stuff */
 
-          vars.popLocalLevel();
-          vars.popClosureLevel();
-
           if (si.getScriptEnvironment().isCallCC())
           {
              SleepClosure tempc = SleepUtils.getFunctionFromScalar(si.getScriptEnvironment().getReturnValue(), si);
              tempc.putMetadata("continuation", SleepUtils.getScalar(this));
              si.getScriptEnvironment().flagReturn(si.getScriptEnvironment().getReturnValue(), ScriptEnvironment.FLOW_CONTROL_PASS); 
           }
+
+          saveToplevelContext(env.saveContext(), phear);  /* saves the top level context *pHEAR*; done last in case there is an error with this */
        }
 
        return temp;

Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/src/sleep/engine/CallRequest.java	2008-03-21 22:28:23 UTC (rev 323)
@@ -289,7 +289,8 @@
             int targs = sleep.bridges.BridgeUtilities.initLocalScope(vars, localLevel, getScriptEnvironment().getCurrentFrame());
             vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new sleep.bridges.ArgumentArray(targs, localLevel)), localLevel);
 
-            return inline.evaluate(getScriptEnvironment());
+            Scalar eval = inline.evaluate(getScriptEnvironment());
+            return eval;
          }
       }
    }

Modified: sleep/src/sleep/runtime/ScriptVariables.java
===================================================================
--- sleep/src/sleep/runtime/ScriptVariables.java	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/src/sleep/runtime/ScriptVariables.java	2008-03-21 22:28:23 UTC (rev 323)
@@ -65,10 +65,33 @@
   */
 public class ScriptVariables implements Serializable
 {
-    Variable    global;   /* global variables */
-    LinkedList  closure;  /* closure specific variables :) */
-    LinkedList  locals;   /* local variables */
+    protected Variable    global;   /* global variables */
+    protected LinkedList  closure;  /* closure specific variables :) */
+    protected LinkedList  locals;   /* local variables--can be stacked into a closure thanks to pushl, popl, and inline functions */
 
+    protected Stack       marks;    /* mark the beginning of a stack for fun and profit */
+
+    /** called when a closure is entered, allows an old stack of local scopes to be restored easily */
+    public void beginToplevel(LinkedList l)
+    {
+       marks.push(locals);
+       locals = l;
+    }
+    
+    /** called when a closure is exited, returns local var scope for later restoration if desired */
+    public LinkedList leaveToplevel()
+    {
+       LinkedList scopes = locals;
+       locals = (LinkedList)marks.pop(); 
+       return scopes;
+    }
+
+    /** used to check if other local scopes exist after the next pop */
+    public boolean haveMoreLocals()
+    {
+        return locals.size() > 1;
+    }
+
     /** Initializes this ScriptVariables container using a DefaultVariable object for default variable storage */
     public ScriptVariables()
     {
@@ -81,6 +104,7 @@
        global   = aVariableClass;
        closure  = new LinkedList();
        locals   = new LinkedList();
+       marks    = new Stack();
 
        pushLocalLevel();
     }

Added: sleep/tests/foreachrecurse.sl
===================================================================
--- sleep/tests/foreachrecurse.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/foreachrecurse.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,28 @@
+#
+# foreach iterators and regex bridge use a metadata hash to keep track of context sensitive data
+# this test assures that foreach loop handles recursion 
+
+global('$i');
+
+sub foo
+{
+   local('$var');
+   println("$i Enter foo!");
+
+   foreach $var ($1)
+   {
+      if ($var eq "icecream" && $2 is $null)
+      {
+         println("$i Calling next foo thingie");
+         $i = "  ";
+         foo($1, 1);
+         $i = "";
+      }
+      println("$i $var");
+   }
+
+   println("$i Exit foo!");
+}
+
+foo(@(1, 2, 3, "icecream", 4, 5, 6, 7));
+

Modified: sleep/tests/inlineb.sl
===================================================================
--- sleep/tests/inlineb.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/inlineb.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -12,7 +12,7 @@
 {
    local('$x');
    $x = 2;
-   $z = 10 * foo();
+   $z = 10 * foo(); # this is a bug and it is bad.
    println($z);
    return 10;
 }

Added: sleep/tests/localstack.sl
===================================================================
--- sleep/tests/localstack.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/localstack.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,42 @@
+#
+# checks that closures carry their local vars with themselves.
+#
+
+sub bar
+{
+   local('$buffer $func');
+   $buffer = allocate();
+   writeObject($buffer, $1);
+   closef($buffer);
+
+   println("Normal continuation:");
+   invoke($1);
+
+   println("Serialized Continuation");
+   $func = readObject($buffer);
+   invoke($func);
+}
+
+sub foo
+{
+   println("Begin foo");
+   local('$x');
+   $x = "a";
+   pushl();
+   local('$x');
+   $x = "b";
+   pushl();
+   local('$x');
+   $x = "c";
+   yield;        # pause execution
+   println($x);
+   popl();
+   println($x);
+   popl();
+   println($x);
+   println("End foo");
+}
+
+foo();
+bar(&foo);
+foo();

Added: sleep/tests/output/foreachrecurse.sl
===================================================================
--- sleep/tests/output/foreachrecurse.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/output/foreachrecurse.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,21 @@
+ Enter foo!
+ 1
+ 2
+ 3
+ Calling next foo thingie
+   Enter foo!
+   1
+   2
+   3
+   icecream
+   4
+   5
+   6
+   7
+   Exit foo!
+ icecream
+ 4
+ 5
+ 6
+ 7
+ Exit foo!

Added: sleep/tests/output/localstack.sl
===================================================================
--- sleep/tests/output/localstack.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/output/localstack.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,12 @@
+Begin foo
+Normal continuation:
+c
+b
+a
+End foo
+Serialized Continuation
+c
+b
+a
+End foo
+Begin foo

Added: sleep/tests/output/pushl2.sl
===================================================================
--- sleep/tests/output/pushl2.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/output/pushl2.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,3 @@
+Begin
+End
+Warning: 1 unaccounted local stack frame(s) in &closure[pushl2.sl:14-17]#1 (perhaps you forgot to &popl?) at pushl2.sl:20

Added: sleep/tests/output/pushl3.sl
===================================================================
--- sleep/tests/output/pushl3.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/output/pushl3.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1 @@
+Warning: &popl: no more local frames exist at pushl3.sl:9

Added: sleep/tests/pushl2.sl
===================================================================
--- sleep/tests/pushl2.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/pushl2.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,20 @@
+#
+# test for scope management...
+#
+
+inline bar
+{
+   pushl();
+   pushl();
+   popl($result => $a * $b);
+}
+
+sub foo
+{
+   local('$z'); 
+   println("Begin");
+   bar(300, 45);
+   println("End");
+}
+
+foo();

Added: sleep/tests/pushl3.sl
===================================================================
--- sleep/tests/pushl3.sl	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/tests/pushl3.sl	2008-03-21 22:28:23 UTC (rev 323)
@@ -0,0 +1,17 @@
+#
+# test for scope management...
+#
+
+inline bar
+{
+   pushl();
+   popl();
+   popl();
+}
+
+sub foo
+{
+   bar();
+}
+
+foo();

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-19 19:26:37 UTC (rev 322)
+++ sleep/whatsnew.txt	2008-03-21 22:28:23 UTC (rev 323)
@@ -16,8 +16,7 @@
   this is in line with how lambda, let, etc.. work.  pass a data
   structure (such as an array or hash) to have updateable shared
   values.
-- round function can now round to a certain number of places if
-  desired.
+- round function can now round to a desired number of places.
 - replace function can now handle empty arguments, it will use
   empty strings in their place.
 - added &warn to send a message to the script warning watcher 



From rsmudge at mail.berlios.de  Fri Mar 21 23:50:02 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 21 Mar 2008 23:50:02 +0100
Subject: [Sleep-svn] r324 - in sleep: . src/sleep/engine tests tests/output
Message-ID: <200803212250.m2LMo2He006738@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-21 23:50:00 +0100 (Fri, 21 Mar 2008)
New Revision: 324

Added:
   sleep/tests/inlined.sl
   sleep/tests/output/inlined.sl
Modified:
   sleep/src/sleep/engine/CallRequest.java
   sleep/whatsnew.txt
Log:
..


Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2008-03-21 22:28:23 UTC (rev 323)
+++ sleep/src/sleep/engine/CallRequest.java	2008-03-21 22:50:00 UTC (rev 324)
@@ -287,8 +287,12 @@
             Variable localLevel = vars.getLocalVariables();
 
             int targs = sleep.bridges.BridgeUtilities.initLocalScope(vars, localLevel, getScriptEnvironment().getCurrentFrame());
-            vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new sleep.bridges.ArgumentArray(targs, localLevel)), localLevel);
 
+            if ((targs - 1) > 0)
+            {
+               vars.setScalarLevel("@_", SleepUtils.getArrayScalar(new sleep.bridges.ArgumentArray(targs, localLevel)), localLevel);
+            }
+
             Scalar eval = inline.evaluate(getScriptEnvironment());
             return eval;
          }

Added: sleep/tests/inlined.sl
===================================================================
--- sleep/tests/inlined.sl	2008-03-21 22:28:23 UTC (rev 323)
+++ sleep/tests/inlined.sl	2008-03-21 22:50:00 UTC (rev 324)
@@ -0,0 +1,26 @@
+inline a
+{
+   println("@_: " . @_ . " and $1 and $2");
+}
+
+inline b
+{
+   println("@_: " . @_ . " and $x and $y");
+}
+
+sub foo
+{
+   a("apple", "bannana", "cow");
+   b($x => "x-ray", $y => "yak");
+}
+
+sub bar
+{
+   b($x => "x-ray", $y => "yak");
+   b($x => "XXX", $y => "YYY");
+   println("@_ is: " . @_ . " and $1 and $2");
+}
+
+foo("aa", "bb");
+bar("aaa", "bbb");
+

Added: sleep/tests/output/inlined.sl
===================================================================
--- sleep/tests/output/inlined.sl	2008-03-21 22:28:23 UTC (rev 323)
+++ sleep/tests/output/inlined.sl	2008-03-21 22:50:00 UTC (rev 324)
@@ -0,0 +1,5 @@
+ at _: @('apple', 'bannana', 'cow') and apple and bannana
+ at _: @('apple', 'bannana', 'cow') and x-ray and yak
+ at _: @('aaa', 'bbb') and x-ray and yak
+ at _: @('aaa', 'bbb') and XXX and YYY
+ at _ is: @('aaa', 'bbb') and aaa and bbb

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-21 22:28:23 UTC (rev 323)
+++ sleep/whatsnew.txt	2008-03-21 22:50:00 UTC (rev 324)
@@ -27,6 +27,10 @@
 - &push can now push multiple arguments
 - added &scalar($object) to force object through the Sleep scalar 
   conversion process.  
+- continuations now save multiple levels of local scope if 
+  necessary (this makes pushl/popl safe for yield/callcc)
+- inline functions will only mangle @_ if unnamed values are
+  passed.  Use $var => ... to pass a named value.
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Sat Mar 22 00:45:16 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 22 Mar 2008 00:45:16 +0100
Subject: [Sleep-svn] r325 - in sleep: . src/sleep/bridges src/sleep/runtime
	tests/output
Message-ID: <200803212345.m2LNjG5g005177@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-22 00:45:14 +0100 (Sat, 22 Mar 2008)
New Revision: 325

Modified:
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/runtime/ScriptInstance.java
   sleep/src/sleep/runtime/ScriptLoader.java
   sleep/src/sleep/runtime/ScriptVariables.java
   sleep/tests/output/cast.sl
   sleep/tests/output/convertds3.sl
   sleep/tests/output/forker.sl
   sleep/tests/output/scalar.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
..


Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/src/sleep/bridges/BasicIO.java	2008-03-21 23:45:14 UTC (rev 325)
@@ -482,7 +482,7 @@
           
              child.getScriptVariables().putScalar("$source", SleepUtils.getScalar(child_io));
 
-             Thread temp = new Thread(child, "fork of " + child.getRunnableBlock().getSourceLocation());
+             Thread temp = new Thread(child, "fork of " + child.getRunnableBlock().getRunnableCode().getSourceLocation());
 
              parent_io.setThread(temp);
              child_io.setThread(temp);

Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/src/sleep/bridges/SleepClosure.java	2008-03-21 23:45:14 UTC (rev 325)
@@ -11,7 +11,7 @@
 /** The Sleep Closure class.  This class represents a Function object that is also a self contained closure */
 public class SleepClosure implements Function
 {
-    private static int ccount = 0;
+    private static int ccount = -1;
     private int id;
 
     private class ClosureIterator implements Iterator

Modified: sleep/src/sleep/runtime/ScriptInstance.java
===================================================================
--- sleep/src/sleep/runtime/ScriptInstance.java	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/src/sleep/runtime/ScriptInstance.java	2008-03-21 23:45:14 UTC (rev 325)
@@ -33,6 +33,7 @@
 import sleep.bridges.DefaultEnvironment;
 import sleep.bridges.DefaultVariable;
 import sleep.bridges.RegexBridge;
+import sleep.bridges.SleepClosure;
 
 import sleep.interfaces.*;
 import sleep.error.*;
@@ -65,7 +66,7 @@
     protected ScriptVariables   variables;
 
     /** The compiled sleep code for this script, the ScriptLoader will set this value upon loading a script. */
-    protected Block             script;
+    protected SleepClosure      script;
 
     /** debug should be absolutely quiet, never fire any runtime warnings */
     public static final int DEBUG_NONE          = 0;
@@ -147,7 +148,7 @@
     /** Install a block as the compiled script code */ 
     public void installBlock(Block _script)
     {
-        script = _script;
+        script = new SleepClosure(this, _script);
     }
 
     /** Constructs a new script instance */
@@ -189,7 +190,7 @@
     /** Executes this script, should be done first thing once a script is loaded */
     public Scalar runScript()
     {
-        return SleepUtils.runCode(script, getScriptEnvironment());
+        return SleepUtils.runCode(script, getName(), this, new Stack());
     }
  
     /** A container for Sleep strack trace elements. */
@@ -373,7 +374,7 @@
     }
 
     /** Returns the compiled form of this script */
-    public Block getRunnableBlock()
+    public SleepClosure getRunnableBlock()
     {
         return script;
     }

Modified: sleep/src/sleep/runtime/ScriptLoader.java
===================================================================
--- sleep/src/sleep/runtime/ScriptLoader.java	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/src/sleep/runtime/ScriptLoader.java	2008-03-21 23:45:14 UTC (rev 325)
@@ -300,7 +300,7 @@
     public ScriptInstance loadScript(String name, Block code, Hashtable env)
     {
         ScriptInstance si = new ScriptInstance(env);
-        si.script = code;
+        si.installBlock(code);
         inProcessScript(name, si);
         return si;
     }

Modified: sleep/src/sleep/runtime/ScriptVariables.java
===================================================================
--- sleep/src/sleep/runtime/ScriptVariables.java	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/src/sleep/runtime/ScriptVariables.java	2008-03-21 23:45:14 UTC (rev 325)
@@ -106,7 +106,7 @@
        locals   = new LinkedList();
        marks    = new Stack();
 
-       pushLocalLevel();
+//       pushLocalLevel();
     }
 
     /** puts a scalar into the global scope */ 

Modified: sleep/tests/output/cast.sl
===================================================================
--- sleep/tests/output/cast.sl	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/tests/output/cast.sl	2008-03-21 23:45:14 UTC (rev 325)
@@ -1,2 +1,2 @@
-[Ljava.lang.CharSequence;@7e845a class [Ljava.lang.CharSequence;
-[Ljava.util.List;@e78c96 class [Ljava.util.List;
+[Ljava.lang.CharSequence;@815338 class [Ljava.lang.CharSequence;
+[Ljava.util.List;@6ed322 class [Ljava.util.List;

Modified: sleep/tests/output/convertds3.sl
===================================================================
--- sleep/tests/output/convertds3.sl	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/tests/output/convertds3.sl	2008-03-21 23:45:14 UTC (rev 325)
@@ -32,9 +32,9 @@
 int[] a
 Collection a
 Collection a
-Warning: there is no method that matches mar([Z at 9a9b65) in sleep.ArrayTest1 at convertds3.sl:36
-Warning: there is no method that matches mar([F at 502819) in sleep.ArrayTest1 at convertds3.sl:37
-Warning: there is no method that matches mar([Ljava.lang.Object;@78aa80) in sleep.ArrayTest1 at convertds3.sl:38
+Warning: there is no method that matches mar([Z at d33a6b) in sleep.ArrayTest1 at convertds3.sl:36
+Warning: there is no method that matches mar([F at a0864f) in sleep.ArrayTest1 at convertds3.sl:37
+Warning: there is no method that matches mar([Ljava.lang.Object;@d1e233) in sleep.ArrayTest1 at convertds3.sl:38
 int[] a
 Collection a
 Collection a

Modified: sleep/tests/output/forker.sl
===================================================================
--- sleep/tests/output/forker.sl	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/tests/output/forker.sl	2008-03-21 23:45:14 UTC (rev 325)
@@ -1,4 +1,4 @@
 Trace: &check('within fork') at forker.sl:9
-Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at c5e9c at forker.sl:8
+Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at 4ac216 at forker.sl:8
 Trace: &sleep(1000) at forker.sl:12
 Trace: &check('outside of fork') at forker.sl:14

Modified: sleep/tests/output/scalar.sl
===================================================================
--- sleep/tests/output/scalar.sl	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/tests/output/scalar.sl	2008-03-21 23:45:14 UTC (rev 325)
@@ -1,4 +1,4 @@
 3
 6.4567
-[B at 554d32 and class [B
+[B at a83a13 and class [B
 this is a test and class java.lang.String

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/tests/output/trace.sl	2008-03-21 23:45:14 UTC (rev 325)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at 7e845a println: 'this is a test'] at trace.sl:6
+Trace: [java.io.PrintStream at 383118 println: 'this is a test'] at trace.sl:6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at trace.sl:7
 81.0
-Trace: [java.io.PrintStream at 7e845a println: 81.0] at trace.sl:7
+Trace: [java.io.PrintStream at 383118 println: 81.0] at trace.sl:7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at trace.sl:8
 243.0
 Trace: &println(243.0) at trace.sl:8
 testing again...
-Trace: [java.io.PrintStream at 7e845a println: 'testing again...'] at trace.sl:10
+Trace: [java.io.PrintStream at 383118 println: 'testing again...'] at trace.sl:10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at trace.sl:12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at trace.sl:12
 Warning: variable '$list' not declared at trace.sl:12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/tests/output/wrong.sl	2008-03-21 23:45:14 UTC (rev 325)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at wrong.sl:6
 81.0
-Trace: [java.io.PrintStream at 81a197 println: 81.0] at wrong.sl:6
+Trace: [java.io.PrintStream at a61172 println: 81.0] at wrong.sl:6
 Trace: &casti(1, 'z') = true at wrong.sl:9
 true
-Trace: [java.io.PrintStream at 81a197 println: true] at wrong.sl:9
+Trace: [java.io.PrintStream at a61172 println: true] at wrong.sl:9
 Trace: &casti(0, 'z') = false at wrong.sl:10
 false
-Trace: [java.io.PrintStream at 81a197 println: false] at wrong.sl:10
+Trace: [java.io.PrintStream at a61172 println: false] at wrong.sl:10
 Trace: &casti(1, 'd') = 1.0 at wrong.sl:13
 1.0
-Trace: [java.io.PrintStream at 81a197 println: 1.0] at wrong.sl:13
+Trace: [java.io.PrintStream at a61172 println: 1.0] at wrong.sl:13
 Trace: &casti(1, 'b') = 1 at wrong.sl:16
 1
-Trace: [java.io.PrintStream at 81a197 println: 1] at wrong.sl:16
+Trace: [java.io.PrintStream at a61172 println: 1] at wrong.sl:16
 Trace: &casti(100, 'f') = 100.0 at wrong.sl:19
 100.0
-Trace: [java.io.PrintStream at 81a197 println: 100.0] at wrong.sl:19
+Trace: [java.io.PrintStream at a61172 println: 100.0] at wrong.sl:19
 Trace: &casti('b', 'c') = b at wrong.sl:22
 b
-Trace: [java.io.PrintStream at 81a197 println: b] at wrong.sl:22
+Trace: [java.io.PrintStream at a61172 println: b] at wrong.sl:22
 Trace: &casti(63, 'i') = 63 at wrong.sl:25
 63
-Trace: [java.io.PrintStream at 81a197 println: 63] at wrong.sl:25
+Trace: [java.io.PrintStream at a61172 println: 63] at wrong.sl:25
 this is a string y0
-Trace: [java.io.PrintStream at 81a197 println: 'this is a string y0'] at wrong.sl:28
+Trace: [java.io.PrintStream at a61172 println: 'this is a string y0'] at wrong.sl:28
 Trace: [new java.lang.StringBuilder: 'test'] = test at wrong.sl:31
 test
-Trace: [java.io.PrintStream at 81a197 println: test] at wrong.sl:31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at cf829d at wrong.sl:34
+Trace: [java.io.PrintStream at a61172 println: test] at wrong.sl:31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 96f4b5 at wrong.sl:34
 abcd
-Trace: [java.io.PrintStream at 81a197 println: [C at cf829d] at wrong.sl:34
+Trace: [java.io.PrintStream at a61172 println: [C at 96f4b5] at wrong.sl:34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-21 22:50:00 UTC (rev 324)
+++ sleep/whatsnew.txt	2008-03-21 23:45:14 UTC (rev 325)
@@ -1,4 +1,4 @@
-2.1-beta 21 
+2.1-beta 21  (21 Mar 08)
 ===========
 - assignment loops now record proper line number information for
   error reporting purposes.
@@ -31,6 +31,8 @@
   necessary (this makes pushl/popl safe for yield/callcc)
 - inline functions will only mangle @_ if unnamed values are
   passed.  Use $var => ... to pass a named value.
+- toplevel sleep scripts are now executed as a closure... this
+  allows callcc to work from the top level.
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Sat Mar 22 01:02:47 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Sat, 22 Mar 2008 01:02:47 +0100
Subject: [Sleep-svn] r326 - in sleep: docs src/sleep/bridges
	src/sleep/runtime
Message-ID: <200803220002.m2M02lNS026484@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-22 01:02:45 +0100 (Sat, 22 Mar 2008)
New Revision: 326

Modified:
   sleep/docs/sleeplang.html
   sleep/src/sleep/bridges/BasicIO.java
   sleep/src/sleep/runtime/ScriptInstance.java
Log:
blah...


Modified: sleep/docs/sleeplang.html
===================================================================
--- sleep/docs/sleeplang.html	2008-03-21 23:45:14 UTC (rev 325)
+++ sleep/docs/sleeplang.html	2008-03-22 00:02:45 UTC (rev 326)
@@ -458,13 +458,15 @@
 
 <pre>iff(comparison, expression_if_true, expression_if_false)</pre>
 
+<p>The second and third parameters for iff are optional.</p>
+
 <p>An example:</p>
 
-<pre>$value = "Calculation took" . $x . " second" . iff($x > 1, "s", "");</pre>
+<pre>$value = "Calculation took" . $x . " second" . iff($x > 1, "s");</pre>
 
 <p><var>$value</var> would be "Calculation took 2 seconds" if $x is equal to 2.  If <var>$x</var> was equal to 0 then 
 <var>$value</var> would be "Calculation took 1 second".  The iff example above checks if <var>$x</var> is greater than 1.  If it 
-is then "s" is returned.  Otherwise "" is returned.</p>
+is then "s" is returned.  Otherwise <var>$null</var> (the default when no false value is specified) is returned.</p>
 
 <h3>Assertions</h3>
 
@@ -2097,8 +2099,8 @@
  </tr>
  <tr>
   <td>@</td>
-  <td>copy(@|&)</td>
-  <td>returns an array with copies of the elements of @array or &generator</td>
+  <td>copy(@|&|$|%)</td>
+  <td>returns an array with copies of the elements of @array or &generator (can also copy hashes or individual scalars)</td>
  </tr>
  <tr>
   <td>@</td>
@@ -2568,6 +2570,11 @@
  </tr>
  <tr>
   <td>$</td>
+  <td>readAsObject([$handle])</td>
+  <td>reads a serialized Java object from the specified handle</td>
+ </tr>
+ <tr>
+  <td>$</td>
   <td>readb([$handle], n)</td>
   <td>reads n bytes from $handle.  If 0 bytes are read <var>$null</var> will be returned.</td>
  </tr>
@@ -2602,10 +2609,13 @@
   <td>using the specified data format string, calculates an estimated size of the data.</td>
  </tr>
  <tr>
+ <tr>
   <td>$</td>
-  <td>skip([$handle], n)</td>
-  <td>tells the handle to skip the next n bytes</td>
+  <td>skip($handle, n, [buffer size])</td>
+  <td>reads and discards up to n bytes from the specified handle.  this is useful for causing data to be read and processed without the expensive conversion process
+      to sleep strings (i.e. when one wants to digest or checksum a file)</td>
  </tr>
+ </tr>
  <tr>
   <td>@</td>
   <td>unpack('format', "string")</td>
@@ -2620,6 +2630,11 @@
  </tr>
  <tr>
   <td></td>
+  <td>writeAsObject([$handle], $scalar, ...)</td>
+  <td>serializes and writes Java objects to the specified handle</td>
+ </tr>
+ <tr>
+  <td></td>
   <td>writeb([$handle], "string")</td>
   <td>writes the byte data of "string" to $handle</td>
  </tr>
@@ -3038,17 +3053,32 @@
   <td>Creates a sleep closure backed instance of the specified java interface class (or classes if an array is used).</td>
  </tr>
  <tr>
+  <td></td>
+  <td>popl($key => $value, ...)</td>
+  <td>pops current local scope, returning to previous local scope.  Populates resulting scope with specified key/value pairs.</td>
+ </tr>
+ <tr>
   <td>@</td>
   <td>profile()</td>
   <td>returns the profiler statistics for the current script environment.  Profile statistics will only be collected if DEBUG_TRACE_CALLS (8) or DEBUG_TRACE_PROFILE_ONLY (24) is set.</td>
  </tr>
  <tr>
   <td></td>
+  <td>pushl($key => $value, ...)</td>
+  <td>creates a new local scope populated with specified key/value pairs.</td>
+ </tr>
+ <tr>
+  <td></td>
   <td>release($semaphore)</td>
   <td>increments the count value of the specified semaphore.</td>
  </tr>
  <tr>
   <td></td>
+  <td>scalar($object)</td>
+  <td>forces the specified object through the Java Object to Sleep scalar conversion process.</td>
+ </tr>
+ <tr>
+  <td></td>
   <td>setf('&func_name', &closure)</td>
   <td>sets the specified function to be bound to the specified closure.</td>
  </tr>
@@ -3094,6 +3124,11 @@
  </tr>
  <tr>
   <td></td>
+  <td>warn("message")</td>
+  <td>prints specified warning message using the install runtime warning watcher</td>
+ </tr> 
+ <tr>
+  <td></td>
   <td>watch('$x $y')</td>
   <td>A useful debug function for tracking variable changes.  parses the specified string and declares all variables in the string as "watch" variables.  Any attempt to update the container *referenced* by a watch variable will print out a warning.</td>
  </tr>
@@ -3883,7 +3918,7 @@
  <tr>
   <td>Z</td>
   <td>variable</td>
-  <td>read/write the specified number of characters (consumes the whole field)</td>
+  <td>read/write the specified number of characters (<consumes the whole field)</td>
  </tr>
 </table>
 

Modified: sleep/src/sleep/bridges/BasicIO.java
===================================================================
--- sleep/src/sleep/bridges/BasicIO.java	2008-03-21 23:45:14 UTC (rev 325)
+++ sleep/src/sleep/bridges/BasicIO.java	2008-03-22 00:02:45 UTC (rev 326)
@@ -482,7 +482,7 @@
           
              child.getScriptVariables().putScalar("$source", SleepUtils.getScalar(child_io));
 
-             Thread temp = new Thread(child, "fork of " + child.getRunnableBlock().getRunnableCode().getSourceLocation());
+             Thread temp = new Thread(child, "fork of " + child.getRunnableBlock().getSourceLocation());
 
              parent_io.setThread(temp);
              child_io.setThread(temp);

Modified: sleep/src/sleep/runtime/ScriptInstance.java
===================================================================
--- sleep/src/sleep/runtime/ScriptInstance.java	2008-03-21 23:45:14 UTC (rev 325)
+++ sleep/src/sleep/runtime/ScriptInstance.java	2008-03-22 00:02:45 UTC (rev 326)
@@ -373,12 +373,20 @@
         parent = p;
     }
 
-    /** Returns the compiled form of this script */
-    public SleepClosure getRunnableBlock()
+    /** Returns the compiled form of this script 
+     *  @see #getRunnableScript
+     */
+    public Block getRunnableBlock()
     {
-        return script;
+       return script.getRunnableCode();
     }
 
+    /** Returns this toplevel script as a Sleep closure. */
+    public SleepClosure getRunnableScript()
+    {
+       return script;
+    }
+
     /** Calls a subroutine/built-in function using this script. */
     public Scalar callFunction(String funcName, Stack parameters)
     {



From rsmudge at mail.berlios.de  Wed Mar 26 21:29:27 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Wed, 26 Mar 2008 21:29:27 +0100
Subject: [Sleep-svn] r327 - in sleep: . src/sleep/engine/atoms
Message-ID: <200803262029.m2QKTQkD020621@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-26 21:29:26 +0100 (Wed, 26 Mar 2008)
New Revision: 327

Modified:
   sleep/src/sleep/engine/atoms/Goto.java
   sleep/whatsnew.txt
Log:
fixed a memory leak... 


Modified: sleep/src/sleep/engine/atoms/Goto.java
===================================================================
--- sleep/src/sleep/engine/atoms/Goto.java	2008-03-22 00:02:45 UTC (rev 326)
+++ sleep/src/sleep/engine/atoms/Goto.java	2008-03-26 20:29:26 UTC (rev 327)
@@ -95,6 +95,11 @@
                                       the increment has to be executed separately so it is included */
             }
          }
+
+         if (e.markFrame() >= 0)
+         {
+            e.getCurrentFrame().clear(); /* prevent some memory leakage action */
+         }
       }
 
       if (e.getFlowControlRequest() == ScriptEnvironment.FLOW_CONTROL_BREAK)

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-22 00:02:45 UTC (rev 326)
+++ sleep/whatsnew.txt	2008-03-26 20:29:26 UTC (rev 327)
@@ -33,6 +33,7 @@
   passed.  Use $var => ... to pass a named value.
 - toplevel sleep scripts are now executed as a closure... this
   allows callcc to work from the top level.
+- fixed a memory leak caused by stack pollution within loops.  
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Thu Mar 27 22:53:31 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 27 Mar 2008 22:53:31 +0100
Subject: [Sleep-svn] r328 - in sleep: src/sleep/bridges src/sleep/engine
	src/sleep/runtime tests tests/output
Message-ID: <200803272153.m2RLrVd3000405@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-27 22:53:30 +0100 (Thu, 27 Mar 2008)
New Revision: 328

Added:
   sleep/tests/callccfork.sl
   sleep/tests/output/callccfork.sl
Modified:
   sleep/src/sleep/bridges/SleepClosure.java
   sleep/src/sleep/engine/Block.java
   sleep/src/sleep/engine/CallRequest.java
   sleep/src/sleep/runtime/ScriptInstance.java
   sleep/tests/output/callcc.sl
   sleep/tests/output/cast.sl
   sleep/tests/output/convertds3.sl
   sleep/tests/output/forker.sl
   sleep/tests/output/scalar.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
Log:
fixing some issues with callcc (and creating new ones in the process, oi vey)


Modified: sleep/src/sleep/bridges/SleepClosure.java
===================================================================
--- sleep/src/sleep/bridges/SleepClosure.java	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/src/sleep/bridges/SleepClosure.java	2008-03-27 21:53:30 UTC (rev 328)
@@ -240,6 +240,9 @@
           {
              SleepClosure tempc = SleepUtils.getFunctionFromScalar(si.getScriptEnvironment().getReturnValue(), si);
              tempc.putMetadata("continuation", SleepUtils.getScalar(this));
+             tempc.putMetadata("sourceLine", si.getScriptEnvironment().getCurrentFrame().pop());
+             tempc.putMetadata("sourceFile", si.getScriptEnvironment().getCurrentFrame().pop());
+
              si.getScriptEnvironment().flagReturn(si.getScriptEnvironment().getReturnValue(), ScriptEnvironment.FLOW_CONTROL_PASS); 
           }
 

Modified: sleep/src/sleep/engine/Block.java
===================================================================
--- sleep/src/sleep/engine/Block.java	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/src/sleep/engine/Block.java	2008-03-27 21:53:30 UTC (rev 328)
@@ -285,6 +285,12 @@
                  }
               }
 
+              if (environment.isCallCC())
+              {
+                 environment.getCurrentFrame().push(source);
+                 environment.getCurrentFrame().push(new Integer(temp.getLineNumber()));
+              }
+
               if (environment.isThrownValue())
               {
                  if (!environment.isExceptionHandlerInstalled())
@@ -312,29 +318,6 @@
                  return environment.getReturnValue(); /* we do this because the exception will get cleared and after that
                                                          there may be a return value */
               }
-              else if (environment.isPassControl())
-              {
-                 if (environment.markFrame() >= 0)
-                 {
-                    Object check = environment.getCurrentFrame().pop(); /* get rid of the function that we're going to callcc */	
-  
-                    if (check != environment.getReturnValue())
-                    {
-                       environment.getScriptInstance().fireWarning("bad callcc stack: " + SleepUtils.describe((Scalar)check) + " expected " + SleepUtils.describe(environment.getReturnValue()), temp.getLineNumber());
-                    }
-                 }
-
-                 Scalar callme = environment.getReturnValue();
-                 environment.flagReturn(null, ScriptEnvironment.FLOW_CONTROL_NONE);
-
-                 environment.CreateFrame(); /* create a frame because the function call will destroy it */
-
-                 /** pass the continuation as the first argument to the callcc'd closure */
-                 environment.getCurrentFrame().push(((SleepClosure)callme.objectValue()).getAndRemoveMetadata("continuation", null));
-
-                 CallRequest.ClosureCallRequest request = new CallRequest.ClosureCallRequest(environment, temp.getLineNumber(), callme, "CALLCC");
-                 request.CallFunction();
-              }
               else if (environment.isDebugInterrupt())
               {
                  environment.getScriptInstance().fireWarning(environment.getDebugString(), temp.getLineNumber());

Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/src/sleep/engine/CallRequest.java	2008-03-27 21:53:30 UTC (rev 328)
@@ -60,7 +60,7 @@
       ScriptEnvironment e = getScriptEnvironment();
       int mark = getScriptEnvironment().markFrame();
 
-      if (isDebug())
+      if (isDebug() && getLineNumber() != Integer.MIN_VALUE)
       {
          if (e.getScriptInstance().isProfileOnly())
          {
@@ -100,7 +100,7 @@
                 }
                 else if (e.isPassControl())
                 {
-                   e.getScriptInstance().fireWarning(formatCall(args) + " ... " + SleepUtils.describe(temp), getLineNumber(), true);
+                   e.getScriptInstance().fireWarning(formatCall(args) + " -goto- " + SleepUtils.describe(temp), getLineNumber(), true);
                 }
                 else if (SleepUtils.isEmptyScalar(temp))
                 {
@@ -155,6 +155,36 @@
 
       e.cleanFrame(mark);
       e.FrameResult(temp);
+
+      if (e.isPassControl())
+      {
+         Scalar callme = temp;
+
+         e.pushSource(((SleepClosure)callme.objectValue()).getAndRemoveMetadata("sourceFile", "<unknown>") + "");
+         int lno = ( (Integer)(  ((SleepClosure)callme.objectValue()).getAndRemoveMetadata("sourceLine", new Integer(-1))  ) ).intValue();
+
+         if (e.markFrame() >= 0)
+         {
+            Object check = e.getCurrentFrame().pop(); /* get rid of the function that we're going to callcc */
+
+            if (check != temp)
+            {
+               e.getScriptInstance().fireWarning("bad callcc stack: " + SleepUtils.describe((Scalar)check) + " expected " + SleepUtils.describe(temp), lno);
+            }
+         }
+
+         e.flagReturn(null, ScriptEnvironment.FLOW_CONTROL_NONE);
+
+         e.CreateFrame(); /* create a frame because the function call will destroy it */
+
+         /** pass the continuation as the first argument to the callcc'd closure */
+         e.getCurrentFrame().push(((SleepClosure)callme.objectValue()).getAndRemoveMetadata("continuation", null));
+
+         CallRequest.ClosureCallRequest request = new CallRequest.ClosureCallRequest(environment, lno, callme, "CALLCC");
+         request.CallFunction();
+
+         e.popSource();
+      }
    }
 
    /** execute a closure with all of the trimmings. */

Modified: sleep/src/sleep/runtime/ScriptInstance.java
===================================================================
--- sleep/src/sleep/runtime/ScriptInstance.java	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/src/sleep/runtime/ScriptInstance.java	2008-03-27 21:53:30 UTC (rev 328)
@@ -25,6 +25,7 @@
 
 import sleep.runtime.Scalar;
 import sleep.engine.Block;
+import sleep.engine.CallRequest;
 
 import sleep.bridges.BasicNumbers;
 import sleep.bridges.BasicStrings;
@@ -50,7 +51,7 @@
 public class ScriptInstance implements Serializable, Runnable
 {
     /** the name of this script */
-    protected String  name  = "Script";
+    protected String  name   = "Script";
 
     /** true by default, indicates wether or not the script is loaded.  Once unloaded this variable must be flagged to false so
         the bridges know data related to this script is stale */
@@ -190,7 +191,26 @@
     /** Executes this script, should be done first thing once a script is loaded */
     public Scalar runScript()
     {
-        return SleepUtils.runCode(script, getName(), this, new Stack());
+       environment.pushSource(getName());
+
+       /* a place to hold our result... */
+       environment.CreateFrame();
+
+       /* this stuff is a necessity for calling into the closure */
+       environment.CreateFrame();
+ //      CallRequest.ClosureCallRequest request = new CallRequest.ClosureCallRequest(environment, script.getRunnableCode().getLowLineNumber(), SleepUtils.getScalar(script), null);
+       CallRequest.ClosureCallRequest request = new CallRequest.ClosureCallRequest(environment, Integer.MIN_VALUE, SleepUtils.getScalar(script), null);
+       request.CallFunction();        
+
+       /* get the return value */
+       Scalar rv = environment.getCurrentFrame().isEmpty() ? SleepUtils.getEmptyScalar() : (Scalar)environment.getCurrentFrame().pop();
+
+       /* handle the cleanup */
+       environment.KillFrame();
+       environment.popSource();
+
+
+       return rv;
     }
  
     /** A container for Sleep strack trace elements. */

Added: sleep/tests/callccfork.sl
===================================================================
--- sleep/tests/callccfork.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/callccfork.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -0,0 +1,22 @@
+#
+# ensure that callcc works from a fork...
+#
+
+debug(15);
+
+sub func
+{
+   println("Begin!");
+   callcc 
+   {
+      println("Inside of callcc function");
+      return "pHEAR";
+   };
+   println("Should never happen");
+}
+
+global('$handle $value');
+
+$handle = fork(&func);
+$value  = wait($handle);
+println($value);

Modified: sleep/tests/output/callcc.sl
===================================================================
--- sleep/tests/output/callcc.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/callcc.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -1,13 +1,13 @@
 Trace: &global('$value') at callcc.sl:18
 foo start: &closure[callcc.sl:9-15]#1
 Trace: &println('foo start: &closure[callcc.sl:9-15]#1') at callcc.sl:9
-Trace: &foo() ... &closure[callcc.sl:11-13]#2 at callcc.sl:19
+Trace: &foo() -goto- &closure[callcc.sl:11-13]#2 at callcc.sl:19
 Hello Continuation: &closure[callcc.sl:9-15]#1
 Trace: &println('Hello Continuation: &closure[callcc.sl:9-15]#1') at callcc.sl:11
 foo postcc - from anonymous function!
 Trace: &println('foo postcc - from anonymous function!') at callcc.sl:15
 Trace: [&closure[callcc.sl:9-15]#1: 'from anonymous function!'] at callcc.sl:12
-Trace: [&closure[callcc.sl:11-13]#2 CALLCC: &closure[callcc.sl:9-15]#1] = 'this is foo's new value' at callcc.sl:19
+Trace: [&closure[callcc.sl:11-13]#2 CALLCC: &closure[callcc.sl:9-15]#1] = 'this is foo's new value' at callcc.sl:10
 Does this ever happen? this is foo's new value
 Trace: &println('Does this ever happen? this is foo's new value') at callcc.sl:20
 Trace: &debug(7) = 7 at callcc.sl:22

Added: sleep/tests/output/callccfork.sl
===================================================================
--- sleep/tests/output/callccfork.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/callccfork.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -0,0 +1,10 @@
+Trace: &global('$handle $value') at callccfork.sl:18
+Begin!
+Trace: &println('Begin!') at callccfork.sl:9
+Inside of callcc function
+Trace: &println('Inside of callcc function') at callccfork.sl:12
+Trace: [&closure[callccfork.sl:12-13]#3 CALLCC: &closure[callccfork.sl:9-15]#2] = 'pHEAR' at callccfork.sl:10
+Trace: &fork(&closure[callccfork.sl:9-15]#1) = sleep.bridges.io.IOObject at 402af3 at callccfork.sl:20
+Trace: &wait(sleep.bridges.io.IOObject at 402af3) = 'pHEAR' at callccfork.sl:21
+pHEAR
+Trace: &println('pHEAR') at callccfork.sl:22

Modified: sleep/tests/output/cast.sl
===================================================================
--- sleep/tests/output/cast.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/cast.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -1,2 +1,2 @@
-[Ljava.lang.CharSequence;@815338 class [Ljava.lang.CharSequence;
-[Ljava.util.List;@6ed322 class [Ljava.util.List;
+[Ljava.lang.CharSequence;@5691e class [Ljava.lang.CharSequence;
+[Ljava.util.List;@d49247 class [Ljava.util.List;

Modified: sleep/tests/output/convertds3.sl
===================================================================
--- sleep/tests/output/convertds3.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/convertds3.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -32,9 +32,9 @@
 int[] a
 Collection a
 Collection a
-Warning: there is no method that matches mar([Z at d33a6b) in sleep.ArrayTest1 at convertds3.sl:36
-Warning: there is no method that matches mar([F at a0864f) in sleep.ArrayTest1 at convertds3.sl:37
-Warning: there is no method that matches mar([Ljava.lang.Object;@d1e233) in sleep.ArrayTest1 at convertds3.sl:38
+Warning: there is no method that matches mar([Z at b01afa) in sleep.ArrayTest1 at convertds3.sl:36
+Warning: there is no method that matches mar([F at bb494b) in sleep.ArrayTest1 at convertds3.sl:37
+Warning: there is no method that matches mar([Ljava.lang.Object;@c8efd1) in sleep.ArrayTest1 at convertds3.sl:38
 int[] a
 Collection a
 Collection a

Modified: sleep/tests/output/forker.sl
===================================================================
--- sleep/tests/output/forker.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/forker.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -1,4 +1,4 @@
 Trace: &check('within fork') at forker.sl:9
-Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at 4ac216 at forker.sl:8
+Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at b301f2 at forker.sl:8
 Trace: &sleep(1000) at forker.sl:12
 Trace: &check('outside of fork') at forker.sl:14

Modified: sleep/tests/output/scalar.sl
===================================================================
--- sleep/tests/output/scalar.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/scalar.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -1,4 +1,4 @@
 3
 6.4567
-[B at a83a13 and class [B
+[B at 922804 and class [B
 this is a test and class java.lang.String

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/trace.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at 383118 println: 'this is a test'] at trace.sl:6
+Trace: [java.io.PrintStream at 716cb7 println: 'this is a test'] at trace.sl:6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at trace.sl:7
 81.0
-Trace: [java.io.PrintStream at 383118 println: 81.0] at trace.sl:7
+Trace: [java.io.PrintStream at 716cb7 println: 81.0] at trace.sl:7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at trace.sl:8
 243.0
 Trace: &println(243.0) at trace.sl:8
 testing again...
-Trace: [java.io.PrintStream at 383118 println: 'testing again...'] at trace.sl:10
+Trace: [java.io.PrintStream at 716cb7 println: 'testing again...'] at trace.sl:10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at trace.sl:12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at trace.sl:12
 Warning: variable '$list' not declared at trace.sl:12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2008-03-26 20:29:26 UTC (rev 327)
+++ sleep/tests/output/wrong.sl	2008-03-27 21:53:30 UTC (rev 328)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at wrong.sl:6
 81.0
-Trace: [java.io.PrintStream at a61172 println: 81.0] at wrong.sl:6
+Trace: [java.io.PrintStream at 8330bf println: 81.0] at wrong.sl:6
 Trace: &casti(1, 'z') = true at wrong.sl:9
 true
-Trace: [java.io.PrintStream at a61172 println: true] at wrong.sl:9
+Trace: [java.io.PrintStream at 8330bf println: true] at wrong.sl:9
 Trace: &casti(0, 'z') = false at wrong.sl:10
 false
-Trace: [java.io.PrintStream at a61172 println: false] at wrong.sl:10
+Trace: [java.io.PrintStream at 8330bf println: false] at wrong.sl:10
 Trace: &casti(1, 'd') = 1.0 at wrong.sl:13
 1.0
-Trace: [java.io.PrintStream at a61172 println: 1.0] at wrong.sl:13
+Trace: [java.io.PrintStream at 8330bf println: 1.0] at wrong.sl:13
 Trace: &casti(1, 'b') = 1 at wrong.sl:16
 1
-Trace: [java.io.PrintStream at a61172 println: 1] at wrong.sl:16
+Trace: [java.io.PrintStream at 8330bf println: 1] at wrong.sl:16
 Trace: &casti(100, 'f') = 100.0 at wrong.sl:19
 100.0
-Trace: [java.io.PrintStream at a61172 println: 100.0] at wrong.sl:19
+Trace: [java.io.PrintStream at 8330bf println: 100.0] at wrong.sl:19
 Trace: &casti('b', 'c') = b at wrong.sl:22
 b
-Trace: [java.io.PrintStream at a61172 println: b] at wrong.sl:22
+Trace: [java.io.PrintStream at 8330bf println: b] at wrong.sl:22
 Trace: &casti(63, 'i') = 63 at wrong.sl:25
 63
-Trace: [java.io.PrintStream at a61172 println: 63] at wrong.sl:25
+Trace: [java.io.PrintStream at 8330bf println: 63] at wrong.sl:25
 this is a string y0
-Trace: [java.io.PrintStream at a61172 println: 'this is a string y0'] at wrong.sl:28
+Trace: [java.io.PrintStream at 8330bf println: 'this is a string y0'] at wrong.sl:28
 Trace: [new java.lang.StringBuilder: 'test'] = test at wrong.sl:31
 test
-Trace: [java.io.PrintStream at a61172 println: test] at wrong.sl:31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 96f4b5 at wrong.sl:34
+Trace: [java.io.PrintStream at 8330bf println: test] at wrong.sl:31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 57ea4a at wrong.sl:34
 abcd
-Trace: [java.io.PrintStream at a61172 println: [C at 96f4b5] at wrong.sl:34
+Trace: [java.io.PrintStream at 8330bf println: [C at 57ea4a] at wrong.sl:34



From rsmudge at mail.berlios.de  Thu Mar 27 23:03:14 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Thu, 27 Mar 2008 23:03:14 +0100
Subject: [Sleep-svn] r329 - in sleep: . src/sleep/engine
Message-ID: <200803272203.m2RM3EN1001352@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-27 23:03:14 +0100 (Thu, 27 Mar 2008)
New Revision: 329

Modified:
   sleep/src/sleep/engine/CallRequest.java
   sleep/whatsnew.txt
Log:
..


Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2008-03-27 21:53:30 UTC (rev 328)
+++ sleep/src/sleep/engine/CallRequest.java	2008-03-27 22:03:14 UTC (rev 329)
@@ -156,6 +156,11 @@
       e.cleanFrame(mark);
       e.FrameResult(temp);
 
+      /* if you're digging here then you've discovered my dirty little secret.  My continuation's continue to possess Java stack frames until
+         something decides to return.  Moving this check into Block.java overcomes this limitation except it makes it so continuations don't work
+         in code invoked outside of a Call instruction enclosed within Block.java.  If this is an issue email me and I'll look at better ways to
+         eliminate this problem. */
+
       if (e.isPassControl())
       {
          Scalar callme = temp;

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-27 21:53:30 UTC (rev 328)
+++ sleep/whatsnew.txt	2008-03-27 22:03:14 UTC (rev 329)
@@ -34,6 +34,8 @@
 - toplevel sleep scripts are now executed as a closure... this
   allows callcc to work from the top level.
 - fixed a memory leak caused by stack pollution within loops.  
+- callcc can now be used within fork to take control of the fork
+  and eventually return a value (retrievable via &wait)
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Fri Mar 28 00:59:04 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 28 Mar 2008 00:59:04 +0100
Subject: [Sleep-svn] r330 - in sleep: . src/sleep/engine tests tests/output
Message-ID: <200803272359.m2RNx4T6019717@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-28 00:59:04 +0100 (Fri, 28 Mar 2008)
New Revision: 330

Added:
   sleep/tests/callccfreeze.sl
   sleep/tests/output/callccfreeze.sl
Modified:
   sleep/readme.txt
   sleep/src/sleep/engine/Block.java
   sleep/whatsnew.txt
Log:
fixed an infinite loop issue in callcc



Modified: sleep/readme.txt
===================================================================
--- sleep/readme.txt	2008-03-27 22:03:14 UTC (rev 329)
+++ sleep/readme.txt	2008-03-27 23:59:04 UTC (rev 330)
@@ -1,5 +1,5 @@
  ------- -------------------- ---------   ---------------  ------- ---------
-Sleep - 2.1 beta 20 - README   
+Sleep - 2.1 beta 21 - README   
 -  ------------- -------- -   ---------------- --       -    -     -     - - -
 
 "You got the language, all you need now is the O'Reilly book".  That is

Modified: sleep/src/sleep/engine/Block.java
===================================================================
--- sleep/src/sleep/engine/Block.java	2008-03-27 22:03:14 UTC (rev 329)
+++ sleep/src/sleep/engine/Block.java	2008-03-27 23:59:04 UTC (rev 330)
@@ -278,10 +278,7 @@
                  }
                  else
                  {
-                    if (temp.next != null)
-                    {
-                       environment.addToContext(this, temp.next);
-                    }
+                    environment.addToContext(this, temp.next);
                  }
               }
 

Added: sleep/tests/callccfreeze.sl
===================================================================
--- sleep/tests/callccfreeze.sl	2008-03-27 22:03:14 UTC (rev 329)
+++ sleep/tests/callccfreeze.sl	2008-03-27 23:59:04 UTC (rev 330)
@@ -0,0 +1,11 @@
+debug(15);
+
+sub foo
+{
+   callcc 
+   {
+      invoke($1);
+   };
+}
+
+foo();

Added: sleep/tests/output/callccfreeze.sl
===================================================================
--- sleep/tests/output/callccfreeze.sl	2008-03-27 22:03:14 UTC (rev 329)
+++ sleep/tests/output/callccfreeze.sl	2008-03-27 23:59:04 UTC (rev 330)
@@ -0,0 +1,3 @@
+Trace: &foo() -goto- &closure[callccfreeze.sl:7]#2 at callccfreeze.sl:11
+Trace: &invoke(&closure[callccfreeze.sl:5-6]#1) at callccfreeze.sl:7
+Trace: [&closure[callccfreeze.sl:7]#2 CALLCC: &closure[callccfreeze.sl:5-6]#1] at callccfreeze.sl:5

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-27 22:03:14 UTC (rev 329)
+++ sleep/whatsnew.txt	2008-03-27 23:59:04 UTC (rev 330)
@@ -36,6 +36,8 @@
 - fixed a memory leak caused by stack pollution within loops.  
 - callcc can now be used within fork to take control of the fork
   and eventually return a value (retrievable via &wait)
+- fixed a callcc corner case that could lead to an infinite loop
+  in the interpreter
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Fri Mar 28 05:00:39 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 28 Mar 2008 05:00:39 +0100
Subject: [Sleep-svn] r331 - in sleep: . src/sleep/engine src/sleep/runtime
	tests/output
Message-ID: <200803280400.m2S40d0x019529@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-28 05:00:30 +0100 (Fri, 28 Mar 2008)
New Revision: 331

Modified:
   sleep/src/sleep/engine/CallRequest.java
   sleep/src/sleep/runtime/ScriptEnvironment.java
   sleep/src/sleep/runtime/ScriptInstance.java
   sleep/src/sleep/runtime/SleepUtils.java
   sleep/tests/output/callccfork.sl
   sleep/tests/output/cast.sl
   sleep/tests/output/convertds3.sl
   sleep/tests/output/forker.sl
   sleep/tests/output/scalar.sl
   sleep/tests/output/trace.sl
   sleep/tests/output/wrong.sl
   sleep/whatsnew.txt
Log:
..


Modified: sleep/src/sleep/engine/CallRequest.java
===================================================================
--- sleep/src/sleep/engine/CallRequest.java	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/src/sleep/engine/CallRequest.java	2008-03-28 04:00:30 UTC (rev 331)
@@ -8,9 +8,15 @@
 import sleep.engine.types.*;
 import sleep.bridges.SleepClosure;
 
-/** this class encapsulates a function call request. sleep has so many reasons, places, and ways to call functions.
-    this class helps to avoid duplicate code and manage the complexity of Sleep's myriad of profiling, tracing, and error reporting
-    options. */
+/** This class encapsulates a function call request.  Sleep has too many reasons, places, and ways to call functions.
+ *  This class helps to avoid duplicate code and manage the complexity of Sleep's myriad of profiling, tracing, and error reporting
+ *  options. 
+ * 
+ *  This functionality is encapsulated (along with necessary setup/teardown that you don't want to touch) within 
+ *  {@linkplain sleep.runtime.SleepUtils#runCode(sleep.engine.Block, sleep.runtime.ScriptEnvironment) SleepUtils.runCode()}.
+ *
+ *  @see sleep.runtime.SleepUtils
+ */
 public abstract class CallRequest
 {
    protected ScriptEnvironment environment;

Modified: sleep/src/sleep/runtime/ScriptEnvironment.java
===================================================================
--- sleep/src/sleep/runtime/ScriptEnvironment.java	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/src/sleep/runtime/ScriptEnvironment.java	2008-03-28 04:00:30 UTC (rev 331)
@@ -621,6 +621,25 @@
        findex--;
     }
     
+    public void CreateFrame(Stack frame)
+    {
+       if (frame == null) 
+       { 
+          frame = new Stack(); 
+       }
+
+       if ((findex + 1) >= frames.size())
+       {
+          frames.add(frame);
+       } 
+       else
+       {
+          frames.set(findex + 1, frame);
+       }
+
+       findex++;
+    }
+
     public void CreateFrame()
     {
        if ((findex + 1) >= frames.size())

Modified: sleep/src/sleep/runtime/ScriptInstance.java
===================================================================
--- sleep/src/sleep/runtime/ScriptInstance.java	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/src/sleep/runtime/ScriptInstance.java	2008-03-28 04:00:30 UTC (rev 331)
@@ -191,26 +191,7 @@
     /** Executes this script, should be done first thing once a script is loaded */
     public Scalar runScript()
     {
-       environment.pushSource(getName());
-
-       /* a place to hold our result... */
-       environment.CreateFrame();
-
-       /* this stuff is a necessity for calling into the closure */
-       environment.CreateFrame();
- //      CallRequest.ClosureCallRequest request = new CallRequest.ClosureCallRequest(environment, script.getRunnableCode().getLowLineNumber(), SleepUtils.getScalar(script), null);
-       CallRequest.ClosureCallRequest request = new CallRequest.ClosureCallRequest(environment, Integer.MIN_VALUE, SleepUtils.getScalar(script), null);
-       request.CallFunction();        
-
-       /* get the return value */
-       Scalar rv = environment.getCurrentFrame().isEmpty() ? SleepUtils.getEmptyScalar() : (Scalar)environment.getCurrentFrame().pop();
-
-       /* handle the cleanup */
-       environment.KillFrame();
-       environment.popSource();
-
-
-       return rv;
+       return SleepUtils.runCode(script, null, this, null);
     }
  
     /** A container for Sleep strack trace elements. */

Modified: sleep/src/sleep/runtime/SleepUtils.java
===================================================================
--- sleep/src/sleep/runtime/SleepUtils.java	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/src/sleep/runtime/SleepUtils.java	2008-03-28 04:00:30 UTC (rev 331)
@@ -26,7 +26,7 @@
 public class SleepUtils
 {
    /** A date stamp of this Sleep release in YYYYMMDD format */
-   public static final int    SLEEP_RELEASE = 20071112;
+   public static final int    SLEEP_RELEASE = 20080328;
 
    /** A string description of this Sleep release */
    public static final String SLEEP_VERSION = "Sleep 2.1";
@@ -62,28 +62,59 @@
         }
      }
 
-   /** "safely" run a snippet of code.  The main thing this function does is clear the return value 
-    *  before returning the value to the caller.  This is important because the return value (if there 
-    *  is one) would not get cleared otherwise.  Kind of important.
+   /** utility function to handle the setup/teardown for a call request */
+   private static Scalar runCode(CallRequest request, ScriptInstance script, Stack locals)
+   {
+       ScriptEnvironment environment = script.getScriptEnvironment();
+
+       synchronized (environment.getScriptVariables())
+       {
+          environment.pushSource(script.getName());
+
+          environment.CreateFrame(); /* this frame holds the result */
+          environment.CreateFrame(locals); /* dump the local vars here plz */
+
+          request.CallFunction();
+
+          /* get the return value */   
+          Scalar rv = environment.getCurrentFrame().isEmpty() ? SleepUtils.getEmptyScalar() : (Scalar)environment.getCurrentFrame().pop();
+
+          /* handle the cleanup */
+          environment.KillFrame();
+          environment.popSource();
+ 
+          /* necessary since we're doing this from a toplevel */
+          environment.resetEnvironment();
+
+          return rv;
+       }
+   }
+
+   /** "safely" run a snippet of code.  The snippet is executed as if it was an inline function.
     *  @param code the block of code we want to execute
     *  @param env the environment to run the code in
     *  @return the scalar returned by the executed code (if their is a return value), null otherwise.
     */
    public static Scalar runCode(Block code, ScriptEnvironment env)
    {
-       synchronized (env.getScriptVariables())
-       {
-          Scalar temp = code.evaluate(env);
-          env.resetEnvironment();             /* if we're going to call a function that returns
-                                                 something then we are obligated to clear its return
-                                                 value when its done running... */
-          return temp;
-       }
+       CallRequest request = new CallRequest.InlineCallRequest(env, Integer.MIN_VALUE, "eval", code);
+       return runCode(request, env.getScriptInstance(), null);
    }
 
-   /** "safely" runs a "Function" of code.  The main thing this method does is clear the return value 
-    *  before returning the value to the caller.  This is important because the return value (if there 
-    *  is one) would not get cleared otherwise.  Kind of important.
+   /** "safely" runs a closure.  
+    *  @param closure the SleepClosure object we want to execute
+    *  @param message the <var>$0</var> parameter (aka the message) to pass to this closure object
+    *  @param script the script we want to execute the function within
+    *  @param locals a stack of scalars representing the arguments to this Function (first arg on top)
+    *  @return the scalar returned by the executed code or the sleep empty scalar if there is no return value (never returns null)
+    */
+   public static Scalar runCode(SleepClosure closure, String message, ScriptInstance script, Stack locals)
+   {
+       CallRequest request = new CallRequest.ClosureCallRequest(script.getScriptEnvironment(), Integer.MIN_VALUE, SleepUtils.getScalar(closure), message);
+       return runCode(request, script, locals);
+   }
+
+   /** "safely" runs a "Function" of code.  
     *  @param func the Function object we want to execute
     *  @param name the name of the function we are executing (can be anything, depending on the function object)
     *  @param script the script we want to execute the function within
@@ -92,53 +123,36 @@
     */
    public static Scalar runCode(Function func, String name, ScriptInstance script, Stack locals)
    {
-       Scalar temp = func.evaluate(name, script, locals);
-       script.getScriptEnvironment().resetEnvironment(); /* if we're going to call a function that returns
-                                                            something then we are obligated to clear its return
-                                                            value when its done running... */
-       if (temp == null)
-          return SleepUtils.getEmptyScalar();
-
-       return temp;
+       CallRequest request = new CallRequest.FunctionCallRequest(script.getScriptEnvironment(), Integer.MIN_VALUE, name, func);
+       return runCode(request, script, locals);
    }
  
    /** "safely" run a snippet of code.  The main thing this function does is clear the return value 
     *  before returning the value to the caller.  This is important because the return value (if there 
     *  is one) would not get cleared otherwise.  Kind of important.
-    *  @param owner the owning script instance of this block of code
+    *  @param script the owning script instance of this block of code
     *  @param code the block of code we want to execute
-    *  @param locals a hashmap containing Scalar objects that should be installed into the local scope.  The keys should be Strings representing the $names for each of the Scalar variables.
+    *  @param vars a hashmap containing Scalar objects that should be installed into the local scope.  The keys should be Strings representing the $names for each of the Scalar variables. This value can be null.
     *  @return the scalar returned by the executed code (if their is a return value), null otherwise.
     */
-   public static Scalar runCode(ScriptInstance owner, Block code, HashMap locals)
+   public static Scalar runCode(ScriptInstance script, Block code, HashMap vars)
    {
-       synchronized (owner.getScriptVariables())
+       Stack locals = new Stack();
+
+       /* turn our hashmap into some acceptable local variables */
+       if (vars != null)
        {
-          ScriptVariables vars = owner.getScriptVariables();
-
-          vars.pushLocalLevel();
-
-          Variable localLevel = vars.getLocalVariables();
-
-          if (locals != null)
+          Iterator i = vars.entrySet().iterator();
+          while (i.hasNext())
           {
-             Iterator i = locals.entrySet().iterator();
-             while (i.hasNext())
-             {
-                Map.Entry value = (Map.Entry)i.next();
-                localLevel.putScalar(value.getKey().toString(), (Scalar)value.getValue());
-             }
+             Map.Entry value = (Map.Entry)i.next();
+             locals.push(new KeyValuePair(SleepUtils.getScalar(value.getKey().toString()), (Scalar)value.getValue()));
           }
-
-          //
-          // execute the block of code
-          //
-          Scalar value = SleepUtils.runCode(code, owner.getScriptEnvironment());
-
-          vars.popLocalLevel();
-         
-          return value;
        }
+    
+       /* do the actual call yo */
+       CallRequest request = new CallRequest.InlineCallRequest(script.getScriptEnvironment(), Integer.MIN_VALUE, "eval", code);
+       return runCode(request, script, locals);
    }
 
    /** "safely" run a snippet of code.  The main thing this function does is clear the return value 

Modified: sleep/tests/output/callccfork.sl
===================================================================
--- sleep/tests/output/callccfork.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/callccfork.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -4,7 +4,7 @@
 Inside of callcc function
 Trace: &println('Inside of callcc function') at callccfork.sl:12
 Trace: [&closure[callccfork.sl:12-13]#3 CALLCC: &closure[callccfork.sl:9-15]#2] = 'pHEAR' at callccfork.sl:10
-Trace: &fork(&closure[callccfork.sl:9-15]#1) = sleep.bridges.io.IOObject at 402af3 at callccfork.sl:20
-Trace: &wait(sleep.bridges.io.IOObject at 402af3) = 'pHEAR' at callccfork.sl:21
+Trace: &fork(&closure[callccfork.sl:9-15]#1) = sleep.bridges.io.IOObject at d88db7 at callccfork.sl:20
+Trace: &wait(sleep.bridges.io.IOObject at d88db7) = 'pHEAR' at callccfork.sl:21
 pHEAR
 Trace: &println('pHEAR') at callccfork.sl:22

Modified: sleep/tests/output/cast.sl
===================================================================
--- sleep/tests/output/cast.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/cast.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -1,2 +1,2 @@
-[Ljava.lang.CharSequence;@5691e class [Ljava.lang.CharSequence;
-[Ljava.util.List;@d49247 class [Ljava.util.List;
+[Ljava.lang.CharSequence;@124746 class [Ljava.lang.CharSequence;
+[Ljava.util.List;@8b8914 class [Ljava.util.List;

Modified: sleep/tests/output/convertds3.sl
===================================================================
--- sleep/tests/output/convertds3.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/convertds3.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -32,9 +32,9 @@
 int[] a
 Collection a
 Collection a
-Warning: there is no method that matches mar([Z at b01afa) in sleep.ArrayTest1 at convertds3.sl:36
-Warning: there is no method that matches mar([F at bb494b) in sleep.ArrayTest1 at convertds3.sl:37
-Warning: there is no method that matches mar([Ljava.lang.Object;@c8efd1) in sleep.ArrayTest1 at convertds3.sl:38
+Warning: there is no method that matches mar([Z at 6835fb) in sleep.ArrayTest1 at convertds3.sl:36
+Warning: there is no method that matches mar([F at b01afa) in sleep.ArrayTest1 at convertds3.sl:37
+Warning: there is no method that matches mar([Ljava.lang.Object;@bb494b) in sleep.ArrayTest1 at convertds3.sl:38
 int[] a
 Collection a
 Collection a

Modified: sleep/tests/output/forker.sl
===================================================================
--- sleep/tests/output/forker.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/forker.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -1,4 +1,4 @@
 Trace: &check('within fork') at forker.sl:9
-Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at b301f2 at forker.sl:8
+Trace: &fork(&closure[forker.sl:9]#2) = sleep.bridges.io.IOObject at 41fab6 at forker.sl:8
 Trace: &sleep(1000) at forker.sl:12
 Trace: &check('outside of fork') at forker.sl:14

Modified: sleep/tests/output/scalar.sl
===================================================================
--- sleep/tests/output/scalar.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/scalar.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -1,4 +1,4 @@
 3
 6.4567
-[B at 922804 and class [B
+[B at c5466b and class [B
 this is a test and class java.lang.String

Modified: sleep/tests/output/trace.sl
===================================================================
--- sleep/tests/output/trace.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/trace.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -1,13 +1,13 @@
 this is a test
-Trace: [java.io.PrintStream at 716cb7 println: 'this is a test'] at trace.sl:6
+Trace: [java.io.PrintStream at e29820 println: 'this is a test'] at trace.sl:6
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at trace.sl:7
 81.0
-Trace: [java.io.PrintStream at 716cb7 println: 81.0] at trace.sl:7
+Trace: [java.io.PrintStream at e29820 println: 81.0] at trace.sl:7
 Trace: [java.lang.Math pow: 3, 5] = 243.0 at trace.sl:8
 243.0
 Trace: &println(243.0) at trace.sl:8
 testing again...
-Trace: [java.io.PrintStream at 716cb7 println: 'testing again...'] at trace.sl:10
+Trace: [java.io.PrintStream at e29820 println: 'testing again...'] at trace.sl:10
 Trace: [sleep.runtime.SleepUtils getListFromArray: @('a', 'b', 'c')] = [a, b, c] at trace.sl:12
 Trace: [new java.util.LinkedList: [a, b, c]] = [a, b, c] at trace.sl:12
 Warning: variable '$list' not declared at trace.sl:12

Modified: sleep/tests/output/wrong.sl
===================================================================
--- sleep/tests/output/wrong.sl	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/tests/output/wrong.sl	2008-03-28 04:00:30 UTC (rev 331)
@@ -1,32 +1,32 @@
 Trace: [java.lang.Math pow: 3, 4] = 81.0 at wrong.sl:6
 81.0
-Trace: [java.io.PrintStream at 8330bf println: 81.0] at wrong.sl:6
+Trace: [java.io.PrintStream at f1916f println: 81.0] at wrong.sl:6
 Trace: &casti(1, 'z') = true at wrong.sl:9
 true
-Trace: [java.io.PrintStream at 8330bf println: true] at wrong.sl:9
+Trace: [java.io.PrintStream at f1916f println: true] at wrong.sl:9
 Trace: &casti(0, 'z') = false at wrong.sl:10
 false
-Trace: [java.io.PrintStream at 8330bf println: false] at wrong.sl:10
+Trace: [java.io.PrintStream at f1916f println: false] at wrong.sl:10
 Trace: &casti(1, 'd') = 1.0 at wrong.sl:13
 1.0
-Trace: [java.io.PrintStream at 8330bf println: 1.0] at wrong.sl:13
+Trace: [java.io.PrintStream at f1916f println: 1.0] at wrong.sl:13
 Trace: &casti(1, 'b') = 1 at wrong.sl:16
 1
-Trace: [java.io.PrintStream at 8330bf println: 1] at wrong.sl:16
+Trace: [java.io.PrintStream at f1916f println: 1] at wrong.sl:16
 Trace: &casti(100, 'f') = 100.0 at wrong.sl:19
 100.0
-Trace: [java.io.PrintStream at 8330bf println: 100.0] at wrong.sl:19
+Trace: [java.io.PrintStream at f1916f println: 100.0] at wrong.sl:19
 Trace: &casti('b', 'c') = b at wrong.sl:22
 b
-Trace: [java.io.PrintStream at 8330bf println: b] at wrong.sl:22
+Trace: [java.io.PrintStream at f1916f println: b] at wrong.sl:22
 Trace: &casti(63, 'i') = 63 at wrong.sl:25
 63
-Trace: [java.io.PrintStream at 8330bf println: 63] at wrong.sl:25
+Trace: [java.io.PrintStream at f1916f println: 63] at wrong.sl:25
 this is a string y0
-Trace: [java.io.PrintStream at 8330bf println: 'this is a string y0'] at wrong.sl:28
+Trace: [java.io.PrintStream at f1916f println: 'this is a string y0'] at wrong.sl:28
 Trace: [new java.lang.StringBuilder: 'test'] = test at wrong.sl:31
 test
-Trace: [java.io.PrintStream at 8330bf println: test] at wrong.sl:31
-Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 57ea4a at wrong.sl:34
+Trace: [java.io.PrintStream at f1916f println: test] at wrong.sl:31
+Trace: &cast(@('a', 'b', 'c', 'd'), 'c') = [C at 608760 at wrong.sl:34
 abcd
-Trace: [java.io.PrintStream at 8330bf println: [C at 57ea4a] at wrong.sl:34
+Trace: [java.io.PrintStream at f1916f println: [C at 608760] at wrong.sl:34

Modified: sleep/whatsnew.txt
===================================================================
--- sleep/whatsnew.txt	2008-03-27 23:59:04 UTC (rev 330)
+++ sleep/whatsnew.txt	2008-03-28 04:00:30 UTC (rev 331)
@@ -1,4 +1,4 @@
-2.1-beta 21  (21 Mar 08)
+2.1-beta 21  (28 Mar 08)
 ===========
 - assignment loops now record proper line number information for
   error reporting purposes.
@@ -38,6 +38,8 @@
   and eventually return a value (retrievable via &wait)
 - fixed a callcc corner case that could lead to an infinite loop
   in the interpreter
+- refactored the SleepUtils.runCode(...) methods to use the
+  standard Sleep mechanism for evaluating functions.
 
 2.1-beta 20  (12 Nov 07)
 ===========



From rsmudge at mail.berlios.de  Fri Mar 28 05:43:48 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 28 Mar 2008 05:43:48 +0100
Subject: [Sleep-svn] r332 - in sleep: . src/sleep/engine/atoms
Message-ID: <200803280443.m2S4hm7X021198@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-28 05:43:48 +0100 (Fri, 28 Mar 2008)
New Revision: 332

Modified:
   sleep/build.xml
   sleep/readme.txt
   sleep/src/sleep/engine/atoms/Assign.java
   sleep/src/sleep/engine/atoms/AssignT.java
Log:
packaging for release.


Modified: sleep/build.xml
===================================================================
--- sleep/build.xml	2008-03-28 04:00:30 UTC (rev 331)
+++ sleep/build.xml	2008-03-28 04:43:48 UTC (rev 332)
@@ -16,7 +16,7 @@
            destdir="${project.build}"
            nowarn="yes"
            depend="yes"
-           debug="true"
+           debug="false"
            source="1.4"
            target="1.4"
            optimize="yes"

Modified: sleep/readme.txt
===================================================================
--- sleep/readme.txt	2008-03-28 04:00:30 UTC (rev 331)
+++ sleep/readme.txt	2008-03-28 04:43:48 UTC (rev 332)
@@ -21,7 +21,6 @@
 and stabilized.  
 
 Sleep Project Homepage: http://sleep.hick.org/
-              (Mirror): http://sleep.berlios.de/
 
  ------- -------------------- ---------   ---------------  ------- ---------
 Documentation
@@ -157,9 +156,9 @@
 Legal Garbage
 -  ------------- -------- -   ---------------- --       -    -     -     - - -
 
-Sleep is (c) 2002, 2003, 2004, 2005, 2006, 2007 Raphael Mudge (raffi at hick.org).  
-All of the source and somehow the documentation are released under the GNU 
-Lesser Public License.  
+Sleep is (c) 2002, 2003, 2004, 2005, 2006, 2007, and 2008 (wow, been at this
+awhile) Raphael Mudge (rsmudge at gmail.com).  All of the source and somehow the 
+documentation are released under the GNU Lesser Public License.  
 
 The scripts and library files supplied as input to or produced as output 
 from the Sleep library do not automatically fall under the copyright of the

Modified: sleep/src/sleep/engine/atoms/Assign.java
===================================================================
--- sleep/src/sleep/engine/atoms/Assign.java	2008-03-28 04:00:30 UTC (rev 331)
+++ sleep/src/sleep/engine/atoms/Assign.java	2008-03-28 04:43:48 UTC (rev 332)
@@ -89,7 +89,7 @@
       }
 
       putv.setValue(value);    
-      e.FrameResult(value);
+      e.KillFrame();
       return null;
    }
 }

Modified: sleep/src/sleep/engine/atoms/AssignT.java
===================================================================
--- sleep/src/sleep/engine/atoms/AssignT.java	2008-03-28 04:00:30 UTC (rev 331)
+++ sleep/src/sleep/engine/atoms/AssignT.java	2008-03-28 04:43:48 UTC (rev 332)
@@ -135,7 +135,8 @@
          putv.setValue(value);
       }
 
-      e.FrameResult(scalar); } catch (Exception ex) { ex.printStackTrace(); }
+      e.KillFrame();
+      } catch (Exception ex) { ex.printStackTrace(); }
       return null;
    }
 }



From rsmudge at mail.berlios.de  Fri Mar 28 06:08:28 2008
From: rsmudge at mail.berlios.de (rsmudge at BerliOS)
Date: Fri, 28 Mar 2008 06:08:28 +0100
Subject: [Sleep-svn] r333 - sleep/src/sleep/engine/atoms
Message-ID: <200803280508.m2S58SRo022508@sheep.berlios.de>

Author: rsmudge
Date: 2008-03-28 06:08:27 +0100 (Fri, 28 Mar 2008)
New Revision: 333

Modified:
   sleep/src/sleep/engine/atoms/Assign.java
   sleep/src/sleep/engine/atoms/AssignT.java
Log:
undoing a silly mistake.



Modified: sleep/src/sleep/engine/atoms/Assign.java
===================================================================
--- sleep/src/sleep/engine/atoms/Assign.java	2008-03-28 04:43:48 UTC (rev 332)
+++ sleep/src/sleep/engine/atoms/Assign.java	2008-03-28 05:08:27 UTC (rev 333)
@@ -89,7 +89,7 @@
       }
 
       putv.setValue(value);    
-      e.KillFrame();
+      e.FrameResult(value);
       return null;
    }
 }

Modified: sleep/src/sleep/engine/atoms/AssignT.java
===================================================================
--- sleep/src/sleep/engine/atoms/AssignT.java	2008-03-28 04:43:48 UTC (rev 332)
+++ sleep/src/sleep/engine/atoms/AssignT.java	2008-03-28 05:08:27 UTC (rev 333)
@@ -135,7 +135,7 @@
          putv.setValue(value);
       }
 
-      e.KillFrame();
+      e.FrameResult(scalar);
       } catch (Exception ex) { ex.printStackTrace(); }
       return null;
    }



